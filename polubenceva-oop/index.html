<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru-RU" xml:lang="ru-RU">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="М. И. Полубенцева" />
  <title>Объектно-ориентированное программирование (C++)</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Arial, sans-serif;
      font-size: 12pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Consolas, monospace;
      background-color: #e4e6e8;
      padding: .2em .4em;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      background-color: #e4e6e8;
      padding: 1em;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #2b91af;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #2b91af;  padding-left: 4px; }
    div.sourceCode
      { color: #000000;  }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; } /* Alert */
    code span.an { background-color: #ff4000; } /* Annotation */
    code span.at { color: #0000ff; } /* Attribute */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #8f08c4; } /* ControlFlow */
    code span.ch { color: #008080; } /* Char */
    code span.cn { background-color: #ff4000; } /* Constant */
    code span.co { color: #008000; } /* Comment */
    code span.cv { color: #008000; } /* CommentVar */
    code span.do { color: #008000; } /* Documentation */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { background-color: #ff4000; } /* Extension */
    code span.im { color: #e21f1f; } /* Import */
    code span.in { color: #008000; } /* Information */
    code span.kw { color: #0000ff; } /* Keyword */
    code span.op { color: #008080; } /* Operator */
    code span.ot { color: #0000ff; } /* Other */
    code span.pp { color: #808080; } /* Preprocessor */
    code span.sc { color: #b776fb; } /* SpecialChar */
    code span.ss { background-color: #ff4000; } /* SpecialString */
    code span.st { color: #a31515; } /* String */
    code span.va { color: #49377f; } /* Variable */
    code span.vs { color: #a31515; } /* VerbatimString */
    code span.wa { color: #008000; font-weight: bold; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>
  #TOC li {
    font-family:'Times New Roman', serif;
  }
  #TOC > ul > li {
    font-style: italic;
    font-weight: bold;
    font-size: 1.2rem;
  }
  #TOC ul ul li {
    font-weight: bold;
    font-style: normal;
    font-size: 1.1rem;
  }
  #TOC ul ul ul li {
    font-style: normal;
    font-weight: normal;
    font-size: 1rem;
  }
  ul, ol {
    padding-left: 1cm;
  }
  ul li, ol li {
    padding-left: 0.5cm;
  }
  #TOC ul {
    padding-left: 1em;
  }
  #TOC ul li {
    padding-left: 0;
  }
  blockquote {
    margin: 1em 0 1em;
    border: 2px solid #e6e6e6;
  }
  p .sourceCode {
    background-color: #e4e6e8;
  }
  tr.even {
    border-top: 1px solid #1a1a1a8c;
    border-bottom: 1px solid #1a1a1a8c;
  }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Объектно-ориентированное программирование (C++)</h1>
<p class="author">М. И. Полубенцева</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#тема-i.-базовые-понятия-объектно-ориентированного-программирования-ооп-и-их-реализация-средствами-c">Тема I. Базовые понятия объектно-ориентированного программирования (ООП) и их реализация средствами C++</a>
<ul>
<li><a href="#введение">Введение</a></li>
<li><a href="#понятия-связанные-с-ооп">Понятия, связанные с ООП</a></li>
<li><a href="#отличия-процедурного-и-объектно-ориентированного-подходов">Отличия процедурного и объектно-ориентированного подходов</a>
<ul>
<li><a href="#решение-в-стиле-си-процедурный-подход">Решение в стиле Си (процедурный подход)</a></li>
<li><a href="#использование-структур-си-укрупнение-данных">Использование структур Си (укрупнение данных)</a></li>
</ul></li>
<li><a href="#объявление-класса">Объявление класса</a></li>
<li><a href="#спецификаторы-привилегии-доступа">Спецификаторы (привилегии) доступа</a>
<ul>
<li><a href="#зачем-нужны-привилегии-доступа">Зачем нужны привилегии доступа</a></li>
<li><a href="#спецификаторы-доступа-c">Спецификаторы доступа C++</a></li>
</ul></li>
<li><a href="#создание-объекта-экземпляра-класса">Создание объекта (экземпляра) класса</a></li>
<li><a href="#оператор-sizeof-применительно-к-классам">Оператор <code>sizeof</code> применительно к классам</a></li>
<li><a href="#определение-peaлизация-методов-класса">Определение (peaлизация) методов класса</a>
<ul>
<li><a href="#встроенные-inline-методы">Встроенные (<code>inline</code>) методы</a></li>
<li><a href="#невстроенные-методы">Невстроенные методы</a></li>
</ul></li>
<li><a href="#доступ-к-public-членам-класса-посредством-объекта-или-ссылки.-селектор-.">Доступ к <code>public</code> членам класса посредством объекта (или ссылки). Селектор «<code>.</code>»</a>
<ul>
<li><a href="#доступ-к-public-переменным">Доступ к <code>public</code> переменным</a></li>
<li><a href="#вызов-public-метода-класса-нестатического.-указатель-this">Вызов <code>public</code> метода класса (нестатического). Указатель <code>this</code></a></li>
</ul></li>
<li><a href="#конструкторы">Конструкторы</a>
<ul>
<li><a href="#конструктор-по-умолчанию-default-constructor">Конструктор по умолчанию (default constructor)</a></li>
<li><a href="#конструктор-с-параметрами">Конструктор с параметрами</a></li>
<li><a href="#специфика-записи-при-вызове-конструктора-с-одним-параметром">Специфика записи при вызове конструктора с одним параметром</a></li>
<li><a href="#конструкторы-и-модификатор-explicit">Конструкторы и модификатор <code>explicit</code></a></li>
<li><a href="#конструкторы-базовых-типов">Конструкторы базовых типов</a></li>
<li><a href="#перегрузка-конструкторов">Перегрузка конструкторов</a></li>
<li><a href="#конструктор-с-параметрами-по-умолчанию">Конструктор с параметрами по умолчанию</a></li>
<li><a href="#возможные-конфликты-при-использовании-параметров-по-умолчанию">Возможные конфликты при использовании параметров по умолчанию</a></li>
<li><a href="#динамическое-создание-объектов">Динамическое создание объектов</a></li>
</ul></li>
<li><a href="#деструкторы">Деструкторы</a>
<ul>
<li><a href="#деструктор-метод-класса.-конструктор-деструктор-функциональное-замыкание">Деструктор — метод класса. Конструктор + деструктор = функциональное замыкание</a></li>
</ul></li>
<li><a href="#когда-вызываются-конструкторы-и-деструкторы">Когда вызываются конструкторы и деструкторы</a></li>
<li><a href="#конструктор-копирования">Конструктор копирования</a>
<ul>
<li><a href="#создание-копий-объектов">Создание копий объектов</a></li>
<li><a href="#передача-объекта-в-качестве-параметра-по-значению">Передача объекта в качестве параметра по значению</a></li>
<li><a href="#возвращение-объекта-по-значению">Возвращение объекта по значению</a></li>
<li><a href="#стандарт-с11-move-конструктор-копирования">Стандарт С++11 — move конструктор копирования</a></li>
</ul></li>
<li><a href="#ключевое-слово-const-и-классы">Ключевое слово <code>const</code> и классы</a>
<ul>
<li><a href="#const-и-возвращаемое-значение"><code>const</code> и возвращаемое значение</a></li>
<li><a href="#константные-методы-класса.-константные-объекты">Константные методы класса. Константные объекты</a></li>
<li><a href="#константные-методы-класса-и-ключевое-слово-mutable">Константные методы класса и ключевое слово <code>mutable</code></a></li>
<li><a href="#константные-объекты">Константные объекты</a></li>
<li><a href="#тип-указателя-this">Тип указателя <code>this</code></a></li>
</ul></li>
<li><a href="#указатель-на-класс.-доступ-к-членам-класса-посредством-указателя.-селектор--">Указатель на класс. Доступ к членам класса посредством указателя. Селектор «<code>-&gt;</code>»</a>
<ul>
<li><a href="#использование-указателя">Использование указателя</a></li>
</ul></li>
<li><a href="#массивы-и-классы">Массивы и классы</a>
<ul>
<li><a href="#массив-объектов-класса">Массив объектов класса</a></li>
</ul></li>
<li><a href="#поля-битов-bit-fields">Поля битов (bit fields)</a></li>
<li><a href="#список-инициализаторов">Список инициализаторов</a></li>
</ul></li>
<li><a href="#тема-ii.-открытое-одиночное-наследование">Тема II. Открытое одиночное наследование</a>
<ul>
<li><a href="#взаимоотношения-между-классами">Взаимоотношения между классами</a></li>
<li><a href="#одиночное-или-простое-наследование">Одиночное (или простое) наследование</a>
<ul>
<li><a href="#объявление-производного-класса-при-одиночном-наследовании">Объявление производного класса при одиночном наследовании</a></li>
<li><a href="#спецификатор-protected-в-базовом-классе">Спецификатор <code>protected</code> в базовом классе</a></li>
<li><a href="#спецификаторы-наследования-при-объявлении-производного-класса">Спецификаторы наследования при объявлении производного класса</a></li>
<li><a href="#порядок-вызовов-конструкторов-при-создании-экземпляра-производного-класса">Порядок вызовов конструкторов при создании экземпляра производного класса</a></li>
<li><a href="#порядок-вызовов-деструкторов-при-разрушении-экземпляра-производного-класса">Порядок вызовов деструкторов при разрушении экземпляра производного класса</a></li>
<li><a href="#аргументы-конструктора-передаваемые-в-базовый-класс">Аргументы конструктора, передаваемые в базовый класс</a></li>
<li><a href="#открытое-public-наследование">Открытое (<code>public</code>) наследование</a></li>
</ul></li>
<li><a href="#полиморфизм.-виртуальные-функции">Полиморфизм. Виртуальные функции</a>
<ul>
<li><a href="#раннее-и-позднее-связывание">Раннее и позднее связывание</a></li>
<li><a href="#наследование-интерфейса-и-наследование-реализации-при-открытом-наследовании">Наследование интерфейса и наследование реализации при открытом наследовании</a></li>
<li><a href="#механизм-наследования-интерфейса-и-реализации-посредством-таблиц-виртуальных-функций">Механизм наследования интерфейса и реализации посредством таблиц виртуальных функций</a></li>
</ul></li>
</ul></li>
<li><a href="#тема-iii.-понятие-friend">Тема III. Понятие <code>friend</code></a>
<ul>
<li><a href="#friend-привилегированные-функции-и-классы"><code>friend</code> (привилегированные) функции и классы</a>
<ul>
<li><a href="#внешняя-глобальная-friend-функция">Внешняя (глобальная) <code>friend</code>-функция</a></li>
<li><a href="#friend-класс"><code>friend</code>-класс</a></li>
<li><a href="#friend-метод-другого-класса">friend-метод другого класса</a></li>
</ul></li>
</ul></li>
<li><a href="#тема-iv.-перегрузка-операторов">Тема IV. Перегрузка операторов</a>
<ul>
<li><a href="#перегрузка-операторов-для-базовых-и-пользовательских-типов">Перегрузка операторов для базовых и пользовательских типов</a></li>
<li><a href="#специфика-перегружаемых-операторов">Специфика перегружаемых операторов</a></li>
<li><a href="#способы-перегрузки-операторов">Способы перегрузки операторов</a></li>
<li><a href="#порядок-поиска-компилятором-перегруженного-оператора">Порядок поиска компилятором перегруженного оператора</a></li>
<li><a href="#перегрузка-операторов-методом-класса">Перегрузка операторов методом класса</a>
<ul>
<li><a href="#operator-memberwise-assignment"><code>operator=</code> (memberwise assignment)</a></li>
<li><a href="#стандарт-с11-move-operator">Стандарт С++11 move <code>operator=</code></a></li>
<li><a href="#перегрузка-оператора">Перегрузка оператора <code>[]</code></a></li>
<li><a href="#перегрузка-оператора---">Перегрузка оператора <code>++</code> (<code>--</code>)</a></li>
<li><a href="#перегрузка-оператора-приведения-типа">Перегрузка оператора приведения типа</a></li>
<li><a href="#перегрузка-оператора--.-умные-указатели">Перегрузка оператора <code>-&gt;</code>. Умные указатели</a></li>
<li><a href="#перегрузка-оператора-.-функциональные-объекты">Перегрузка оператора <code>()</code>. Функциональные объекты</a></li>
<li><a href="#специфика-при-использовании-перегруженных-операторов-в-классах-с-конструктором-принимающим-один-параметр">Специфика при использовании перегруженных операторов в классах с конструктором, принимающим один параметр</a></li>
</ul></li>
<li><a href="#перегрузка-оператора-с-помощью-глобальной-функции">Перегрузка оператора с помощью глобальной функции</a>
<ul>
<li><a href="#перегрузка-оператора-проверка-на-равенство">Перегрузка оператора «<code>==</code>» (проверка на равенство)</a></li>
<li><a href="#перегрузка-оператора-вывод-в-библиотечный-ostream">Перегрузка оператора <code>&lt;&lt;</code> (вывод в библиотечный <code>ostream</code>)</a></li>
<li><a href="#перегрузка-перегруженных-глобальными-функциями-операторов">Перегрузка перегруженных глобальными функциями операторов</a></li>
</ul></li>
<li><a href="#правила-выбора-формы-перегрузки-операторов">Правила выбора формы перегрузки операторов</a></li>
</ul></li>
<li><a href="#тема-v.-сложные-указатели.-указатели-на-члены-класса">Тема V. Сложные указатели. Указатели на члены класса</a></li>
<li><a href="#тема-vi.-встроенные-объекты-composition.-отношение-между-классами-содержит">Тема VI. Встроенные объекты (composition). Отношение между классами «содержит»</a>
<ul>
<li><a href="#понятие-встроенного-объекта">Понятие встроенного объекта</a></li>
<li><a href="#конструирование-и-уничтожение-встроенных-объектов">Конструирование и уничтожение встроенных объектов</a></li>
<li><a href="#передача-параметров-конструктора-встроенным-объектам.-список-инициализации-конструктора">Передача параметров конструктора встроенным объектам. Список инициализации конструктора</a></li>
<li><a href="#когда-без-списка-инициализации-не-обойтись">Когда без списка инициализации не обойтись</a></li>
<li><a href="#порядок-инициализации-членов-класса">Порядок инициализации членов класса</a></li>
<li><a href="#пример-использования-встроенных-объектов-для-построения-квадратов-посредством-прямоугольников">Пример использования встроенных объектов для построения квадратов посредством прямоугольников</a></li>
<li><a href="#пример-использования-встроенных-объектов-ассоциативный-массив">Пример использования встроенных объектов «ассоциативный массив»</a></li>
<li><a href="#указатели-на-объекты-в-качестве-членов-данных-класса">Указатели на объекты в качестве членов данных класса</a></li>
<li><a href="#ссылки-на-указатели">Ссылки на указатели</a></li>
<li><a href="#объектно-ориентированный-двухсвязный-список-однородный.-вложенные-объявления-классов">Объектно-ориентированный двухсвязный список (однородный). Вложенные объявления классов</a></li>
<li><a href="#специфика-использования-безразмерных-массивов">Специфика использования безразмерных массивов</a></li>
<li><a href="#предварительное-неполное-объявление-класса-forward-declaration">Предварительное неполное объявление класса (forward declaration)</a></li>
</ul></li>
<li><a href="#тема-vii.-статические-члены-класса">Тема VII. Статические члены класса</a>
<ul>
<li><a href="#статические-данные">Статические данные</a>
<ul>
<li><a href="#пример-использования-статических-переменных.-определение-имени-класса-объекта-во-время-выполнения">Пример использования статических переменных. Определение имени класса объекта во время выполнения</a></li>
</ul></li>
<li><a href="#статические-методы">Статические методы</a>
<ul>
<li><a href="#использование-статических-методов-для-доступа-извне-к-private-или-protected-static-данным-класса">Использование статических методов для доступа извне к <code>private</code> или <code>protected</code> <code>static</code>-данным класса</a></li>
<li><a href="#производящие-функции-классов-виртуальный-конструктор">Производящие функции классов («виртуальный конструктор»)</a></li>
</ul></li>
</ul></li>
<li><a href="#тема-viii.-структуры-и-объединения-c">Тема VIII. Структуры и объединения C++</a>
<ul>
<li><a href="#структура-c">Структура C++</a></li>
<li><a href="#объединения-c">Объединения C++</a>
<ul>
<li><a href="#анонимные-объединения-классы-структуры">Анонимные объединения (классы, структуры)</a></li>
</ul></li>
</ul></li>
<li><a href="#тема-ix.-защищенное-наследование.-отношение-между-классами-подобен">Тема IX. Защищенное наследование. Отношение между классами — «подобен»</a>
<ul>
<li><a href="#цель">Цель</a></li>
<li><a href="#friend"><code>friend</code></a></li>
<li><a href="#защищенное-наследование-при-построении-иерархий-классов">Защищенное наследование при построении иерархий классов</a></li>
</ul></li>
<li><a href="#тема-x.-множественное-наследование">Тема X. Множественное наследование</a>
<ul>
<li><a href="#простой-пример-без-полиморфизма">Простой пример (без полиморфизма)</a></li>
<li><a href="#множественное-наследование-и-полиморфизм">Множественное наследование и полиморфизм</a></li>
<li><a href="#проблемы-возникающие-при-множественном-наследовании">Проблемы, возникающие при множественном наследовании</a></li>
</ul></li>
<li><a href="#тема-xi.-механизм-rtti-run-time-type-identification">Тема XI. Механизм RTTI (run-time type identification)</a>
<ul>
<li><a href="#оператор-static_cast-и-указатели-на-классы-связанные-наследованием">Оператор <code>static_cast</code> и указатели на классы связанные наследованием</a></li>
<li><a href="#динамическая-идентификация-типа">Динамическая идентификация типа</a>
<ul>
<li><a href="#подключение-rtti">Подключение RTTI</a></li>
<li><a href="#оператор-typeid-и-класс-type_info">Оператор <code>typeid</code> и класс <code>type_info</code></a></li>
<li><a href="#пример-использования-оператора-typeid">Пример использования оператора <code>typeid</code></a></li>
<li><a href="#оператор-dynamic_cast">Оператор <code>dynamic_cast</code></a></li>
<li><a href="#операторы-typeid-и-dynamic_cast-и-наследование">Операторы typeid и <code>dynamic_cast</code> и наследование</a></li>
</ul></li>
<li><a href="#когда-возникает-необходимость-rtti">Когда возникает необходимость RTTI</a></li>
</ul></li>
<li><a href="#тема-xii.-исключительные-ситуации-exceptions">Тема XII. Исключительные ситуации (exceptions)</a>
<ul>
<li><a href="#что-такое-исключительные-ситуации">Что такое исключительные ситуации</a></li>
<li><a href="#способы-отслеживания-аварийных-ситуаций">Способы отслеживания «аварийных» ситуаций</a>
<ul>
<li><a href="#прекращение-выполнения-программы">Прекращение выполнения программы</a></li>
<li><a href="#возвращение-функцией-значения-статуса-кода-завершения">Возвращение функцией значения статуса (кода завершения)</a></li>
<li><a href="#статус-завершения-системных-вызовов">Статус завершения системных вызовов</a></li>
<li><a href="#выявление-ошибок-в-debug-версии">Выявление ошибок в Debug-версии</a></li>
<li><a href="#обработка-ошибок-с-помощью-функций-обратного-вызова">Обработка ошибок с помощью функций обратного вызова</a></li>
<li><a href="#выполнение-глобального-перехода-при-возникновении-ошибки">Выполнение глобального перехода при возникновении ошибки</a></li>
<li><a href="#малоизвестная-и-малоиспользуемая-часть-старой-стандартной-библиотеки-с">Малоизвестная и малоиспользуемая часть старой стандартной библиотеки С</a></li>
</ul></li>
<li><a href="#встроенные-средства-c-для-обработки-исключений-c-exception-handling">Встроенные средства C++ для обработки исключений (C++ exception handling)</a>
<ul>
<li><a href="#оператор-throw-сравнение-с-return">Оператор <code>throw</code> — сравнение с <code>return</code></a></li>
<li><a href="#операторы-try-и-catch">Операторы <code>try</code> и <code>catch</code></a></li>
<li><a href="#пример">Пример</a></li>
<li><a href="#обработка-нескольких-типов-исключений">Обработка нескольких типов исключений</a></li>
<li><a href="#обработчики-исключений-могут">Обработчики исключений могут</a></li>
<li><a href="#function-level-try-блок">Function-level <code>try</code>-блок</a></li>
</ul></li>
<li><a href="#последовательность-выполнения-кода-и-выбор-исключений">Последовательность выполнения кода и выбор исключений</a>
<ul>
<li><a href="#обработка-непредусмотренных-исключений">Обработка непредусмотренных исключений</a></li>
<li><a href="#обработка-неперехваченных-исключений">Обработка неперехваченных исключений</a></li>
<li><a href="#спецификация-исключений">Спецификация исключений</a></li>
</ul></li>
<li><a href="#специфика-оператора-new">Специфика оператора <code>new</code></a></li>
<li><a href="#исключения-в-конструкторах-и-деструкторах">Исключения в конструкторах и деструкторах</a></li>
<li><a href="#исключения-и-наследование">Исключения и наследование</a></li>
<li><a href="#стандартные-исключения">Стандартные исключения</a></li>
</ul></li>
<li><a href="#тема-xiii.-обобщенное-программирование">Тема XIII. Обобщенное программирование</a>
<ul>
<li><a href="#идеи-обобщенного-программирования.-зачем-нужны-шаблоны.-понятия-связанные-с-шаблонами">Идеи обобщенного программирования. Зачем нужны шаблоны. Понятия, связанные с шаблонами</a>
<ul>
<li><a href="#объявление-шаблона-общее">Объявление шаблона (общее)</a></li>
<li><a href="#термины-связанные-с-шаблонами">Термины, связанные с шаблонами</a></li>
</ul></li>
<li><a href="#шаблоны-функций">Шаблоны функций</a>
<ul>
<li><a href="#способы-обобщения-функций-выполняющих-одинаковые-действия-но-оперирующих-данными-разных-типов">Способы обобщения функций, выполняющих одинаковые действия, но оперирующих данными разных типов</a></li>
<li><a href="#шаблоны-функций-и-объекты-пользовательского-типа">Шаблоны функций и объекты пользовательского типа</a></li>
<li><a href="#шаблоны-классов">Шаблоны классов</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<p><em>На Си Вы можете просто делать ошибки.</em></p>
<p><em>на C++ Вы сможете их также наследовать!</em></p>
<h1 id="тема-i.-базовые-понятия-объектно-ориентированного-программирования-ооп-и-их-реализация-средствами-c">Тема I. Базовые понятия объектно-ориентированного программирования (ООП) и их реализация средствами C++</h1>
<h2 id="введение">Введение</h2>
<p>C++ является гибридным языком программирования. Это означает, что он совмещает как процедурные возможности (заимствованные из Си), так и объектно-ориентированные средства, позволяющие разработчику:</p>
<ul>
<li><p>создавать собственные пользовательские типы данных (классы) для описания объектов реального мира</p></li>
<li><p>и манипулировать объектами такого пользовательского типа также просто, как переменными базового типа.</p></li>
</ul>
<p>Одну и ту же задачу можно решить как в процедурном стиле, так и в объектно-ориентированном. Следует помнить, что в зависимости от выбранного способа реализации задачи, программист по-разному строит свою программу (это справедливо для всех этапов разработки) и должен учитывать следующее:</p>
<ul>
<li><p>при процедурном подходе акцент делается в основном на реализацию программы посредством эффективных функций. Такой подход хорош для небольших программ, в которых требуется оптимизировать время выполнения и/или объем занимаемой памяти;</p></li>
<li><p>при объектно-ориентированном подходе время выполнения, да и объем памяти неизбежно увеличиваются, но при создании больших программных продуктов программист все равно получает выигрыш, выражаемый в конечном итоге в уменьшении трудоемкости.</p></li>
</ul>
<p><img src="media/image1.svg" /></p>
<h2 id="понятия-связанные-с-ооп">Понятия, связанные с ООП</h2>
<p><img src="media/image2.svg" /></p>
<h2 id="отличия-процедурного-и-объектно-ориентированного-подходов">Отличия процедурного и объектно-ориентированного подходов</h2>
<p>На примере одной и той же задачи попробую показать разные способы ее решения и отметить разницу в реализации при переходе от процедурного</p>
<p>Объектно-ориентированное программирование (C++) решения к объектно-ориентированному. Исходными данными являются: день месяца, месяц, год. Требуется вычислить порядковый день в году. Например, первому марта 2006 года соответствует 60-ый порядковый день года.</p>
<p>При описании каждого способа будем исходить из того, что задачу можно разделить на две части: есть сервер, который предоставляет требуемый сервис, а также существуют клиенты, которые хотят использовать предоставляемый сервис. Посмотрим, как меняются взаимоотношения между клиентом и сервером при переходе от процедурного к объектно-ориентированному способу.</p>
<h3 id="решение-в-стиле-си-процедурный-подход">Решение в стиле Си (процедурный подход)</h3>
<p>Замечание: процедурное решение этой задачи было приведено в качестве примера еще создателями языка Си (Керниган и Ричи).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">//сервер:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> DayOfYear<span class="op">(</span><span class="dt">int</span> day<span class="op">,</span> <span class="dt">int</span> month<span class="op">,</span> <span class="dt">int</span> year<span class="op">)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Вспомогательный массив, содержащий количество дней в</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//каждом месяце</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ar<span class="op">[][</span><span class="dv">12</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="op">{</span><span class="dv">31</span><span class="op">,</span> <span class="dv">28</span><span class="op">,</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="op">...},</span>   <span class="co">//не високосный год</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                     <span class="op">{</span><span class="dv">31</span><span class="op">,</span> <span class="dv">29</span><span class="op">,</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="op">...}</span> <span class="op">};</span> <span class="co">//високосный год</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Определяю — по какой строчке суммировать</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> I <span class="op">=</span> <span class="op">(</span>year <span class="op">%</span> <span class="dv">4</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&amp;&amp;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">((</span>year <span class="op">%</span> <span class="dv">100</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">||</span> <span class="op">(</span>year <span class="op">%</span> <span class="dv">400</span> <span class="op">==</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="op">(</span>month <span class="op">-</span> <span class="dv">1</span><span class="op">);</span> i<span class="op">++)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        day <span class="op">+=</span> ar<span class="op">[</span>I<span class="op">][</span>i<span class="op">];</span>  <span class="co">//копим порядковый день года</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> day<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">//клиент</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> m1 <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> y1 <span class="op">=</span> <span class="dv">2006</span><span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> DayOfYear<span class="op">(</span>d1<span class="op">,</span> m1<span class="op">,</span> y1<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  <span class="co">//вызов</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d100 <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> m100 <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> y100 <span class="op">=</span> <span class="dv">2004</span><span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> DayOfYear<span class="op">(</span>d100<span class="op">,</span> m100<span class="op">,</span> y100<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  <span class="co">//вызов</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Неудобства: — оперирую с разными датами, их много -&gt; все время</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">//придется помнить, какая тройка переменных к какой дате</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">//относится</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Графически вызов функции можно представить:</p>
<p><img src="media/image3.svg" /></p>
<p>Важно:</p>
<ul>
<li><p>данные для совершения сервером действия предоставляет клиент!</p></li>
<li><p>данных много!</p></li>
<li><p>о том, что несколько элементов данных относятся к одной сущности (дате), знает только программист!</p></li>
<li><p>«накладные расходы» компилятора на вызов такой функции достаточно высоки, так как каждое данное передается отдельно (память для формирования параметров в стеке + время).</p></li>
</ul>
<h3 id="использование-структур-си-укрупнение-данных">Использование структур Си (укрупнение данных)</h3>
<p>Это развитие процедурной подхода. Такой способ просто позволяет сгруппировать данные, относящиеся к одной сущности, посредством структуры.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Date</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> year<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> month<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> day<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">//сервер:</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> DayOfYear<span class="op">(</span><span class="at">const</span> <span class="co">/*struct*/</span> Date<span class="op">*</span> date<span class="op">)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ar<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">12</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="op">{</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">28</span><span class="op">,</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="op">...</span> <span class="op">},</span>  <span class="co">//не високосный год</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                      <span class="op">{</span><span class="dv">31</span><span class="op">,</span> <span class="dv">29</span><span class="op">,</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span> <span class="op">};</span> <span class="co">//високосный год</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> I <span class="op">=</span> <span class="op">(</span>date<span class="op">-&gt;</span>year <span class="op">%</span> <span class="dv">4</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&amp;&amp;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">((</span>date<span class="op">-&gt;</span>year <span class="op">%</span> <span class="dv">100</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">||</span> <span class="op">(</span>date<span class="op">-&gt;</span>year <span class="op">%</span> <span class="dv">400</span> <span class="op">==</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> YearDay <span class="op">=</span> date<span class="op">-&gt;</span>day<span class="op">;</span><span class="co">//здесь будем копить порядковый день</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//года, так как нелогично «портить»</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//содержимое по адресу date</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> date<span class="op">-&gt;</span>month <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        YearDay <span class="op">+=</span> ar<span class="op">[</span>I<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> YearDay<span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">//клиент:</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="co">//</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    Date d1 <span class="op">=</span> <span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">2006</span> <span class="op">};</span> <span class="co">//создание и инициализация переменной</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>                              <span class="co">//типа Date</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> DayOfYear<span class="op">(&amp;</span>d1<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="co">//передача параметра</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                                              <span class="co">//по указателю</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    Date d100 <span class="op">=</span> <span class="op">{</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">2006</span> <span class="op">};</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> DayOfYear<span class="op">(&amp;</span>d100<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><img src="media/image4.svg" /></p>
<p>Важно:</p>
<ul>
<li><p>данные сгруппированы посредством структуры</p></li>
<li><p>данные все еще на стороне клиента!</p></li>
<li><p>зато за счет укрупнения данных программисту нужно запоминать гораздо меньше</p></li>
<li><p>и объем передаваемой информации тоже сократился (передается только адрес структурной переменной)! Замечание: если передавать объект по значению, то экономии памяти не будет.</p></li>
</ul>
<h4 id="использование-классов-c">1.1.1. Использование классов C++</h4>
<p>Объектно-ориентированный подход позволяет в одном типе совместить как данные, описывающие этот объект, так и операции над этими данными.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">//сервер:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Date</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> year<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> month<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> day<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> IsLeapYear<span class="op">()</span><span class="co">//аргументы не передаются!!! — метод выполняет</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//действия над данными объекта! ! !</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>year <span class="op">%</span> <span class="dv">4</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&amp;&amp;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">((</span>year <span class="op">%</span> <span class="dv">100</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">||</span> <span class="op">(</span>year <span class="op">%</span> <span class="dv">400</span> <span class="op">==</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span> <span class="co">//спецификатор доступа понятие будет введено позже</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> DayOfYear<span class="op">()</span><span class="co">//параметры не передаются!!! Это не обычная</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//Функция, а метод класса, который обращается к</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//данным того объекта, для которого он был</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//вызван!!!</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ar<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">12</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="op">{</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">28</span><span class="op">,</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="op">...</span> <span class="op">},</span><span class="co">//не високосный год</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>                          <span class="op">{</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">29</span><span class="op">,</span> <span class="dv">31</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span> <span class="op">};</span> <span class="co">//високосный год</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> I <span class="op">=</span> IsLeapYear<span class="op">();</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> YearDay <span class="op">=</span> day<span class="op">;</span><span class="co">//здесь будем копить порядковый день года</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> month <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            YearDay <span class="op">+=</span> ar<span class="op">[</span>I<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> YearDay<span class="op">;</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co">//клиент:</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    Date my<span class="op">;</span> <span class="co">//создание объекта типа Date</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> <span class="co">//Инициализация членов данных объекта — пока не привожу код</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> my<span class="op">.</span>DayOfYear<span class="op">();</span> <span class="co">//вызов метода класса. Эта функция</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//не принимает параметров.Она</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//высчитывает порядковый день года,</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//исходя из данных объекта my</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><img src="media/image5.svg" /></p>
<p><em>Важно: данные на стороне сервера!</em></p>
<p>Главный принцип ООП — не получайте посредством объекта данные, необходимые для совершения Вашей операции — вместо этого «попросите» объект, содержащий данные, сделать эту операцию с его (объекта) данными для Вас. Этот принцип называется <strong>делегированием</strong> (delegation).</p>
<h2 id="объявление-класса">Объявление класса</h2>
<p>Класс — это определяемый пользователем тип данных. Если класс хорошо сконструирован, использование экземпляров такого пользовательского типа ничем не отличается от использования переменных базовых типов: они могут передаваться в функцию в качестве параметра, могут быть скомпонованы в массив и т.д. Отличие — базовые типы для компилятора — «родные» (встроенные), а о Вашем пользовательском типе компилятор ничего не знает, поэтому использованию класса должно предшествовать его объявление (описание для компилятора свойств объектов пользовательского типа). Объявление класса — это заготовка для компилятора, по которой он будет строить реальный экземпляр <em>(объект)</em> данного типа.</p>
<p>Принципиальным отличием классов от старых структур Си является объединение (инкапсуляция) в одной программной единице, как данных, так и методов для работы с этими данными. Определяя термин «инкапсуляция», говорят также, что переменные класса (member variables) инкапсулированы вместе с набором функций (member functions) для работы с этими переменными. Полученный в результате класс — это программный модуль, который можно использовать как строительный блок при разработке приложения (приложений).</p>
<blockquote>
<p>3амечание: объявление класса рекомендуется помещать в заголовочный файл.</p>
</blockquote>
<p><img src="media/image6.svg" /></p>
<p>Формально простейшее объявление класса выглядит так:</p>
<p><img src="media/image7.svg" /></p>
<p><code>список_членов_класса</code> — включает описание как типов и имен переменных (member variables), так и прототипы функций класса (member functions), которые принято в русскоязычной литературе называть методами.</p>
<p>Замечание: <code>;</code> после закрывающей фигурной скобки обязательна!</p>
<p>Какую информацию получает компилятор, встречая объявления класса:</p>
<ul>
<li><p>объявлен новый пользовательский (агрегатный) тип данных;</p></li>
<li><p>имена и типы членов класса: типы переменных (эту информацию компилятор использует прежде всего для вычисления количества памяти, необходимой для хранения экземпляра данного класса) и прототипы функций;</p></li>
<li><p>ограничения по использованию функций и переменных класса (эту информацию компилятор извлекает из указанных программистом спецификаторов доступа).</p></li>
</ul>
<p>Основное назначение классов — описывать объекты реального мира. В некотором смысле проектирование класса — это моделирование. Удобно начинать строить модель с очень грубого приближения, учитывая только некоторые (важные на взгляд программиста) свойства и наращивать функциональность по мере разработки. В качестве примера начинаем разрабатывал класс, абстрагирующий животное. Конечно, можно придумать много свойств, присущих любому животному, но я для начала выбираю лишь несколько (преследуя учебные цели). Например:</p>
<p>Файл <code>Animal.h</code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> SEX</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    MALE<span class="op">,</span> FEMALE</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span> <span class="co">//для тех, кто не очень дружен с английским языком: SEX — это</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   <span class="co">//пол, который за редким исключением может быть только мужским</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">//или женским</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> <span class="va">m_age</span><span class="op">;</span> <span class="co">//возраст (не может быть отрицательным, не</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//должен уменьшаться, есть естественные</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//ограничения)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="va">m_bHasMaster</span><span class="op">;</span><span class="co">//ecть/нeт хозяина (хозяева появляются и, к</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//сожалению, пропадают)</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    SEX <span class="va">m_sex</span><span class="op">;</span> <span class="co">//пол (может измениться только в случае</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>               <span class="co">//хирургического вмешательства, обычно не изменяется</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>               <span class="co">//на протяжении жизни)</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Замечание 1: большинство разработчиков Microsoft использует для имен переменных класса префикс <code>m_</code> (от слова member). По моему мнению, это удобно, так как позволяет в тексте программы легко отличать переменные класса от обычных переменных.</p>
<p>Замечание 2: в объявлении класса за очень немногими исключениями (например, <code class="sourceCode cpp"><span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> n<span class="op">=</span><span class="dv">1</span><span class="op">;</span></code>) могут быть только объявления переменных, прототипы методов и тела inline-методов!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> <span class="va">m_age</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//в этой строке компилятор выдаст ошибку</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="спецификаторы-привилегии-доступа">Спецификаторы (привилегии) доступа</h2>
<p>При объявлении класса программист с помощью спецификаторов доступа (ключевых слов C++) формирует компилятору правила ограничения области видимости для разных членов класса (переменных или методов). Другими словами, привилегии доступа это способ указать компилятору, где в тексте программы можно обращаться к члену класса: в любом произвольном месте программы (в частности извне класса) или только в методах класса. Посредством указанного при объявлении члена класса спецификатора компилятор в дальнейшем будет производить контроль: есть ли право использовать указанное имя в данном контексте (и «обмануть» компилятор достаточно трудно).</p>
<blockquote>
<p>Замечание: спецификаторы доступа применимы также к вложенным классам и перечислениям.</p>
</blockquote>
<h3 id="зачем-нужны-привилегии-доступа">Зачем нужны привилегии доступа</h3>
<p>При проектировании класса разработчик должен исходить из того, что разработанный и отлаженный класс может пригодиться как ему самому в будущем при решении другой задачи, так и другому программисту, поэтому существуют правила, которых рекомендуется придерживаться.</p>
<h4 id="защита-данных-от-несанкционированного-использования">1.1.2. Защита данных от несанкционированного использования</h4>
<p>Если бы привилегий доступа не было и все члены класса были общедоступны (как поля Си структур), для разрабатываемого класса <code>Animal</code> были бы вполне возможны следующие нелогичные с точки зрения моделирования объектов реального мира действия:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">//animal.h</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Animal</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> <span class="va">m_age</span><span class="op">;</span> <span class="co">//переменная общедоступна</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;animal.h&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    Animal an<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    an<span class="op">.</span><span class="va">m_age</span> <span class="op">=</span> <span class="op">-</span><span class="dv">100</span><span class="op">;</span> <span class="co">//компилятор выдаст предупреждение</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//опреобразовании знакового вбеззнаковое, но</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//выполнит, и получится животное, которое уже</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//прожило много веков</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    an<span class="op">.</span><span class="va">m_age</span> <span class="op">=</span> <span class="dv">10000</span><span class="op">;</span> <span class="co">//не имеет смысла, но будет выполнено!</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    an<span class="op">.</span><span class="va">m_age</span><span class="op">--;</span> <span class="co">//аналогично</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Поэтому одной из парадигм объектно-ориентированного подхода является «защита» данных от таких несанкционированных разработчиком класса действий, то есть ограничение доступа к членам класса посредством привилегий доступа, например:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span> <span class="co">//спецификатор доступа, который делает переменную m_age</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>         <span class="co">//&quot;невидимой&quot; или недоступной вне класса</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> <span class="va">m_age</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    Animal an<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//an.m_age = -100; //ошибка компилятора — нет прав доступа!</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//an.m_age = 10000; //аналогично</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//an.m_age--; //аналогично</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>А так как данные теперь извне класса непосредственно недоступны, то разработчик класса должен предоставить доступные (открытые) программисту-пользователю методы, которые позволят обращаться к переменным класса, но только предусмотренным разработчиком способом. В частности, в таких методах всегда можно ввести контроль, например:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span> <span class="co">//спецификатор доступа, который делает переменную m_age</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>         <span class="co">//«невидимой вне класса»</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_age</span><span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span> <span class="co">//спецификатор доступа, который делает метод SetAge</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//общедоступным</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> SetAge<span class="op">(</span><span class="dt">int</span> age<span class="op">)</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>age <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> age <span class="op">&lt;</span> <span class="dv">30</span><span class="op">)</span> <span class="co">//или if (age &gt;= m_age &amp;&amp; age &lt; 30)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">m_age</span> <span class="op">=</span> age<span class="op">;</span> <span class="co">//переменная класса будет модифицирована</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//только при допустимом значении параметра</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//age</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Такого не может быть!&quot;</span><span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Реализуйте самостоятельно объявленный который должен</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">//переменную m_age параметра delta ниже метод, увеличивать</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">//на значение</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> Grow<span class="op">(</span><span class="dt">int</span> delta<span class="op">);</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    Animal an<span class="op">;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    an<span class="op">.</span>SetAge<span class="op">(-</span><span class="dv">100</span><span class="op">);</span> <span class="co">//&quot;Такого не может быть!&quot;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    an<span class="op">.</span>SetAge<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">//ОК</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Замечание: <strong>в идеальном классе согласно правилам ООП все данные должны быть защищены</strong> (хотя далеко не всегда разработчики классов даже широко известных библиотек этому правилу следуют).</p>
</blockquote>
<h4 id="защита-методов">1.1.3. Защита методов</h4>
<p>Класс может оказаться достаточно сложным с большим количеством методов, из которых только часть предназначены для «внешнего» использования, а остальные являются вспомогательными, то есть, предназначены только для «внутреннего» использования. Первая группа представляет открытый интерфейс пользователя класса (такие методы должны быть общедоступны) — это те методы, без которых программист-пользователь не сможет использовать класс. А методы второй группы лучше делать защищенными, так как:</p>
<ul>
<li><p>их «прямое» использование может привести к нежелательным последствиям так же, как и модификация переменных «напрямую» (поэтому такие методы можно сделать видимыми только для других функций, входящих в состав этого класса и недоступными для любого другого кода);</p></li>
<li><p>знание таких вспомогательных подробностей реализации для исп ользования класса просто не нужно, а, делая их общедоступными, разработчик просто увеличивает объем информации, который необходимо усвоить программисту-пользователю. Поэтому хорошим стилем является сокрытие от него несущественных деталей реализации (пусть лучше сосредоточится на процессе проектирования).</p></li>
</ul>
<blockquote>
<p>Таким образом, класс — это замкнутый мир со своими четко определенными правилами взаимодействия с «внешним» миром. Можно даже сравнить класс с «черным ящиком», который скрывает всю информацию, предоставляя для общения с внешним миром только предусмотренный разработчиком этого класса интерфейс.</p>
</blockquote>
<h3 id="спецификаторы-доступа-c">Спецификаторы доступа C++</h3>
<p>В C++ существуют три уровня привилегий доступа к членам класса. Специфика:</p>
<ul>
<li>Каждый уровень доступа определяется своим ключевым словом (спецификатором доступа) <code>public</code>, <code>private</code> или <code>protected</code>. Назначение спецификаторов доступа:</li>
</ul>
<p><code>public</code> — общедоступный, то есть к нему имеют доступ не только методы класса, но и «внешние» по отношению к классу функции. <em><code>public</code> члены класса образуют открытый интерфейс для «общения» с классом извне.</em></p>
<p><code>private</code> — данный член не доступен вне класса; обращаться к нему могут только методы данного класса.</p>
<p><code>protected</code> — данный элемент не доступен вне класса, пользоваться им могут методы данного класса и методы производных классов (<a href="#тема-ii.-открытое-одиночное-наследование">тема «Наследование»</a>).</p>
<ul>
<li><p>Необязательно для каждого члена класса указывать спецификатор доступа. Пока компилятор не встретит другой спецификатор, он будет использовать предыдущий. Таким образом, внутри класса формируются секции.</p></li>
<li><p>Каждое объявление (переменной или метода) внутри класса определяет привилегию доступа в зависимости от того, в какой секции оно расположено.</p></li>
<li><p>Секций с одним и тем же ключевым словом может быть сколько угодно и располагаться они могут в любом порядке.</p></li>
<li><p>По умолчанию объявления являются <code>private</code>.</p></li>
<li><p>Из метода класса «видны» (компилятор разрешает обращаться к) <code>private</code> и <code>protected</code> члены другого объекта этого же класса (пример приведу позже).</p></li>
</ul>
<p>Например:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Access</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_iX</span><span class="op">;</span> <span class="co">//private no умолчанию</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_iY</span><span class="op">;</span> <span class="co">//public</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_iZ</span><span class="op">;</span> <span class="co">//protected</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="va">m_cZ</span><span class="op">;</span> <span class="co">//protected</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Increase<span class="op">(</span><span class="dt">int</span> dx<span class="op">,</span> <span class="dt">int</span> dy<span class="op">);</span> <span class="co">//public</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> WillBeInherited<span class="op">();</span> <span class="co">//protected</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ForInternalUsage<span class="op">();</span> <span class="co">//private</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Использование спецификаторов доступа для идеального класса можно изобразить графически следующим образом:</p>
<p><img src="media/image10.svg" /></p>
<h2 id="создание-объекта-экземпляра-класса">Создание объекта (экземпляра) класса</h2>
<p>В простейшем случае создание объекта класса выглядит также как и определение переменной базового типа:</p>
<table style="width:94%;">
<colgroup>
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>Определение переменной базового типа</th>
<th>Один из возможных способов создания объекта типа <code>Animal</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><img src="media/image11.svg" /></p>
<p>Компилятор зарезервировал <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span></code> памяти и в зависимости от контекста определения проинициализировал эту область памяти нулями или оставил без инициализации (то есть глобальные и статические переменные будут проинициализированы нулем, а локальные переменные будут содержать случайные значения).</p></td>
<td><p><img src="media/image12.svg" /></p>
<p>Создан объект <code>my</code> типа Animal. Компилятор зарезервировал <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">(</span>Animal<span class="op">)</span></code> памяти и, если разработчик класса предусмотрел специальной функции инициализации, проинициализировал (или не проинициализировал) его согласно общим правилам инициализации переменных.</p></td>
</tr>
</tbody>
</table>
<h2 id="оператор-sizeof-применительно-к-классам">Оператор <code>sizeof</code> применительно к классам</h2>
<p>При создании экземпляра класса компилятор должен зарезервировать необходимый объем памяти. Специфика:</p>
<ul>
<li><p>память резервируется для всех обычных (нестатических — смотри <a href="#тема-vii.-статические-члены-класса">тему «Статические члены класса»</a>) переменных класса</p></li>
<li><p>при появлении виртуальных методов в каждом объекте появляются дополнительные служебные данные (смотри <a href="#полиморфизм.-виртуальные-функции">тему «Полиморфизм»</a>)</p></li>
<li><p>память резервируется только для данных класса, а код методов (не <code>inline</code>) существуют в единственном экземпляре (также как тела обычных глобальных функций)</p></li>
<li><p>компилятор выделяет память для каждого данного в том порядке, в котором переменные объявлены в классе</p></li>
<li><p>оптимизирующий компилятор (например, VC) при выделении памяти под каждую переменную объекта может минимизировать время обращения к любому данному следующим образом: он располагает данные так, чтобы любое из них можно было прочитать из памяти за минимальное количество канальных циклов. Это означает, что любой элемент данных (для того, чтобы при считывании его не нужно было считывать «по кускам») должен быть размещен по адресу, кратному длине элемента. Эти правила следует учитывать для более эффективного использования памяти.</p></li>
</ul>
<p>Например, для оптимизирующего компилятора:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//данные</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//методы</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> SetA<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span> <span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> GetA<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_a</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>A<span class="op">);</span> <span class="co">//4 байта</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//данные</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="va">m_c</span><span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_n</span><span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_d</span><span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">//методы</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>A<span class="op">);</span> <span class="co">//24 байта (см. рис.)</span></span></code></pre></div>
<p><img src="media/image13.svg" /></p>
<p>Замечание 1: зная о правилах, согласно которым оптимизирующий компилятор для выравнивания полей резервирует дополнительные байты, программист мог бы гораздо эффективнее использовать память, всего лишь объявляя переменные класса в другом порядке:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//данные</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_d</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_n</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="va">m_c</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//методы</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>A<span class="op">);</span> <span class="co">//16 байтов (т. к. компилятор может</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//добавить 2 резервных байта)</span></span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>Animal<span class="op">);</span> <span class="co">//???</span></span></code></pre></div>
<p>Замечание 2: в принципе можно разработать класс, в котором нет переменных, а есть только методы. В таком случае из вышесказанного следует, что компилятору вообще памяти выделять не следует, но объект не может занимать 0 байтов, поэтому согласно стандарту при создании объектов такого типа компилятор выделяет 1 байт.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> В</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//данных нет!!!</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//методы есть</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>В<span class="op">);</span> <span class="co">//1</span></span></code></pre></div>
<h2 id="определение-peaлизация-методов-класса">Определение (peaлизация) методов класса</h2>
<p>Как и обычные функции, методы класса могут быть встроенными (встречая в тексте программы вызов такого метода, компилятор подставляет в месте вызова код функции, не тратя ресурсов на вызов) и невстроенными, при вызове которых компилятор передает управление на точку входа (а тело такой функции существует в единственном экземпляре).</p>
<h3 id="встроенные-inline-методы">Встроенные (<code>inline</code>) методы</h3>
<p>Встроенными удобно делать очень короткие и часто вызываемые методы. О том, что Вы хотите сделать метод встроенным, компилятору можно сообщить двумя способами (при этом в любом случае это будет только Вашей рекомендацией компилятору, а компилятор сам решит, имеет ли смысл такой метод встраивать, исходя из соотношения затраты/выигрыш):</p>
<ol type="1">
<li>неявно, совместив объявление и определение метода (при этом ключевое слово <code>inline</code> использовать не обязательно).</li>
</ol>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="va">m_bHasMaster</span><span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> SetMaster<span class="op">()</span> <span class="op">{</span> <span class="va">m_bHasMaster</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//объявление совмещено с реализацией ⇒ компилятор</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//воспринимает такой метод как встроенный</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<ol start="2" type="1">
<li>методы, определенные вне класса также можно сделать встраиваемыми, используя при объявлении и при определении ключевое слово <code>inline</code>.</li>
</ol>
<p>Замечание: при этом определение функции должно быть в <code>h</code>-файле, как и объявление класса, так как компилятор в месте вызова метода должен подставить его тело, а следовательно, должен это тело «видеть»:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Файл Animal.h</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="dt">void</span> SetMaster<span class="op">();</span> <span class="co">//только объявление. Ключевое слово</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//inline обязательно</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Здесь же (или в другом вспомогательном заголовочном файле) тело метода. Специфика: так как имя класса является областью видимости, а реализация метода приводится «вне» класса, компилятору нужно указать, что это не обычная функция, а метод класса Animal посредством имени класса и спецификатора разрешения области видимости — <code>Animal::</code></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> Animal<span class="op">::</span>SetMaster<span class="op">()</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_bHasMaster</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="невстроенные-методы">Невстроенные методы</h3>
<p>Общепринятая практика — помещать определение (реализацию) невстроенного метода в соответствующий файл реализации — <code>.cpp</code>-файл.</p>
<p>Например:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">//файл Animal.h:</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> SetMaster<span class="op">();</span> <span class="co">//только объявление</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Файл Animal.cpp содержит реализацию метода SetMaster:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;Animal.h&quot;</span><span class="pp"> </span><span class="co">//обязательно, так как компилятор должен знать,</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//что Animal — это пользовательский тип, а также</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//видеть свойства пользовательского типа</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Animal<span class="op">::</span>SetMaster<span class="op">()</span> <span class="co">//префикс Animal:: говорит компилятору о</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//принадлежности к классу</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_bHasMaster</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="доступ-к-public-членам-класса-посредством-объекта-или-ссылки.-селектор-.">Доступ к <code>public</code> членам класса посредством объекта (или ссылки). Селектор «<code>.</code>»</h2>
<h3 id="доступ-к-public-переменным">Доступ к <code>public</code> переменным</h3>
<p>Если в классе есть общедоступные данные (чего по правилам быть не должно), обращение к таким переменным осуществляется посредством имени объекта (или ссылки на объект), оператора «<code>.</code>» (селектора) и имени переменной класса. Другая возможность (доступ посредством указателя на объект) будет обсуждаться позже в соответствующем разделе.</p>
<p>Обращение к <code>public</code> переменным класса практически ничем не отличается от обращения к полю Си структуры. Пример:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> А</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    А a<span class="op">;</span> <span class="co">//создание экземпляра класса А с именем а</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span><span class="va">m_a</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">//присвоили переменной m_a объекта а значение 10.</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>                <span class="co">//Что при этом делает компилятор :</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>                <span class="co">//а) формирует адрес = &amp;а(база) +</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>                <span class="co">//смещение_переменной_m_а_относительно_базы(+0)</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>                <span class="co">//б) по вычисленному адресу заносит 10</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    а<span class="op">.</span><span class="va">m_b</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>  <span class="co">//а) формирует адрес = &amp;a +</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>                <span class="co">//смещение_переменной_m_b_относительно базы(+4)</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>                <span class="co">//б) по вычисленному адресу заносит 2</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="вызов-public-метода-класса-нестатического.-указатель-this">Вызов <code>public</code> метода класса (нестатического). Указатель <code>this</code></h3>
<p>Синтаксис вызова метода класса аналогичен обращению к переменной класса. Но в силу того, что метод класса должен производить действия над данными того объекта, для которого он был вызван, вызов метода существенно отличается от вызова обычной (глобальной) функции.</p>
<h4 id="анатомия-вызова-нестатического-метода-класса">1.1.4. Анатомия вызова нестатического метода класса</h4>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Set<span class="op">(</span><span class="dt">int</span> a<span class="op">);</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    A ob<span class="op">;</span> <span class="co">//создание объекта</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    ob<span class="op">.</span>Set<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">//вызов метода можно рассматривать как вызов</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>               <span class="co">//глобальной функции Set(&amp;ob, 5); То есть при вызове</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>               <span class="co">//нестатического метода класса компилятор формирует</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>               <span class="co">//дополнительный(невидимый для программиста)</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>               <span class="co">//параметр, посредством которого передается адрес</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>               <span class="co">//того объекта, для которого вызывается метод</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>А в теле метода при обращении к переменной класса компилятор вычисляет адрес, по которому нужно прочитать или записать значение, следующим образом: адрес объекта (полученный в качестве скрытого параметра) + смещение переменной относительно этой базы:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> A<span class="op">::</span>Set<span class="op">(</span><span class="dt">int</span> а<span class="op">)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    m_а <span class="op">=</span> а<span class="op">;</span> <span class="co">//присвоить значение а по адресу = адрес объекта</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>             <span class="co">//+ смещение m_а_относительно базы</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: по умолчанию</p>
<ul>
<li><p>методы с фиксированным количеством параметров вызываются с соглашением <code>__stdcall</code>, но адрес объекта передается в регистре <code>ECX</code>;</p></li>
<li><p>методы с переменным количеством параметров вызываются с соглашением <code>__cdecl</code>.</p></li>
</ul>
<h4 id="указатель-this">1.1.5. Указатель <code>this</code></h4>
<p>В большинстве случаев компилятор использует полученный в качестве параметра адрес объекта неявно (предыдущий пример), но иногда программисту хочется или необходимо этим адресом воспользоваться явно. Этот адрес доступен программисту посредством имени «<code>this</code>».</p>
<p>Специфика указателя <code>this</code>:</p>
<ul>
<li><p>указатель <code>this</code> формируется компилятором только внутри нестатических методов класса (а также структуры или объединения C++) ⇒ использовать этот указатель вне метода класса невозможно;</p></li>
<li><p>для класса <code>А</code> тип указателя <code>this</code> — <code>A* const</code>. То есть это константный (во всяком случае в поздних версиях C++) указатель, модифицировать который компилятор не позволит;</p></li>
</ul>
<p>Явное использование <code>this</code>:</p>
<ol type="1">
<li>При обращении к членам класса (приведенные три строки эквивалентны)</li>
</ol>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> A<span class="op">::</span>Set<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//здесь компилятор формирует указатель this (как если бы</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//программист определил локальную переменную с именем this: A*</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//const this = адрес_объекта;) и использует это значение в</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//качестве базы при обращении к переменным класса m_a = n;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_a</span> <span class="op">=</span> n<span class="op">;</span> <span class="co">//this используется компилятором неявно, то есть эту</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>             <span class="co">//строчку компилятор интерпретирует как *(this +</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>             <span class="co">//смещение) = n;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span><span class="va">m_a</span> <span class="op">=</span> n<span class="op">;</span> <span class="co">//корректно и эквивалентно предыдущей строчке, но</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//не обязательно — компилятор сделает это и без</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//явного указания</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*</span><span class="kw">this</span><span class="op">).</span><span class="va">m_a</span> <span class="op">=</span> n<span class="op">;</span> <span class="co">//тоже корректно и имеет такой же смысл, так</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//как любой указатель можно разыменовать, а</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//селектором при обращении посредством объекта</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//является «.»</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    A<span class="op">::</span>m_а <span class="op">=</span> n<span class="op">;</span> <span class="co">//можно обозначить принадлежность классу</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">//посредством А::</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li>Использование <code>this</code> в качестве возвращаемого значения. Выражение <code>(*this)</code> часто используется для возвращения копии текущего объекта или ссылки на текущий объект из метода класса.</li>
</ol>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">&amp;</span> A<span class="op">::</span>SomeFunc<span class="op">()</span> <span class="co">//или А А::SomeFunc()</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="3" type="1">
<li>Использование <code>this</code> в качестве аргумента функции. Выражения <code>(*this)</code> или <code>this</code> можно использовать для формирования параметра, передаваемого из метода класса другой функции:</li>
</ol>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> AnotherFunc1<span class="op">(</span>А<span class="op">*);</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> AnotherFunc2<span class="op">(</span>A<span class="op">&amp;);</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> AnotherFunc3<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> A<span class="op">::</span>SomeFunc<span class="op">()</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    AnotherFunc1<span class="op">(</span><span class="kw">this</span><span class="op">);</span> <span class="co">//(A*)</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    AnotherFunc2<span class="op">(*</span><span class="kw">this</span><span class="op">);</span> <span class="co">//(A&amp;)</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    AnotherFunc3<span class="op">(*</span><span class="kw">this</span><span class="op">);</span> <span class="co">//(A)</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="конструкторы">Конструкторы</h2>
<p>При создании экземпляра старой структуры Си единственной возможностью присвоить значения полям при создании структурной переменной было использование списка инициализаторов, например:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Date</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> year<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> month<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> day<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    Date dat1 <span class="op">=</span> <span class="op">{</span> <span class="dv">2006</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">1</span> <span class="op">};</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Обычно же при создании экземпляра класса требуется:</p>
<ul>
<li><p>выделить для него память,</p></li>
<li><p>проинициализировать его переменные (в разных ситуациях, возможно, по-разному),</p></li>
<li><p>а может быть совершить еще какие-нибудь инициализирующие действия.</p></li>
</ul>
<p>Для того чтобы учесть все перечисленные потребности, удобно предоставить в распоряжение программиста методы, специально предназначенные для инициализации переменных класса и предписать компилятору вызывать соответствующий метод при создании экземпляра класса.</p>
<p>У всех классов C++ есть один или несколько таких специальных методов — конструкторов (constructors), автоматически вызываемых при создании экземпляра класса компилятором (автоматически означает, что программист явно такой метод не вызывает, а компилятор «понимает» какой конструктор следует вызвать или сгенерировать по контексту создания объекта).</p>
<p>Конструктор — это не обычный метод класса. Специфика конструктора заключается в следующем:</p>
<ul>
<li><p>конструктор невозможно вызвать явно;</p></li>
<li><p>конструктор вызывается компилятором автоматически при создании нового объекта;</p></li>
<li><p>имя конструктора предопределено, оно всегда совпадает с именем класса (так как компилятор вызывает этот метод неявно, произвольно такой метод называться не может);</p></li>
<li><p>у конструктора отсутствует тип возвращаемого значения (даже если Вы укажите ключевое слово <code>void</code>, компилятор выдаст ошибку)!</p></li>
<li><p>конструктор не может быть объявлен с ключевыми словами <code>const</code> и <code>volatile</code> (<a href="#ключевое-слово-const-и-классы">раздел «Ключевое слово <code>const</code> и классы»</a>);</p></li>
<li><p>не может быть виртуальным (<a href="#полиморфизм.-виртуальные-функции">раздел «Полиморфизм. Виртуальные функции»</a>);</p></li>
<li><p>не может быть статическим;</p></li>
<li><p>соглашение по вызову — <code>__thiscall</code> (не может быть объявлен с ключевым словом <code>cdecl</code>).</p></li>
</ul>
<p>В остальном конструктор подобен обычным функциям, в частности, как и любая функция C++, может иметь любое количество параметров, может быть многократно перегружен программистом и т. д.</p>
<h3 id="конструктор-по-умолчанию-default-constructor">Конструктор по умолчанию (default constructor)</h3>
<p>Конструктором по умолчанию называется конструктор:</p>
<ul>
<li><p>у которого нет параметров</p></li>
<li><p>или все параметры имеют значения по умолчанию.</p></li>
</ul>
<p>Если в классе отсутствует явно определенный пользователем конструктор, то компилятор генерирует собственный автоматический конструктор по умолчанию. Такой автоматический <code>default</code> конструктор для такого простого класса, которым пока является <code>Animal</code>, ничего делать не будет, но для более сложных классов он выполняет два важных действия:</p>
<ul>
<li><p>вызывает конструкторы для встроенных объектов класса (<a href="#тема-vi.-встроенные-объекты-composition.-отношение-между-классами-содержит">раздел «Встроенные объекты»</a>)</p></li>
<li><p>и конструкторы базовых классов (<a href="#тема-ii.-открытое-одиночное-наследование">раздел «Наследование»</a>).</p></li>
</ul>
<p>Замечание: компилятор не всегда может создать автоматический конструктор по умолчанию. Ограничения:</p>
<ul>
<li><p>в классе объявлены константные члены данных;</p></li>
<li><p>в классе объявлены ссылки;</p></li>
<li><p>данный класс является производным, а в базовом классе конструктор объявлен <code>private</code>.</p></li>
</ul>
<p>Например, пока мы не ввели в разрабатываемый класс <code>Animal</code> ни одного своего конструктора:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    Animal an<span class="op">;</span> <span class="co">//выделена намять и вызван автоматический конструктор</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>               <span class="co">//по умолчании, который ничего существенного делать</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>               <span class="co">//не умеет, поэтому данные — члены класса (так как</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>               <span class="co">//объект локальный) остались не проинициализированными</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Так как небезопасно использовать объект, в котором данные имеют случайные значения, логично реализовать свой <code>default</code> конструктор, который будет присваивать переменным класса предусмотренные программистом значения. Например;</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> <span class="va">m_age</span><span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="va">m_bHasMaster</span><span class="op">;</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    SEX <span class="va">m_sex</span><span class="op">;</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">()</span> <span class="co">//объявление и реализация default конструктора</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>             <span class="co">//без параметров</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_age</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_sex</span> <span class="op">=</span> MALE<span class="op">;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_bHasMaster</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    Animal an<span class="op">;</span> <span class="co">//выделена память и вызван введенный нами</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>               <span class="co">//в класс конструктор по умолчанию</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 1: для создания объекта приведенным способом, конструктор должен быть общедоступен (<code>public</code>) для того, чтобы компилятор имел право вызывать этот метод</p>
<p>Замечание 2 (существенное!): обратите внимание на следующий фрагмент кода и запомните разницу:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    Animal a1<span class="op">;</span> <span class="co">//вызов конструктора по умолчанию</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    Animal а<span class="dv">2</span><span class="op">();</span> <span class="co">//а эту строчку компилятор трактует как объявление</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//функции, которая не принимает параметров и</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//возвращает значение типа Animal!</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="конструктор-с-параметрами">Конструктор с параметрами</h3>
<p>Так как основным предназначением конструктора является инициализация переменных класса, то в основном используются конструкторы с параметрами. Вот новое объявление класса Animal с явным (<code>inline</code>) конструктором:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> <span class="va">m_age</span><span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="va">m_bHasMaster</span><span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    SEX <span class="va">m_sex</span><span class="op">;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">(</span><span class="dt">int</span> age<span class="op">,</span> <span class="dt">bool</span> master<span class="op">,</span> SEX s<span class="op">)</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="co">//объявление и реализация конструктора с параметрами</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_age</span> <span class="op">=</span> age<span class="op">;</span> <span class="va">m_sex</span> <span class="op">=</span> s<span class="op">;</span> <span class="va">m_bHasMaster</span> <span class="op">=</span> master<span class="op">;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Соответственно изменится и код создания объекта типа <code>Animal</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>Animal an<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> FEMALE<span class="op">);</span> <span class="co">//компилятор создаст экземпляр класса</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//Animal и вызовет конструктор с</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//параметрами</span></span></code></pre></div>
<p>Замечание 1: поскольку мы ввели явный конструктор с параметрами и явно не переопределили свой конструктор без параметров, компилятор уже не будет генерировать автоматически конструктор по умолчанию и в ответ на попытку сконструировать объект <code>Animal</code> по умолчанию выдаст ошибку:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>Animal an2<span class="op">;</span> <span class="co">//ошибка — в классе не определен конструктор без</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>            <span class="co">//параметров</span></span></code></pre></div>
<p>Замечание 2: конструктор с параметрами, у которого все параметры имеют значения по умолчанию (<a href="#конструктор-по-умолчанию-default-constructor">раздел «Конструктор по умолчанию»</a>), эквивалентен конструктору по умолчанию.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">(</span><span class="dt">int</span> age <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">bool</span> master <span class="op">=</span> <span class="kw">false</span><span class="op">,</span> SEX s <span class="op">=</span> MALE<span class="op">);</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//эквивалентен конструктору пo умолчанию</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    Animal a1<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> FEMALE<span class="op">);</span><span class="co">//компилятор передаст в качестве</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//параметров указанные значения</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    Animal а<span class="dv">2</span><span class="op">;</span> <span class="co">//компилятор вызовет тот же метод, но передаст</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>               <span class="co">//значения по умолчанию, указанные в прототипе метода</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 3: можно создать константный объект, предназначенный только для чтения (для таких объектов впоследствии можно будет вызывать только константные методы класса — <a href="#ключевое-слово-const-и-классы">раздел «Ключевое слово <code>const</code> и классы»</a>):</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Animal my<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> MALE<span class="op">);</span></span></code></pre></div>
<h3 id="специфика-записи-при-вызове-конструктора-с-одним-параметром">Специфика записи при вызове конструктора с одним параметром</h3>
<p>Иногда Вы можете встретить несколько странную запись, которая означает неявный вызов конструктора с одним параметром:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    A a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">//компилятор вызовет конструктор с одним параметром.</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>             <span class="co">//Для компилятора такая запись означает то же самое,</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>             <span class="co">//что</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    A а<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Такую запись можно интерпретировать следующим образом: компилятор приводит значение, стоящее справа от знака равенства, к требуемому типу слева от знака равенства посредством конструктора с одним параметром (аналогично неявному приведению базовых типов: <code>float f = 1;</code> эквивалентно <code>float а(1);</code>).</p>
<h3 id="конструкторы-и-модификатор-explicit">Конструкторы и модификатор <code>explicit</code></h3>
<p>Для того чтобы запретить неявное преобразование применяется модификатор <code>explicit</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m_а<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="co">//конструктор объявлен с модификатором</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>                 <span class="co">//explicit.Этот модификатор запрещает</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>        m_а <span class="op">=</span> a<span class="op">;</span>      <span class="co">//компилятору приводить тип неявно.</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    A а <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">//неявное преобразование запрещено ⇒ ошибка</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>             <span class="co">//компилятора : cannot convert from &#39;const int&#39; to</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>             <span class="co">//&#39;class A&#39;</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="конструкторы-базовых-типов">Конструкторы базовых типов</h3>
<p>Если класс хорошо спроектирован, использование объектов такого пользовательского типа не должно отличаться от использования переменных базового типа. Полезно было бы иметь и «обратную совместимость», то есть в тех ситуациях, где можно использовать объекты классов, хотелось бы иметь возможность также использовать и переменные базовых типов (например, обобщенные алгоритмы стандартной библиотеки умеют работать с данными любого типа — раздел «Обобщенные алгоритмы STL»<!-- такого раздела нет! -->). Для поддержки такой «обратной совместимости», для базовых типов введено понятие конструктора:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">//это привычная запись для инициализации переменной</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>           <span class="co">//базового типа</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">(</span><span class="dv">1</span><span class="op">);</span> <span class="co">//а это эквивалент предыдущей строки, только в терминах</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>          <span class="co">//конструирования объектов: компилятор должен выделить</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>          <span class="co">//память для переменной типа int и проинициализировать</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>          <span class="co">//указанным в качестве параметра значением</span></span></code></pre></div>
<p>Замечание 1: для базовых типов предусмотрен вызов конструктора по умолчанию (при этом компилятор инициализирует переменную базового типа нулем). Синтаксически вызов конструктора по умолчанию для базовых типов выглядит:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dt">int</span><span class="op">();</span> <span class="co">//по умолчанию инициализируются нулем</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j<span class="op">;</span> <span class="co">//а здесь никакого конструктора неявно не вызывается,</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>           <span class="co">//поэтому локальная переменная базового типа остается</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>           <span class="co">//неинициализированной</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 2: посредством вызова конструктора можно проинициализировать заданным в качестве параметра значением переменную базового типа, создаваемую динамически:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> р <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">//это указание компилятору выделить память</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//sizeof(int) в куче и занести по этому адресу</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//значение 5 (а не динамическое создание</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//массива из 5 элементов типа int)</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> p1 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span><span class="dv">5</span><span class="op">];</span> <span class="co">//в отличие от предыдущего примера, эта запись</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//предписывает компилятору выделить в куче</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//память под массив из пяти элементов типа</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//int. При этом неявно инициализировать</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//выделенный блок памяти компилятор не будет.</span></span></code></pre></div>
<h3 id="перегрузка-конструкторов">Перегрузка конструкторов</h3>
<p>Объекты одного и того же класса можно инициализировать разными способами. Для этих целей удобно иметь несколько разных инициализирующих функций. В C++ могут перегружаться любые функции, в том числе и конструкторы. Вы можете реализовать любое количество конструкторов, различающихся количеством и/или типами аргументов. Главное, чтобы компилятор при создании объекта мог «разобраться» вызов какого именно метода ему нужно сгенерировать при создании объекта. Например:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">();</span> <span class="co">//конструктор по умолчанию</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">(</span><span class="dt">int</span> age<span class="op">,</span> <span class="dt">bool</span> master<span class="op">,</span> SEX s<span class="op">);</span> <span class="co">//конструктор с параметрами</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Теперь экземпляры класса <code>Animal</code> можно создать следующими способами:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>Animal an1<span class="op">;</span> <span class="co">//компилятор вызовет конструктор по умолчанию</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>Animal аn2<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> MALE<span class="op">);</span> <span class="co">//компилятор вызовет конструктор с</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//параметрами</span></span></code></pre></div>
<h3 id="конструктор-с-параметрами-по-умолчанию">Конструктор с параметрами по умолчанию</h3>
<p>Как и все функции, конструктор может иметь аргументы, формируемые компилятором по умолчанию.</p>
<p>Например:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> age <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">bool</span> master <span class="op">=</span> <span class="kw">false</span><span class="op">,</span> SEX s <span class="op">=</span> MALE<span class="op">);</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Экземпляр класса Animal можно создать:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>Animal an1<span class="op">;</span> <span class="co">//значения всех трех параметров будет сформировано</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>            <span class="co">//компилятором по умолчанию</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>Animal аn2<span class="op">(</span><span class="dv">2</span><span class="op">);</span> <span class="co">//значение первого параметра задано явно, остальные</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>               <span class="co">//по умолчанию</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>Animal аn3<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>Animal an4<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> MALE<span class="op">);</span></span></code></pre></div>
<blockquote>
<p>Замечание: как и для обычных функций значения по умолчанию должны быть указаны только в прототипе метода. Если Вы продублируете эти значения при определении метода, компилятор выдаст ошибку.</p>
</blockquote>
<h3 id="возможные-конфликты-при-использовании-параметров-по-умолчанию">Возможные конфликты при использовании параметров по умолчанию</h3>
<p>При наличии нескольких конструкторов и использовании конструктора, имеющего аргументы по умолчанию, может возникнуть следующая ситуация:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">();</span> <span class="co">//конструктор без параметров</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> age <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">bool</span> master <span class="op">=</span> <span class="kw">false</span><span class="op">,</span> SEX s <span class="op">=</span> MALE<span class="op">);</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//конструктор, у которого все параметры имеют значения по</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//умолчанию</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Пока неоднозначности не возникло, но компилятор уже выдает предупреждение (warning)</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    Animal an<span class="op">;</span> <span class="co">//а здесь ошибка компилятора, так как нет</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>               <span class="co">//однозначности — какой именно конструктор должен</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>               <span class="co">//быть вызван</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="динамическое-создание-объектов">Динамическое создание объектов</h3>
<p>При динамическом создании объектов оператор new не только выделяет память в куче, но и вызывает для создаваемого таким образом объекта конструктор. Возвращает оператор new типизированный указатель.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">*</span> р <span class="op">=</span> <span class="kw">new</span> Animal<span class="op">;</span> <span class="co">//конструктор по умолчанию</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">*</span> р <span class="op">=</span> <span class="kw">new</span> Animal<span class="op">();</span> <span class="co">//тоже конструктор по умолчанию</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">*</span> р <span class="op">=</span> <span class="kw">new</span> Animal<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="kw">false</span><span class="op">,</span> MALE<span class="op">);</span> <span class="co">//конструктор с параметрами</span></span></code></pre></div>
<p>Попользовавшись таким динамическим объектом, не забудьте освободить память!</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> р<span class="op">;</span> <span class="co">//вызов деструктора и освобождение памяти</span></span></code></pre></div>
<h2 id="деструкторы">Деструкторы</h2>
<h3 id="деструктор-метод-класса.-конструктор-деструктор-функциональное-замыкание">Деструктор — метод класса. Конструктор + деструктор = функциональное замыкание</h3>
<p>Деструктор — еще один специфический метод класса. Деструктор выполняет операции, обратные тем, которые выполняют конструкторы: например, если конструктор выделяет динамическую память, то деструктор, вероятнее всего, ее освобождает и т. д. (это называется функциональным замыканием).</p>
<p>Специфика деструктора:</p>
<ul>
<li><p>в большинстве случаев вызывается компилятором неявно, когда заканчивается время жизни объекта (хотя в отличие от конструктора деструктор можно вызывать и явно);</p></li>
<li><p>имя деструктора совпадает с именем класса, но предваряется тильдой «<code>~имя_класса</code>»;</p></li>
<li><p>не принимает параметров и ничего не возвращает (даже <code>void</code>);</p></li>
<li><p>деструктор может быть только один (в отличие от конструкторов, которых может быть сколько угодно);</p></li>
<li><p>может (а иногда и должен) быть виртуальным;</p></li>
<li><p>вызывается компилятором с соглашением по вызову — <code>__stdcall</code> (<code>thiscall</code>)</p></li>
</ul>
<p>Если явно в классе деструктор программистом не определен, то компилятор генерирует его сам. Такой автоматический деструктор для простых классов как наш класс <code>Animal</code> практически ничего не делает, но он умеет выполнять очень важные действия для чуть более сложных классов:</p>
<ul>
<li><p>вызывает деструкторы встроенных объектов данного класса (<a href="#тема-vi.-встроенные-объекты-composition.-отношение-между-классами-содержит">раздел «Встроенные объекты»</a>),</p></li>
<li><p>вызывает деструкторы базовых классов (<a href="#тема-ii.-открытое-одиночное-наследование">раздел «Наследование»</a>).</p></li>
</ul>
<p>Замечание 1: при этом следует отдавать себе отчет в том, что некоторые действия за программиста он автоматически сгенерировать не может (например, освободить выделенную динамически память).</p>
<p>Замечание 2: если класс простой и при уничтожении объекта никаких специфических действий выполнять не нужно, то совершенно излишне явно реализовывать в таком классе деструктор.</p>
<p>Усложним наш класс <code>Animal</code> таким образом, чтобы возникла необходимость ввести деструктор. Дадим имя животному. Имя — это строка (массив символов), но хранить в объекте эту строчку можно по-разному:</p>
<ol type="1">
<li><p>неэффективный вариант — объявить в классе встроенный массив, например <code>char m_name[20]</code>. Неэффективность такого подхода заключается в том, что размерность массива должна быть задана константой и компилятор в любом объекте будет резервировать 20 байтов, поэтому если имя короткое, мы заставим компилятор выделить память под неиспользуемый резерв, а если имя «длиннее», чем размер массива, нам придется его «программно обрезать»;</p></li>
<li><p>более эффективный вариант — объявить в классе указатель на строку, например <code>char* m_pName</code>. При этом строки могут быть разной длины, а в объекте будет храниться только адрес строки.</p></li>
</ol>
<p>Рассмотрим второй вариант и способы его реализации:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> <span class="va">m_pName</span><span class="op">;</span> <span class="co">//указатель на строку с именем животного</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> age<span class="op">,</span> <span class="dt">bool</span> master<span class="op">,</span> SEX s<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> pName<span class="op">);</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//так как в классе появилась новая переменная, модифицируем</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//конструктор — он должен формировать в объекте указатель на</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//требуемую строку</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>При реализации конструктора мы должны учесть, что четвертый параметр конструктора может быть разной природы ⇒ если в реализации конструктора мы поступим с указателем так же, как поступали с другими переменными.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Плохой способ реализации конструктора:</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">::</span>Animal<span class="op">(</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> age<span class="op">,</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> master<span class="op">,</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    SEX s<span class="op">,</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> pName<span class="op">)</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_age</span> <span class="op">=</span> age<span class="op">;</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_pName</span> <span class="op">=</span> pName<span class="op">;</span> <span class="co">//запоминаем в переменной класса адрес, но не</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//знаем, каким образом была выделена память в</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//вызывающей функции</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>то это может привести к большой проблеме в нижеприведенном фрагменте</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Создание объектов. Обратите внимание — строка с именем может</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//быть задана разными способами:</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    Animal an1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> MALE<span class="op">,</span> <span class="st">&quot;Bobik&quot;</span><span class="op">);</span> <span class="co">//в качестве параметра</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">//используется строковый</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">//литерал</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> ar<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Sharik&quot;</span><span class="op">;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    Animal аn2<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="kw">false</span><span class="op">,</span> MALE<span class="op">,</span> ar<span class="op">);</span> <span class="co">//в качестве параметра</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">//используется локальный массив</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> р <span class="kw">new</span> <span class="dt">char</span><span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> p<span class="op">;</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    Animal an3<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> FEMALE<span class="op">,</span> p<span class="op">);</span> <span class="co">//в качестве параметра</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">//используется указатель на</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">//динамический массив</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span><span class="op">[]</span> р<span class="op">;</span> <span class="co">//а теперь освобождаем динамически захваченную</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>                <span class="co">//память (при этом в объекте an3 остается</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>                <span class="co">//недействительный указатель)</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> <span class="co">//продолжаем пользоваться объектом an3!!!</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Хороший способ реализации конструктора (мы должны обеспечить существование всех данных объекта, пока существует сам объект, поэтому формируем динамическую копию строки-параметра!):</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">::</span>Animal<span class="op">(...,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> pName<span class="op">)</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Динамически выделить достаточное для хранения строки</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//количество памяти.</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_pName</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">char</span><span class="op">[</span>strlen<span class="op">(</span>pName<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span> <span class="co">//+1, так как функция</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">//strlen «не считает»</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">//завершающий нулевой байт</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Скопировать строку-аргумент в динамически выделенную память</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    strcpy<span class="op">(</span><span class="va">m_pName</span><span class="op">,</span> pName<span class="op">);</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Теперь класс Animal стал «нетривиальным», так как в конструкторе происходит динамическое выделение памяти. Созданный динамически массив будет существовать, пока программист явно не вызовет оператор <code>delete[] m_pName</code>. Очевидно, что это стоит сделать тогда, когда объект прекращает свое существование. Как раз тогда компилятор неявно вызовет деструктор (который для такого класса программист должен явно реализовать).</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Animal<span class="op">()</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="co">//объявление деструктора, совмещенное с определением</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_pName</span><span class="op">;</span> <span class="co">//освобождение памяти, занятой в</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>                          <span class="co">//конструкторе</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Замечание: модифицируйте самостоятельно конструктор по умолчанию (он тоже должен предусматривать инициализацию указателя m_pName!). Подумайте: почему вариант а) плохой и чем грозит Вам вариант б) ?</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">::</span>Animal<span class="op">()</span><span class="co">//а)</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_pName</span> <span class="op">=</span> <span class="st">&quot;Default&quot;</span><span class="op">;</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">::</span>Animal<span class="op">()</span><span class="co">//б)</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_pName</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="когда-вызываются-конструкторы-и-деструкторы">Когда вызываются конструкторы и деструкторы</h2>
<p>Конструкторы вызываются компилятором при создании объекта, а деструкторы при уничтожении. Но если вызов конструктора достаточно очевиден, вызов деструктора определяется временем существования объекта:</p>
<ol type="1">
<li>именованный автоматический объект — конструируется каждый раз, когда компилятор встречает его объявление и уничтожается при выходе из блока, в котором он объявлен (в частности таким блоком является тело функции)</li>
</ol>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    Animal аn<span class="op">;</span> <span class="co">//конструктор (в данном случае по умолчанию)</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//деструктор</span></span></code></pre></div>
<ol start="2" type="1">
<li><p>встроенные массивы объектов — аналогично</p></li>
<li><p>динамический объект существует пока программист не уничтожит его явно:</p></li>
</ol>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">*</span> р <span class="op">=</span> <span class="kw">new</span> Animal<span class="op">(...);</span> <span class="co">//конструктор</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> р<span class="op">;</span> <span class="co">//деструктор</span></span></code></pre></div>
<ol start="4" type="1">
<li><p>глобальный, в пространстве имен — конструктор вызывается в прологе функции <code>main()</code>, деструктор — при завершении программы.</p></li>
<li><p>статический локальный — конструктор вызывается при первом выполнении данного кода, а деструктор — при завершении программы.</p></li>
<li><p>временный (автоматический) неименованный объект, который создается как часть вычисления выражения и уничтожается по завершении вычисления всего выражения.</p>
<p>а) <code>...А(1) + А(2)...</code></p>
<p>б) <code>func(А(1))</code></p></li>
<li><p>передача параметров по значению (<a href="#передача-объекта-в-качестве-параметра-по-значению">раздел «Передача объектов по значению»</a>)</p></li>
<li><p>возвращение объекта по значению (<a href="#возвращение-объекта-по-значению">раздел «Возвращение объектов по значению»</a>).</p></li>
</ol>
<h2 id="конструктор-копирования">Конструктор копирования</h2>
<p>Конструктор копирования — особый вид конструктора. Как и конструктор по умолчанию, конструктор копий (copy constructor) — это метод класса, который может сгенерировать компилятор автоматически.</p>
<p>Автоматический конструктор копирования подходит только для простых классов и умеет делать следующие действия:</p>
<ul>
<li><p>почленно копировать простые данные класса (переменные базовых типов, указатели, массивы с элементами базового типа);</p></li>
<li><p>вызывать конструктор копирования базового класса;</p></li>
<li><p>вызывать конструкторы копирования для встроенных объектов.</p></li>
</ul>
<blockquote>
<p>Следствие: для простых классов совершенно незачем явно вводить в класс конструктор копирования.</p>
</blockquote>
<p>Замечание: компилятор не всегда может создать автоматический конструктор копирования. Ограничения:</p>
<ul>
<li><p>в классе объявлены константные члены данных</p></li>
<li><p>в классе объявлены ссылки</p></li>
<li><p>данный класс является производным, а в базовом классе конструктор объявлен private.</p></li>
</ul>
<h3 id="создание-копий-объектов">Создание копий объектов</h3>
<p>Основное назначение конструктора копий — создавать новый экземпляр (того же класса) таким образом, чтобы он стал копией существующего объекта. Если класс простой, например:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> А</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> name<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//конструктор копирования явно программистом в классе не</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//предусмотрен</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>то нас устроит автоматический конструктор копирования, генерируемый компилятором, который просто перепишет из существующего объекта данные в новый создаваемый объект:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    A al<span class="op">;</span> <span class="co">//создание объекта посредством default-конструктора</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    А а<span class="dv">2</span> <span class="op">=</span> а<span class="dv">1</span><span class="op">;</span> <span class="co">//создание объекта посредством автоматического</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>               <span class="co">//конструктора копирования (нормальная форма записи)</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    А аЗ<span class="op">(</span>а<span class="dv">1</span><span class="op">);</span> <span class="co">//то же самое (функциональная форма записи)</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>но, если для нашего нетривиального класса Animal не реализован корректный конструктор копирования, то при использовании автоматического конструктора копирования вместо двух отдельных одинаковых животных, появляются «сиамские близнецы»:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    Animal al<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> MALE<span class="op">,</span> <span class="st">&quot;Bobik&quot;</span><span class="op">);</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    Animal a2 <span class="op">=</span> a1<span class="op">;</span> <span class="co">//создаем клон объекта al. Здесь компилятор</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//вызовет автоматический конструктор</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//копирования.Это нормальная форма записи.</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    Animal a3<span class="op">(</span>al<span class="op">);</span> <span class="co">//то же самое. Это функциональная форма вызова</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//конструктора копирования.</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">//а здесь компилятор вызовет деструкторы для локальных объектов</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">//a1, а2, а3!!!Вызов первого деструктора освободит динамически</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">//захваченную память, а вызов следующего попытается освободить уже</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">//«недействительный» блок.При этом, скорее всего Вы получите</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">//ошибку времени выполнения!!!</span></span></code></pre></div>
<p>Почему возникнет ошибка времени выполнения? Автоматический конструктор копирования умеет только копировать простые данные из одного объекта в другой. Это устраивает нас для значений переменных <code>m_age</code>, <code>m_bHasMaster</code>, <code>m_sex</code>. Но для указателя <code>m_pName</code> это является катастрофой, так как компилятор переписывает адрес одного и того же динамически выделенного блока памяти в другой объект (это еще не катастрофа). А потом по закрывающей фигурной скобке компилятор вызывает деструкторы для локальных объектов. Вызов деструктора для первого объекта освобождает память, при этом данный блок становится недействительным. А во втором объекте указатель продолжает содержать адрес уже недействительно блока памяти. При попытке вторично освободить этот блок возникает ошибка времени выполнения! А вот это уже катастрофа!</p>
<p>«Сиамские близнецы»</p>
<p><img src="media/image14.svg" /></p>
<p>Поэтому автоматический конструктор копирования в данном случае не годится, а следовательно, для такого класса программист должен явно реализовать корректный конструктор копирования:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Animal.h</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">(</span><span class="at">const</span> Animal<span class="op">&amp;</span> other<span class="op">);</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Замечание 1: модификатор <code>const</code> не обязателен, но его использование является хорошим стилем, так как предписывает компилятору не спускать модификации параметра</p>
<p>Замечание 2: существенным является передача именно ссылки в качестве источника копирования для того, чтобы избежать бесконечной рекурсии (смотри <a href="#передача-объекта-в-качестве-параметра-по-значению">раздел «Передача объекта в качестве параметра»</a>). К счастью, компилятор отслеживает тип аргумента конструктора копирования, и если Вы попробуете задать в качестве типа параметра не ссылку, а значение, выдаст ошибку.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Animal.срр</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">::</span>Animal<span class="op">(</span><span class="at">const</span> Animal<span class="op">&amp;</span> other<span class="op">)</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Простые данные теперь никто за нас копировать не будет,</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//поэтому копируем сами:</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_age</span> <span class="op">=</span> other<span class="op">.</span><span class="va">m_age</span><span class="op">;</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_sex</span> <span class="op">=</span> other<span class="op">.</span><span class="va">m_sex</span><span class="op">;</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_bHasMaster</span> <span class="op">=</span> other<span class="op">.</span><span class="va">m_bHasMaster</span><span class="op">;</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//А для имени создаем свою динамическую копию:</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_pName</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">char</span><span class="op">[</span>strlen<span class="op">(</span>other<span class="op">.</span><span class="va">m_pName</span><span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>              <span class="co">//выделяем память для копии строки. Длину строки</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>              <span class="co">//узнаем, извлекая нужный указатель из параметра</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    strcpy<span class="op">(</span><span class="va">m_pName</span><span class="op">,</span> other<span class="op">.</span><span class="va">m_pName</span><span class="op">);</span><span class="co">//копируем</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 1: автоматический конструктор копирования подходит только для простых классов. Для более сложных классов, требующих динамического выделения памяти или иной специализированной инициализации, автоматический конструктор копирования не годится.</p>
<p>Замечание 2: инициализация и присваивание являются различными операциями! Копирование для уже существующих объектов осуществляется не с помощью копирующего конструктора, а посредством оператора присваивания (<a href="#тема-iv.-перегрузка-операторов">раздел «Перегрузка операторов»</a>):</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    Animal an1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> MALE<span class="op">,</span> <span class="kw">true</span><span class="op">),</span> an3<span class="op">;</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    Animal an2 <span class="op">=</span> an1<span class="op">;</span> <span class="co">//создается новый объект an2 посредством</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//конструктора копирования</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Когда конструктор копирования не вызывается!</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    an3 <span class="op">=</span> an1<span class="op">;</span> <span class="co">//Оба объекта уже существуют. Объект an3 принимает</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>               <span class="co">//значение объекта an1 посредством оператора «=»(это</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>               <span class="co">//совершенно другой метод класса)</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="передача-объекта-в-качестве-параметра-по-значению">Передача объекта в качестве параметра по значению</h3>
<p>Менее очевиден вызов конструктора копирования при передаче по значению в качестве параметра функции. Например:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> FVal<span class="op">(</span>A a<span class="op">);</span> <span class="co">//прототип функции, которая принимает параметр</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>                <span class="co">//типа А по значению</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    A x<span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    FVal<span class="op">(</span>x<span class="op">);</span> <span class="co">//*вызывается конструктор копирования*, чтобы создать в</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>             <span class="co">//стеке копию объекта x для передачи параметра по</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>             <span class="co">//значению</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> FVal<span class="op">(</span>A а<span class="op">)</span> <span class="co">//реализация функции</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//работа с копией</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//вызывается деструктор для копии (то есть для параметра а)</span></span></code></pre></div>
<p>Замечание 1: не рекомендуется принимать «большие» объекты по значению — эффективнее передавать адрес объекта (ссылку или указатель на объект). Если при этом требуется запретить модификацию самого объекта — передавайте константную ссылку или указатель на константный объект!!!</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> FRef<span class="op">(</span>A<span class="op">&amp;</span> а<span class="op">);</span> <span class="co">//прототип функции, которая принимает ссылку на А.</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//При вызове компилятор положит в стек адрес</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//объекта!!!</span></span></code></pre></div>
<p>Замечание 2: при формировании параметра Вы можете создавать анонимный неименованный объект в обоих случаях — при передаче по ссылке и по значению:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>FVal<span class="op">(</span>А<span class="op">(&lt;</span>параметры<span class="op">&gt;));</span><span class="co">//компилятор понимает, что создается временный</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//объект, поэтому: 1) сразу выделяет память в</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//стеке для передаваемого параметра и вызывает</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//конструктор</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//2) по завершающей скобке функции FVal</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//вызывает деструктор для параметра</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>FRef<span class="op">(</span>А<span class="op">(&lt;</span>параметры<span class="op">&gt;));</span><span class="co">//компилятор:</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//1) вызывает конструктор для инициализации</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//автоматического неименованного объекта</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//2) в качестве параметра передает в функцию</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//адрес автоматического неименованного объекта</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//3) после вычисления выражения (то есть после</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//вызова функции и приема возвращаемого</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//значения) деструктор для автоматического</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//объекта</span></span></code></pre></div>
<h3 id="возвращение-объекта-по-значению">Возвращение объекта по значению</h3>
<p>Возвращение объекта по значению происходит тоже с помощью конструктора копирования:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    А а<span class="op">;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    а <span class="op">=</span> Get<span class="op">();</span> <span class="co">//1) компилятор резервирует в стеке память для</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>               <span class="co">//возвращаемого значения и генерирует вызов функции</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>               <span class="co">//Get с невидимым дополнительным параметром —</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>               <span class="co">//Get(адрес_для_возвращаемого_значения)</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>               <span class="co">//2)operator= для приема возвращаемого значения,</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>               <span class="co">//3) деструктор для возвращаемого значения</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    Get<span class="op">();</span> <span class="co">//возвращаемое значение формируется, но ничему не</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>           <span class="co">//присваивается! -&gt; деструктор для возвращаемого значения</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    A al <span class="op">=</span> Get<span class="op">();</span> <span class="co">//а в этом случае хороший компилятор будет</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//оптимизировать вызов:</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//1) так как слева создается новый объект,</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//компилятор формирует вызов Get(&amp;al)</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//2) operator= не вызывается, так как возвращаемое</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//значение уже сформировано по нужному адресу</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//3) деструктор для возвращаемого значения не</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//вызывается</span></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>В функции:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>A Get<span class="op">()</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    A tmp<span class="op">;</span> <span class="co">//этот объект создается в стековом кадре данной функции.</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>           <span class="co">//*После возврата управления из функции компилятор может</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>           <span class="co">//использовать эту область стека для других целей!*</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tmp<span class="op">;</span> <span class="co">//компилятор, формируя возвращаемое значение, с</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>                <span class="co">//помощью конструктора копий копирует объект из</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>                <span class="co">//стекового кадра данной функции в ту область стека,</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>                <span class="co">//которую «зарезервировала» вызывающая функция</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">//уничтожаются локальные объекты (вызывается деструктор для tmp)</span></span></code></pre></div>
<p>Замечание: нельзя возвращать адрес локального объекта (ссылку или указатель) так же, как это было с базовыми типами. В случае объектов ситуация усугубляется тем. что по закрывающей фигурной скобке вызываются деструкторы локальных объектов.</p>
<h3 id="стандарт-с11-move-конструктор-копирования">Стандарт С++11 — move конструктор копирования</h3>
<p>Без использования семантики перемещения:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> m_р<span class="op">;</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> <span class="va">m_n</span><span class="op">;</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="at">const</span> A<span class="op">&amp;);</span><span class="co">//обычный (классический) конструктор копирования</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><em>Реализация классического конструктора копирования???</em></p>
<p><em>Накладные расходы при создании полноценной (глубокой) копии???</em></p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>A f<span class="op">()</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    A tmp<span class="op">;</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tmp<span class="op">;</span> <span class="co">//для формирования возвращаемого значения компилятор</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>                <span class="co">//вызывает классический конструктор копирования со</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>                <span class="co">//всеми «накладными расходами» для создания</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>                <span class="co">//полноценной копии (глубокое копирование)</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Согласно стандарту С++11 для временных объектов можно использовать такое понятие как rvalue reference (ссылка на ссылку)</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> m_р<span class="op">;</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> <span class="va">m_n</span><span class="op">;</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="at">const</span> A<span class="op">&amp;);</span><span class="co">//обычный (классический) конструктор копирования</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span>A<span class="op">&amp;&amp;);</span><span class="co">//move конструктор копирования</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>A f<span class="op">()</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    A tmp<span class="op">;</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tmp<span class="op">;</span> <span class="co">//move конструктор копирования — компилятор сам</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>                <span class="co">//«догадается», что объект временный</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">//или программист ему «подскажет»:</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">//return std::move(tmp); //move конструктор копирования</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Реализация move конструктора копирования:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">::</span>A<span class="op">(</span>A<span class="op">&amp;&amp;</span> tmp<span class="op">)</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_n</span> <span class="op">=</span> tmp<span class="op">.</span><span class="va">m_n</span><span class="op">;</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_p</span> <span class="op">=</span> tmp<span class="op">.</span><span class="va">m_p</span><span class="op">;</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    tmp<span class="op">.</span><span class="va">m_p</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="ключевое-слово-const-и-классы">Ключевое слово <code>const</code> и классы</h2>
<p>Применительно к классам ключевое слово <code>const</code> может быть использовано:</p>
<p><img src="media/image15.svg" /></p>
<h3 id="const-и-возвращаемое-значение"><code>const</code> и возвращаемое значение</h3>
<p>Правила одинаковы как для возвращения константных базовых типов, так и пользовательских. Если ключевое слово <code>const</code> относится к возвращаемому значению, то компилятор гарантирует, что возвращаемое значение может быть использовано только для чтения.</p>
<p>Например:</p>
<p>а) без ключевого слова <code>const</code>:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> GetA<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_a</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> a<span class="op">.</span>GetA<span class="op">();</span> <span class="co">//ОК — прочитали значение защищенной</span></span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//переменной класса</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>GetA<span class="op">()</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">//не очень корректно, так как позволили</span></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//посредством возвращаемого методом GetA() адреса</span></span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//защищенной переменной произвольным образом</span></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//изменять ее значение</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>б) с помощью ключевого слова const запрещаем модифицировать значение переменной класса посредством возвращаемого адреса:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> GetA<span class="op">()</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//a.GetA()=2; //ошибка компилятора</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> a<span class="op">.</span>GetA<span class="op">();</span> <span class="co">//возвращаемое значение теперь можно</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//использовать только для чтения</span></span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="константные-методы-класса.-константные-объекты">Константные методы класса. Константные объекты</h3>
<p>Если метод предназначен только для «чтения» (то есть не должен модифицировать данные объекта), рекомендуется объявить его как константный метод. В константном методе компилятор не позволит модифицировать любые переменные класса или вызывать любые другие не константные методы класса.</p>
<p>Например:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> А</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Increase<span class="op">()</span> <span class="op">{</span> <span class="va">m_a</span><span class="op">++;</span> <span class="op">}</span> <span class="co">//вспомогательный метод, </span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//модифицирующий переменную класса</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> get<span class="op">()</span> <span class="at">const</span>    <span class="co">//«read-only» метод класса</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//m_а++;       //ошибка компилятора — попытка модифицировать</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//переменную класса</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Increase(); //ошибка компилятора — попытка вызвать не</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//константный метод класса</span></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span> <span class="op">}</span> <span class="co">//метод, изменяющий данные</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//объекта. Не может быть</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//константным!</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Замечание 1: если объявление и реализация метода разнесены, ключевое слово <code>const</code> требуется как при объявлении, так и при определении метода:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co">//A.h</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> get<span class="op">()</span> <span class="at">const</span><span class="op">;</span> <span class="co">//объявление</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="co">//А.срр</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> A<span class="op">::</span>get<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_a</span><span class="op">;</span> <span class="op">}</span> <span class="co">//определение</span></span></code></pre></div>
<p>Замечание 2: методы, отличающиеся только ключевым словом <code>const</code>, могут быть <strong>перегружены</strong>. Какой метод вызывать компилятор определяет исходя из константности объекта, посредством которого вызывается метод. Например:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fA<span class="op">();</span> <span class="co">//не константный метод</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fA<span class="op">()</span> <span class="at">const</span><span class="op">;</span> <span class="co">//константный метод</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>    A a1<span class="op">;</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>    a1<span class="op">.</span>fA<span class="op">();</span> <span class="co">//компилятор вызовет не константный метод</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> A a2<span class="op">;</span> <span class="co">//константный объект</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>    a2<span class="op">.</span>fA<span class="op">();</span> <span class="co">//компилятор вызовет константный метод</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="константные-методы-класса-и-ключевое-слово-mutable">Константные методы класса и ключевое слово <code>mutable</code></h3>
<p>В константном методе не разрешено модифицировать переменные класса, но бывают ситуации, когда все-таки необходимо в таком методе изменить значение какой-нибудь переменной. Для «снятия константности» с <strong>переменных</strong>, требующих изменения, введено ключевое слово <code>mutable</code>. Такую переменную компилятор позволит модифицировать даже в константном методе класса. Например:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">mutable</span> <span class="dt">int</span> <span class="va">m_count</span><span class="op">;</span> <span class="co">//счетчик — сколько раз посредством метода</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//get() обращались к данному объекту</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> а <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> а<span class="op">;</span> <span class="va">m_count</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> get<span class="op">()</span> <span class="at">const</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_count</span><span class="op">++;</span> <span class="co">//если бы переменная m_count была объявлена без</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//ключевого слова mutable, компилятоp Вы выдал </span></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//ошибку!</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Замечание 1: ключевое слово <code>mutable</code> не может быть применено к статическим и <code>const</code>-переменным класса.</p>
<p>Замечание 2: методы с ключевым словом <code>mutable</code> объявлять нельзя.</p>
<h3 id="константные-объекты">Константные объекты</h3>
<p>Если в распоряжении программиста предоставлен константный объект, константная ссылка или указатель на константный объект (например, в качестве параметра функции), то компилятор позволит использовать такой объект только для чтения, то есть:</p>
<ul>
<li><p>читать доступные переменные,</p></li>
<li><p>вызывать доступные константные методы класса. Например:</p></li>
</ul>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f1<span class="op">();</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f2<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">(</span><span class="at">const</span> A<span class="op">&amp;</span> a<span class="op">)</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//a.m_a++; //ошибка компилятора</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> a<span class="op">.</span><span class="va">m_a</span><span class="op">;</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//a.f1(); //ошибка компилятора</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>f2<span class="op">();</span> <span class="co">//ОК!</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="тип-указателя-this">Тип указателя <code>this</code></h3>
<p>В обычном методе класса <code>А</code> указатель <code>this</code> ведет себя как константный указатель типа <code>A* const</code>, то есть любые попытки модифицировать <code>this</code> вызовут ошибку компилятора.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> A<span class="op">::</span>f1<span class="op">()</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">++;</span> <span class="co">//ошибка компилятора</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_a</span><span class="op">++;</span> <span class="co">//ОК</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>В константном методе класса this ведет себя как указатель типа <code>const A* const</code>, го есть посредством такого указателя можно только читать данные и модифицировать его запрещено.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> A<span class="op">::</span>f1<span class="op">()</span> <span class="at">const</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">++;</span> <span class="co">//ошибка компилятора</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_a</span><span class="op">++;</span> <span class="co">//ошибка компилятора</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="указатель-на-класс.-доступ-к-членам-класса-посредством-указателя.-селектор--">Указатель на класс. Доступ к членам класса посредством указателя. Селектор «<code>-&gt;</code>»</h2>
<p>Так как понятие класс определяет тип данных, то в соответствии с логикой языка C++ ничто не мешает (а иногда без этого не получить преимуществ ООП) объявить переменную — «указатель на класс». Как и обычный указатель, он хранит адрес объекта и может использоваться не только не только для получения адреса «самого объекта», но и для доступа к <code>public</code> членам класса (как к членам-данным, так и для вызова методов).</p>
<p>Пример:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Set<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pA <span class="op">=</span> <span class="kw">new</span> A<span class="op">();</span> <span class="co">//а) компилятор динамически выделит память —</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//sizeof(A)</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//б) вызовет default конструктор</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//в) проинициализирует указатель рА адресом</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//объекта</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a><span class="co">//  int nX = рА-&gt;m_а;//доступ к private-элементам данных класса</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//посредством указателя тоже запрещен ⇒ ошибка</span></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>    pA<span class="op">-&gt;</span>Set<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">//вызов public-метода посредством указателя</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> pA<span class="op">;</span> <span class="co">//динамически созданный объект необходимо уничтожить</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>               <span class="co">//(перед освобождением памяти будет вызван деструктор)</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="использование-указателя">Использование указателя</h3>
<p>Если в нашем распоряжении есть указатель, а функция принимает объект по значению или по ссылке:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F1<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F2<span class="op">(</span>A<span class="op">&amp;);</span></span></code></pre></div>
<p>Вызов:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>    F1<span class="op">(*</span>рА<span class="op">);</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    F2<span class="op">(*</span>рА<span class="op">);</span></span></code></pre></div>
<p>И наоборот, если в нашем распоряжении есть объект, а функция принимает указатель:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F3<span class="op">(</span>A<span class="op">*);</span></span></code></pre></div>
<p>Вызов:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">;</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    F3<span class="op">(&amp;</span>a<span class="op">);</span></span></code></pre></div>
<p>Замечание: в качестве параметра можно сформировать адрес неименованного автоматического объекта, так как он будет существовать до конца вычисления выражения:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>    F3<span class="op">(&amp;</span>A<span class="op">(</span><span class="dv">33</span><span class="op">));</span><span class="co">//1) — конструктор для автоматического</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>               <span class="co">//неименованного объекта,</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>               <span class="co">//2) его адрес в стек</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>               <span class="co">//3) после возврата из функции — деструктор</span></span></code></pre></div>
<h2 id="массивы-и-классы">Массивы и классы</h2>
<h3 id="массив-объектов-класса">Массив объектов класса</h3>
<p>Пример:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m_а<span class="op">;</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> х <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> m_а <span class="op">=</span> х<span class="op">;</span> <span class="op">}</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>        A ar1<span class="op">[</span><span class="dv">5</span><span class="op">];</span> <span class="co">//массив из пяти объектов A. При создании каждого</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//элемента массива вызывается конструктор по</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//умолчанию</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>        A ar2<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> A<span class="op">(</span><span class="dv">1</span><span class="op">),</span> A<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">};</span> <span class="co">//массив из двух объектов A. При</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//создании каждого элемента</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//массива вызывается конструктор</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//с аргументами. Оптимизация</span></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//компилятора: каждый элемент</span></span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//массива конструируется прямо</span></span>
<span id="cb86-19"><a href="#cb86-19" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//«на месте» — автоматических</span></span>
<span id="cb86-20"><a href="#cb86-20" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//неименованных объектов</span></span>
<span id="cb86-21"><a href="#cb86-21" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//компилятор не создает.</span></span>
<span id="cb86-22"><a href="#cb86-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-23"><a href="#cb86-23" aria-hidden="true" tabindex="-1"></a>        A ar3<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> A<span class="op">(</span><span class="dv">1</span><span class="op">),</span> A<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">};</span> <span class="co">//массив из трех объектов A. При</span></span>
<span id="cb86-24"><a href="#cb86-24" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//создании первых двух элементов</span></span>
<span id="cb86-25"><a href="#cb86-25" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//массива вызывается конструктор</span></span>
<span id="cb86-26"><a href="#cb86-26" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//с аргументами, при создании</span></span>
<span id="cb86-27"><a href="#cb86-27" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//третьего — конструктор по</span></span>
<span id="cb86-28"><a href="#cb86-28" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//умолчанию</span></span>
<span id="cb86-29"><a href="#cb86-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-30"><a href="#cb86-30" aria-hidden="true" tabindex="-1"></a>        A ar4<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span> <span class="co">//а здесь (если неявные</span></span>
<span id="cb86-31"><a href="#cb86-31" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//преобразования не запрещены —</span></span>
<span id="cb86-32"><a href="#cb86-32" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//explicit) компилятор вызовет для</span></span>
<span id="cb86-33"><a href="#cb86-33" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//каждого элемента массива</span></span>
<span id="cb86-34"><a href="#cb86-34" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//конструктор с одним параметром</span></span>
<span id="cb86-35"><a href="#cb86-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-36"><a href="#cb86-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span><span class="co">//вызываются деструкторы для всех элементов всех массивов</span></span>
<span id="cb86-37"><a href="#cb86-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-38"><a href="#cb86-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">//но!</span></span>
<span id="cb86-39"><a href="#cb86-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-40"><a href="#cb86-40" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> р <span class="op">=</span> <span class="kw">new</span> A<span class="op">[</span><span class="dv">10</span><span class="op">];</span> <span class="co">//динамическое выделение памяти под 10</span></span>
<span id="cb86-41"><a href="#cb86-41" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//элементов типа A и вызов для каждого</span></span>
<span id="cb86-42"><a href="#cb86-42" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//конструктора по умолчанию</span></span>
<span id="cb86-43"><a href="#cb86-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-44"><a href="#cb86-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">//*Вызовите для каждого элемента массива public метод*</span></span>
<span id="cb86-45"><a href="#cb86-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-46"><a href="#cb86-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span><span class="op">[]</span> р<span class="op">;</span> <span class="co">//вызов деструктора для каждого элемента</span></span>
<span id="cb86-47"><a href="#cb86-47" aria-hidden="true" tabindex="-1"></a>                <span class="co">//динамического массива и освобождение памяти</span></span>
<span id="cb86-48"><a href="#cb86-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="массив-указателей-на-объекты-класса">1.1.6. Массив указателей на объекты класса</h4>
<p>Пример:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> par1<span class="op">[</span><span class="dv">5</span><span class="op">];</span> <span class="co">//неинициализированный массив из пяти указателей на</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>                <span class="co">//объекты А</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="co">//Замечание: если разные элементы массива будут содержать разные по</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="co">//своей природе адреса (например, и стековых объектов, и</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a><span class="co">//динамических) — с таким массивом работать очень трудно ⇒</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>    A a1<span class="op">(</span><span class="dv">1</span><span class="op">),</span> a2<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> par2<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="op">&amp;</span>a1<span class="op">,</span> <span class="op">&amp;</span>a2 <span class="op">};</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a><span class="co">//или</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> рar3<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="kw">new</span> A<span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="kw">new</span> A<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">};</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>                <span class="co">//массив из трех указателей на объекты А. Два первых</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>                <span class="co">//элемента массива проинициализированы, третий</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>                <span class="co">//инициализируется нулем по правилам неполной</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>                <span class="co">//инициализации массивов с элементами базового типа</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Вызовите для каждого элемента массива public метод</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span> <span class="kw">delete</span> рar3<span class="op">[</span>i<span class="op">];</span> <span class="op">}</span></span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">//delete корректно работает с нулевым указателем</span></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> par2<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="op">&amp;</span>A<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">),</span> <span class="op">&amp;</span>A<span class="op">(</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">};</span></span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a>                <span class="co">//можно ли проинициализировать массив таким</span></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a>                <span class="co">//образом???</span></span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="поля-битов-bit-fields">Поля битов (bit fields)</h2>
<p>Если мы заведомо знаем, что наши целочисленные данные очень короткие, то есть диапазон изменения значений мал, то логично отвести под такие данные ровно столько памяти, сколько может занимать максимально (минимально) возможное значение в нашем диапазоне.</p>
<p>Рассмотрим способы минимизации использования памяти:</p>
<p><em>Способ №1</em>: для хранения значения каждого данного объявляем в классе целочисленную переменную. При выборе типа переменной стараемся экономить память:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Date</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> month<span class="op">;</span><span class="co">//а на самом деле диапазон изменения</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//значений 0-12 ⇒ достаточно 4 бита</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">short</span> year<span class="op">;</span><span class="co">//а на самом деле диапазон изменения</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//значений 0-3000 0хbb8⇒ достаточно 12 битов</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> day<span class="op">;</span><span class="co">//а на самом деле диапазон изменения значений</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//0-31 0x1f-&gt; достаточно 5 битов</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>При таком подходе все равно образуется неиспользуемый резерв — «избыточные» неиспользуемые разряды, а с учетом выравнивания полей компилятором и дополнительные неиспользуемые байты.</p>
<p><em>Способ №2</em>: зная, что все наши данные «помещаются» в 32 разряда, объявляем в классе одну переменную типа <code>int</code> или <code>unsigned int</code> и сами «распределяем» в ней разряды следующим образом:</p>
<p><img src="media/image16.svg" /></p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Date <span class="op">{</span> <span class="dt">unsigned</span> <span class="dt">int</span> date<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<p>При таком подходе:</p>
<p>а) приходилось бы все время помнить: какие биты для чего нами отведены, б) приходилось бы все время самим применять побитовые операции для извпечения/запаковки значений.</p>
<p><em>Способ №3</em>: альтернативой приведенным вариантам является использование битовых полей (при этом программист избегает неэффективности первого варианта и неудобств при использовании второго варианта). Язык C++ допускает использование в структурах и классах (только!!!) особого типа полей — битовых полей. Использование таких полей делает возможным простой доступ к совокупностям битов, при этом экономится память, так как мы отводим под данные ровно столько разрядов, сколько требуется. Для битовых полей компилятор за программиста а) выделяет биты и б) осуществляет побитовые операции и сдвиги, извлекая или запаковывая значения.</p>
<p>Объявление битового поля:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>целый_тип <span class="op">[</span>идентификатор<span class="op">]</span> <span class="op">:</span> размер_поля_в_битах<span class="op">;</span></span></code></pre></div>
<ol type="1">
<li>целый тип может быть <code>signed</code> и <code>unsigned</code> (таким образом Вы сообщаете компилятору — как интерпретировать этот диапазон, в частности как «распаковывать» значения)</li>
<li>в качестве целого типа могут быть использованы <code>char</code>, <code>short</code> или <code>int</code></li>
<li>в качестве типа целого может быть использован enum (интерпретируется компилятором как <code>signed int</code>)</li>
<li>если идентификатор опущен, анонимное битовое поле, которое используется для выравнивания (padding). Замечание: анонимное битовое поле с нулевым размером указывает компилятору разместить следующее ноле, начиная с границы типа</li>
</ol>
<p>Пример:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> DAY <span class="op">{</span> MONDAY<span class="op">,</span> TUESDAY<span class="op">,</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Date</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> month <span class="op">:</span> <span class="dv">4</span><span class="op">;</span><span class="co">//4 бита</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    DAY nWeekDay <span class="op">:</span> <span class="dv">4</span><span class="op">;</span> <span class="co">//0..7 (4 bits). Так как enum это эквивалент</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//signed int ⇒ следует зарезервировать один</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//один дополнительный бит под знак или</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//сопоставить именованным константам другие</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//значения???</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> year <span class="op">:</span> <span class="dv">12</span><span class="op">;</span><span class="co">//12 битов</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> day <span class="op">:</span> <span class="dv">5</span><span class="op">;</span><span class="co">//5 битов</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Во всех приведенных ниже методах мы пользуемся битовыми полями</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">//как обычными переменными класса, а компилятор сам осуществляет</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">//запаковку/распаковку значений с помощью побитовых операторов и</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">//операторов сдвига</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>    Date<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">unsigned</span> <span class="dt">int</span> year<span class="op">,</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> day<span class="op">,</span> DAY wd<span class="op">)</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> month <span class="op">=</span> m<span class="op">;</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> GetMonth<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> month<span class="op">;</span> <span class="op">}</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">//«вручную» нам бы пришлось: return date &amp; 0xf;</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> SetMonth<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> m<span class="op">)</span> <span class="op">{</span> month <span class="op">=</span> m<span class="op">;</span> <span class="op">}</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">//date = (m &amp; 0xf) | (date &amp; 0xff...f0);</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>    Date d<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2006</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> SUNDAY<span class="op">);</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> month <span class="op">=</span> d<span class="op">.</span>GetMonth<span class="op">();</span></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 1: специфика Microsoft — порядок выделения битов в порядке объявления, начиная с младшего. В других компиляторах правила могут быть другими.</p>
<p><img src="media/image17.svg" /></p>
<p>Замечание 2: иногда для каких-либо специфических целей требуется указать компилятору, что одну группу битовых полей я хочу запаковать в один <code>unsigned int</code>, а следующую в другой — для этих целей используется неименованное битовое поле нулевой длины</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Date</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> month <span class="op">:</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    DAY nWeekDay <span class="op">:</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//Следующее поле будет расположено в</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//зависимости от типа поля(и от компилятора)</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> year <span class="op">:</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> day <span class="op">:</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><img src="media/image18.svg" /></p>
<p>Для поля битов нельзя:</p>
<ul>
<li><p>получить адрес: <code>int* р = &amp;m_х; //ошибка</code></p></li>
<li><p><code>int&amp; r = m_x; //объявить ссылку и проинициализировать ее битовым полем</code></p></li>
<li><p>оператор <code>sizeof</code> с ними тоже не работает — illegal sizeof operand</p></li>
</ul>
<p>а в остальном можно пользоваться как любой другой переменной класса.</p>
<h2 id="список-инициализаторов">Список инициализаторов</h2>
<p>Замечание: согласно новому стандарту С++11 перечисленные ниже ограничения компилятор игнорирует, поэтому список инициализаторов может быть использован в тех случаях, когда нужно только проинициализировать переменные объекта и не требуется производить какие-нибудь дополнительные действия.</p>
<p>Объект класса (или структуры C++) можно проинициализировать также как структуру только в том случае, если класс не содержат:</p>
<ul>
<li><p>конструкторов,</p></li>
<li><p><code>private</code> или <code>protected</code> членов</p></li>
<li><p>базовых классов,</p></li>
<li><p>виртуальных функций</p></li>
</ul>
<p>Например:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span> <span class="co">//так как защищенные переменные компилятор не позволит</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//инициализировать посредством списка инициализаторов</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> ar<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Func<span class="op">();</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>    A a <span class="op">=</span> <span class="op">{</span> <span class="dv">5</span><span class="op">,</span> <span class="st">&quot;ABC&quot;</span> <span class="op">};</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="тема-ii.-открытое-одиночное-наследование">Тема II. Открытое одиночное наследование</h1>
<h2 id="взаимоотношения-между-классами">Взаимоотношения между классами</h2>
<p><em>Правило 1: различайте понятия: «является» (is-а), «содержит» (has-а) и «подобен» (as-а)!</em></p>
<p>Отношения между классами могут быть трех видов:</p>
<p><img src="media/image19.svg" /></p>
<p>Замечание: для корректного построения иерархии классов программист должен четко представлять различия этих трех видов взаимоотношений и применять их исключительно по назначению.</p>
<h2 id="одиночное-или-простое-наследование">Одиночное (или простое) наследование</h2>
<p><em>Правило 2: не перегружайте базовый класс понятиями. Обычно для задания общих для всех потомков свойств достаточно в базовый класс ввести 7-8 понятий.</em></p>
<p>Классы чаще всего строятся постепенно, начиная от простых базовых классов с общими для некоторого множества объектов свойствами и заканчивая «навороченными» специализированными классами-монстрами. Каждый раз, когда от предыдущего класса производится последующий, производный класс наследует какие-то или все родительские качества, добавляя к ним новые свойства (или, наоборот, убирая лишние). На свойстве наследования основана популярность библиотек классов (таких как MFC, OWL и Qt). При этом ощутимым преимуществом для программиста является использование разработанных и отлаженных профессионалами классов в качестве базовых для своих более специализированных целей.</p>
<p>Наследование может быть одиночным или множественным. Отличия:</p>
<table style="width:94%;">
<colgroup>
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>одиночное</th>
<th>множественное</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Каждый производный класс имеет только одного непосредственного предка (хотя иерархия может быть достаточно сложной)</td>
<td>Производный класс наследует свойства двух и более «родителей»</td>
</tr>
<tr class="even">
<td><img src="media/одиночное.svg" /></td>
<td><img src="media/множеств.svg" /></td>
</tr>
</tbody>
</table>
<p>Замечание: множественное наследование сложнее в реализации и будет рассмотрено позже (<a href="#тема-x.-множественное-наследование">раздел «Множественное наследование»</a>).</p>
<h3 id="объявление-производного-класса-при-одиночном-наследовании">Объявление производного класса при одиночном наследовании</h3>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> имя_производного_класса <span class="op">:</span> <span class="op">[</span>спецификатор_наследования<span class="op">]</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>имя_базового_класса <span class="op">{</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    список_членов_производного_класса</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Например:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> А <span class="op">{</span> список членов класса А <span class="op">};</span> <span class="co">//базовый класс</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> В <span class="op">:</span> <span class="kw">public</span> А <span class="op">{</span> список членов класса В<span class="op">};</span> <span class="co">//производный класс</span></span></code></pre></div>
<p>Такое объявление говорит компилятору о том, что:</p>
<ul>
<li><p>класс <code>B</code> включает в себя, как составляющую весь класс <code>A</code>,</p></li>
<li><p>в зависимости от спецификатора наследования и спецификаторов доступа методы класса <code>B</code> имеют право обращаться к членам класса <code>A</code> или нет.</p></li>
</ul>
<p>Замечание: конструкторы, деструкторы и оператор присваивания не наследуются! Наследуются данные и остальные методы класса.</p>
<h3 id="спецификатор-protected-в-базовом-классе">Спецификатор <code>protected</code> в базовом классе</h3>
<p>Спецификатор <code>protected</code> используется при наследовании и действует только в методах класса. Означает:</p>
<table style="width:94%;">
<colgroup>
<col style="width: 30%" />
<col style="width: 31%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>Спецификатор доступа в базовом классе</th>
<th>Доступ извне посредством объекта производного класса</th>
<th>Доступ из методов производного класса к элементам базового класса</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>public:</code></td>
<td>доступен</td>
<td>доступен</td>
</tr>
<tr class="even">
<td><code>protected:</code></td>
<td>не доступен</td>
<td>доступен</td>
</tr>
<tr class="odd">
<td><code>private:</code></td>
<td>не доступен</td>
<td>не доступен</td>
</tr>
</tbody>
</table>
<p>Пример:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a1</span><span class="op">;</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FA1<span class="op">();</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a2</span><span class="op">;</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FA2<span class="op">();</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FA3<span class="op">();</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b1</span><span class="op">;</span></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FB1<span class="op">();</span></span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b2</span><span class="op">;</span></span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FB2<span class="op">();</span></span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FB3<span class="op">();</span></span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Внутри метода производного класса:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> В<span class="op">::</span>FB3<span class="op">()</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_b1</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">//ОК</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    FA3<span class="op">();</span>    <span class="co">//ОК</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_a2</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">//ОК</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>    FA2<span class="op">();</span>    <span class="co">//ОК</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a><span class="co">//  m_a1 = 2; //ошибка — нет прав доступа</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="co">//  FA1();    //ошибка — нет прав доступа</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>«Извне» класса:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    А а<span class="op">;</span> <span class="co">//вызывается конструктор А</span></span></code></pre></div>
<figure>
<img src="media/image20.svg" alt="Объект a" /><figcaption aria-hidden="true">Объект a</figcaption>
</figure>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span> <span class="co">//конструктор А, потом В</span></span></code></pre></div>
<figure>
<img src="media/image21.svg" alt="Объект b" /><figcaption aria-hidden="true">Объект b</figcaption>
</figure>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//доступ к членам посредством объекта базового типа</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    а<span class="op">.</span>FA3<span class="op">();</span> <span class="co">//ОК</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//доступ к членам посредством объекта производного типа</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>FB3<span class="op">();</span> <span class="co">//ОК</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>FA3<span class="op">();</span> <span class="co">//ОК</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="спецификаторы-наследования-при-объявлении-производного-класса">Спецификаторы наследования при объявлении производного класса</h3>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">:</span> <span class="op">&lt;</span>спецификатор наследования<span class="op">&gt;</span> A <span class="op">{</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><img src="media/image22.svg" /></p>
<p>Замечание: если спецификатор наследования опущен, то компилятор по умолчанию считает, что он <code>private</code>!</p>
<p>Закрытое наследование специфично и будет рассмотрено позже (<a href="#тема-ix.-защищенное-наследование.-отношение-между-классами-подобен">раздел «Закрытое наследование»</a>).</p>
<h3 id="порядок-вызовов-конструкторов-при-создании-экземпляра-производного-класса">Порядок вызовов конструкторов при создании экземпляра производного класса</h3>
<p>При создании экземпляра любого класса любым способом вызывается его конструктор. Если класс является производным, кроме конструктора данного класса должен быть также вызван конструктор базового класса. Создание объекта начинается с базовой части, поэтому порядок вызовов конструкторов в C++ фиксирован: прежде всего вызывается конструктор базового класса, затем вызываются конструкторы всех промежуточных классов согласно иерархии наследования, и наконец, вызывается конструктор целевого класса. Приведенный порядок имеет смысл, поскольку производные классы имеют более специализированный характер, чем базовый, поэтому специализированная часть «накладывается» поверх общей.</p>
<p>Пример:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> B <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span></code></pre></div>
<p>При создании экземпляра класса C конструкторы вызываются в следующем порядке:</p>
<pre><code>A::A() -&gt; B::B() -&gt; C::C()</code></pre>
<p>Осуществляется вызов конструктора базового класса в том коде, который компилятор генерирует по открывающей фигурной скобке конструктора:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>C<span class="op">::</span>C<span class="op">(</span>параметры<span class="op">)</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="co">//вызов конструктора базового класса B</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//тело конструктора класса C</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>B<span class="op">::</span>B<span class="op">(</span>параметры<span class="op">)</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="co">//вызов конструктора базового класса A</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//тело конструктора класса B</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>A<span class="op">::</span>A<span class="op">(</span>параметры<span class="op">)</span></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//тело конструктора класса A</span></span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="порядок-вызовов-деструкторов-при-разрушении-экземпляра-производного-класса">Порядок вызовов деструкторов при разрушении экземпляра производного класса</h3>
<p>Деструкторы при разрушении объекта производного класса вызываются в порядке, обратном вызову конструкторов Причина та же: сначала разрушаются специализированные части, затем общие. Например, при разрушении экземпляра класса <code>C</code> порядок вызовов деструкторов будет следующим:</p>
<pre><code>C::~C() -&gt; B::~B() -&gt; A::~A()</code></pre>
<p>Осуществляется вызов деструкторов базового класса в том коде, который компилятор генерирует по закрывающей фигурной скобке деструктора:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>C<span class="op">::~</span>C<span class="op">()</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//тело деструктора класса C</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//вызов деструктора базового класса B</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>B<span class="op">::~</span>B<span class="op">()</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//тело деструктора класса B</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//вызов деструктора базового класса A</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>A<span class="op">::~</span>A<span class="op">()</span></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a><span class="co">//тело деструктора класса A</span></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: если объект был создан динамически, то при выполнении оператора <code>delete</code> сначала вызываются деструкторы, а потом только освобождается память (то есть на время выполнения деструктора сам объект еще гарантированно существует).</p>
<h3 id="аргументы-конструктора-передаваемые-в-базовый-класс">Аргументы конструктора, передаваемые в базовый класс</h3>
<p>Так как производный класс содержит в себе базовую часть, при создании экземпляра производного класса обычно возникает необходимость передать какие-то параметры конструктору базового класса. Так как конструктор базового класса выполняется раньше, чем конструктор производного, то конструктору базового класса нужно <strong>явно</strong> передать предназначенные ему параметры. Поэтому для передачи параметров конструктору базового класса используется специальная запись.</p>
<p>Модифицируем класс <code>Animal</code>. До сих пор мы абстрагировали какое-то обобщенное животное. Теперь вынесем общие для любого животного свойства в базовый класс, а от него наследуем более специализированный класс, абстрагирующий собаку.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Animal.h</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> SEX <span class="op">{</span> MALE<span class="op">,</span> FEMALE <span class="op">};</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span><span class="co">//изменяем спецификатор доступа таким образом, чтобы эти</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>          <span class="co">//понятия были доступны методам производного класса</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_age</span><span class="op">;</span> <span class="co">//у любого животного должен быть возраст</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    SEX <span class="va">m_sex</span><span class="op">;</span> <span class="co">//у любого животного должен быть пол</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> <span class="va">m_pName</span><span class="op">;</span> <span class="co">//у любого животного может быть имя</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">(</span><span class="dt">int</span> age<span class="op">,</span> SEX s<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> pName <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Dog.h</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;Animal.h&quot;</span><span class="pp"> </span><span class="co">//компилятор должен знать свойства базового</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//класса</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dog <span class="op">:</span> <span class="kw">public</span> Animal</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="va">m_bHasMaster</span><span class="op">;</span> <span class="co">//есть дикие и домашние собаки -&gt; может быть</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//хозяин</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> <span class="va">m_pMasterName</span><span class="op">;</span> <span class="co">//а если есть хозяин, то у него должно быть</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//имя</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>    Dog<span class="op">(</span><span class="dt">int</span> age<span class="op">,</span> SEX s<span class="op">,</span> <span class="dt">bool</span> master<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> pName<span class="op">,</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> pMaster<span class="op">);</span> <span class="co">//параметры age, s, pName предназначены</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//конструктору базового класса, а параметры master</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//и pMaster предназначены производному классу</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Dog.cpp</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>Dog<span class="op">::</span>Dog<span class="op">(</span><span class="dt">int</span> age<span class="op">,</span> SEX s<span class="op">,</span> <span class="dt">bool</span> master<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> pName<span class="op">,</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> pMaster</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span> <span class="op">:</span> Animal<span class="op">(</span>age<span class="op">,</span> s<span class="op">,</span> pName<span class="op">)</span> <span class="co">//передача параметров конструктору</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>                              <span class="co">//базового класса</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="co">//здесь будет вызван конструктор базового класса с указанными</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a> <span class="co">//параметрами, который проинициализирует базовую часть объекта</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//работа с производной частью объекта</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_bHasMaster</span> <span class="op">=</span> master<span class="op">;</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_pMasterName</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">char</span><span class="op">[</span>strlen<span class="op">(</span>pMaster<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>    strcpy<span class="op">(</span><span class="va">m_pMasterName</span><span class="op">,</span> pMaster<span class="op">);</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="специфика-передачи-параметров-конструктору-копирования-базового-класса">1.1.7. Специфика передачи параметров конструктору копирования базового класса</h4>
<p>Если Вы явно не определяете в производном классе конструктор копирования, то автоматический конструктор копирования (сгенерированный компилятором) будет вызывать конструктор копирования базового класса (определенный программистом или тоже автоматический). Но, если Вы определяете в производном классе конструктор копирования, но не вызываете явно конструктор копирования базового класса, компилятор вызывать сам конструктор копирования базового класса не будет, а базовая часть нового объекта будет сконструирована с помощью default-конструктора.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>Dog<span class="op">::</span>Dog<span class="op">(</span><span class="at">const</span> Dog<span class="op">&amp;</span> ref<span class="op">)</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> Animal<span class="op">(</span>ref<span class="op">)</span> <span class="co">//указываем компилятору, каким конструктором</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//базового класса следует инициализировать базовую часть (в</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//нашем случае логично вызывать конструктор копирования базового</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//класса)</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Замечание: компилятор сам неявно приведет тип</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//параметра const Dog&amp; ref к константной ссылке базового типа</span></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//const Animals</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_pMasterName</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">char</span><span class="op">[</span>strlen<span class="op">(</span>ref<span class="op">.</span><span class="va">m_pMasterName</span><span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>    strcpy<span class="op">(</span><span class="va">m_pMasterName</span><span class="op">,</span> ref<span class="op">.</span><span class="va">m_pMasterName</span><span class="op">);</span></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_bHasMaster</span> <span class="op">=</span> ref<span class="op">.</span><span class="va">m_bHasMaster</span><span class="op">;</span></span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Дана иерархия классов:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span></code></pre></div>
<p>Подумайте, для каких классов в приведенных ниже примерах программист должен явно реализовать конструктор копирования:</p>
<ul>
<li><p>A — простой класс. B — простой класс</p></li>
<li><p>A — простой класс, B — сложный класс</p></li>
<li><p>A — сложный класс, B — простой класс</p></li>
<li><p>A — сложный класс, B — сложный класс</p></li>
</ul>
</blockquote>
<h3 id="открытое-public-наследование">Открытое (<code>public</code>) наследование</h3>
<p>Иерархия классов работает эффективно только в том случае, если она корректно спроектирована.</p>
<h4 id="правило-3">1.1.8. Правило №3</h4>
<blockquote>
<p>Правило 3: открытое наследование в C++ моделирует следующее утверждение — «производный класс есть разновидность базового класса» ⇒ все. что применимо к базовому классу, должно быть также применимо к производному ⇒ везде, где может быть использован объект <code>A</code>, может быть использован и объект <code>В</code>, поскольку объект <code>В</code> содержит базовую часть <code>A</code>.</p>
</blockquote>
<p>Пример:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//базовый класс абстрагирует обобщенный прямоугольник</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_left</span><span class="op">,</span> <span class="va">m_right</span><span class="op">,</span> <span class="va">m_top</span><span class="op">,</span> <span class="va">m_bottom</span><span class="op">;</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//у любого прямоугольника должны быть координаты</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>    Rect<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> b<span class="op">);</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//другие методы</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ColoredRect <span class="op">:</span> <span class="kw">public</span> Rect <span class="co">//производный класс добавляет к</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>                                <span class="co">//координатам цвет</span></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> eColor <span class="op">{</span> RED <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> GREEN <span class="op">=</span> <span class="dv">2</span><span class="op">,</span> BLUE <span class="op">=</span> <span class="dv">4</span> <span class="op">};</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>    eColor <span class="va">m_color</span><span class="op">;</span> <span class="co">//у цветного прямоугольника есть цвет</span></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>    ColoredRect<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> eColor c<span class="op">);</span></span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> SetColor<span class="op">(</span>eColor c<span class="op">)</span> <span class="op">{</span> <span class="va">m_color</span> <span class="op">=</span> c<span class="op">;</span> <span class="op">}</span></span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">//другие методы</span></span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>    Rect r<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a>    ColoredRect cr<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> ColoredRect<span class="op">::</span>RED<span class="op">);</span></span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">//очевидно:</span></span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>SetColor<span class="op">(</span>ColoredRect<span class="op">::</span>RED<span class="op">);</span> <span class="co">//ошибка, так как в базовом классе</span></span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//такого метода нет</span></span>
<span id="cb112-28"><a href="#cb112-28" aria-hidden="true" tabindex="-1"></a>    cr<span class="op">.</span>SetColor<span class="op">(</span>ColoredRect<span class="op">::</span>RED<span class="op">);</span> <span class="co">//OK</span></span>
<span id="cb112-29"><a href="#cb112-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Глобальные функции, принимающие в качестве параметров адреса (ссылки или указатели) или значения объектов пользовательского типа:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>Rect UnionRects<span class="op">(</span><span class="at">const</span> Rect<span class="op">&amp;</span> ref1<span class="op">,</span> <span class="at">const</span> Rect<span class="op">&amp;</span> ref2<span class="op">)</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">//все прямоугольники можно «объединить»</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">,</span> r<span class="op">,</span> t<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Вычисление координат «описанного» прямоугольника</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>    Rect res<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> t<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>ColoredRect UnionColoredRects<span class="op">(</span><span class="at">const</span> ColoredRect<span class="op">&amp;</span> ref1<span class="op">,</span> <span class="at">const</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>    ColoredRect<span class="op">&amp;</span> ref2<span class="op">)</span> <span class="co">//только у цветных прямоугольников можно</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//«смешать» цвет</span></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">,</span> r<span class="op">,</span> t<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Вычисление координат «описанного» прямоугольника</span></span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> res_color <span class="op">=</span> ref1<span class="op">.</span>GetColor<span class="op">()</span> <span class="op">|</span> ref2<span class="op">.</span>GetColor<span class="op">();</span></span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a>    ColoredRect res<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> t<span class="op">,</span> b<span class="op">,</span> <span class="kw">static_cast</span><span class="op">&lt;</span>ColoredRect<span class="op">::</span></span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>        eColor<span class="op">&gt;(</span>res_color<span class="op">));</span></span>
<span id="cb113-18"><a href="#cb113-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb113-19"><a href="#cb113-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb113-20"><a href="#cb113-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb113-21"><a href="#cb113-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb113-22"><a href="#cb113-22" aria-hidden="true" tabindex="-1"></a>    Rect r<span class="op">;</span> <span class="co">//объект базового типа</span></span>
<span id="cb113-23"><a href="#cb113-23" aria-hidden="true" tabindex="-1"></a>    ColoredRect сr<span class="op">;</span> <span class="co">//объект производного типа</span></span>
<span id="cb113-24"><a href="#cb113-24" aria-hidden="true" tabindex="-1"></a>    Rect resR <span class="op">=</span> UnionRects<span class="op">(</span>r<span class="op">,</span> сr<span class="op">);</span> <span class="co">//OK — все прямоугольники можно</span></span>
<span id="cb113-25"><a href="#cb113-25" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//«объединить»</span></span>
<span id="cb113-26"><a href="#cb113-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">//unsigned int col = UnionColoredRects(r,сr);</span></span>
<span id="cb113-27"><a href="#cb113-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">//ошибка — только у цветных прямоугольников можно «смешать»</span></span>
<span id="cb113-28"><a href="#cb113-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">//цвет</span></span>
<span id="cb113-29"><a href="#cb113-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="пример-ошибочного-построения-иерархии-классов-при-открытом-наследовании">1.1.9. Пример ошибочного построения иерархии классов при открытом наследовании</h4>
<p>При открытом наследовании программист должен соблюдать правило: <strong>все, что справедливо для базового класса, должно также выполняться для производного класса</strong>. Следующий пример демонстрирует нарушение этого правила. Следствием является нерабочая иерархия классов:</p>
<p>В школе нас всех учили, что «квадрат — это прямоугольник, у которого все стороны равны». Попробуем реализовать это утверждение посредством иерархии классов.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> left<span class="op">,</span> top<span class="op">,</span> right<span class="op">,</span> bottom<span class="op">;</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    Rect<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> l<span class="op">;</span> top <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> r<span class="op">;</span> bottom <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> InflateRect<span class="op">(</span><span class="dt">int</span> dleft<span class="op">,</span> <span class="dt">int</span> dtop<span class="op">,</span> <span class="dt">int</span> dright<span class="op">,</span> <span class="dt">int</span> dbottom<span class="op">);</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//этот метод «раздвигает» стороны прямоугольника (каждую на свою</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//дельту)</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Square <span class="op">:</span><span class="kw">public</span> Rect <span class="co">//наследует метод InflateRect</span></span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a><span class="co">//координаты квадрата хранятся в базовой части</span></span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>    Square<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> dx<span class="op">)</span> <span class="op">:</span></span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a>        Rect<span class="op">(</span>l<span class="op">,</span> t<span class="op">,</span> l <span class="op">+</span> dx<span class="op">,</span> t <span class="op">+</span> dx<span class="op">)</span></span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{}</span> <span class="co">//конструктор принимает в качестве параметров координаты</span></span>
<span id="cb114-21"><a href="#cb114-21" aria-hidden="true" tabindex="-1"></a>       <span class="co">//центра и длину стороны -&gt; создается всегда квадрат!!!</span></span>
<span id="cb114-22"><a href="#cb114-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb114-23"><a href="#cb114-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb114-24"><a href="#cb114-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb114-25"><a href="#cb114-25" aria-hidden="true" tabindex="-1"></a>    Rect r<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span> <span class="co">//прямоугольник (стороны не равны)</span></span>
<span id="cb114-26"><a href="#cb114-26" aria-hidden="true" tabindex="-1"></a>    Square sq<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span> <span class="co">//квадрат (все стороны равны)</span></span>
<span id="cb114-27"><a href="#cb114-27" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>InflateRect<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">);</span> <span class="co">//ОК — раздвинули стороны</span></span>
<span id="cb114-28"><a href="#cb114-28" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//прямоугольника на разные дельты</span></span>
<span id="cb114-29"><a href="#cb114-29" aria-hidden="true" tabindex="-1"></a>    sq<span class="op">.</span>InflateRect<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">);</span> <span class="co">//наш квадрат «вырождается» в</span></span>
<span id="cb114-30"><a href="#cb114-30" aria-hidden="true" tabindex="-1"></a>                                <span class="co">//прямоугольник</span></span>
<span id="cb114-31"><a href="#cb114-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>То есть некоторые утверждения, справедливые для прямоугольников, не выполняются для квадратов. А открытое наследование предполагает, что <strong>ВСЕ,</strong> что применимо к базовому классу, также применимо и к объектам производного класса!</p>
<p>Вариант правильного с точки зрения C++ построения иерархии: любой четырехугольник всегда может изменять все свои координаты на одно и то же приращение. К функциональности базового класса прямоугольник добавляет специфические для прямоугольников методы: все четыре координаты можно изменить каждую на свою дельту или прямоугольника можно «растянуть» по координате <code>x</code> на одну дельту (влево и вправо), а по координате <code>y</code> на другую дельту (вверх и вниз).</p>
<p><img src="media/image23.svg" /></p>
<blockquote>
<p>Замечание: при таком построении иерархии методы производного класса</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Rect<span class="op">::</span>Inflate<span class="op">(</span><span class="dt">int</span> dleft<span class="op">,</span> <span class="dt">int</span> dtop<span class="op">,</span> </span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dright<span class="op">,</span> <span class="dt">int</span> dbottom<span class="op">);</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Rect<span class="op">::</span>Inflate<span class="op">(</span><span class="dt">int</span> dx<span class="op">,</span> <span class="dt">int</span> dy<span class="op">);</span></span></code></pre></div>
<p>перекрывают область видимости метода базового класса <code class="sourceCode cpp"><span class="dt">void</span> Quadro<span class="op">::</span>lnflate<span class="op">(</span><span class="dt">int</span> d<span class="op">);</span></code> поэтому в следующем фрагменте компилятор выдаст ошибку:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    Rect r<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//r.Inflate(5); //компилятор выдает диагностику о том, что</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//подходящего метода в классе Rect нет</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Но! Всегда существует возможность вызвать любой <code>public</code> метод базового класса при открытом наследовании (<a href="#спецификатор-разрешения-области-видимости-при-наследовании">раздел «Спецификатор разрешения области видимости при наследовании»</a>).</p>
</blockquote>
<h2 id="полиморфизм.-виртуальные-функции">Полиморфизм. Виртуальные функции</h2>
<p>Для пояснения понятия полиморфизма в языках программирования рассмотрим аналог для разговорных языков (в частности русский язык является исключительно полиморфным языком):</p>
<blockquote>
<p><strong>переводить</strong> (книгу, бабушку через дорогу, деньги, стрелку…)</p>
</blockquote>
<p>Приведенный глагол можно связать с конкретным набором действий только тогда, когда известен сам объект воздействия.</p>
<p>Полиморфизм в C++ является одним из наиболее туманных понятий с точки зрения начинающего программиста. Полиморфизм — это свойство одного и того же кода C++ вести себя по-разному в зависимости от текущих условий выполнения программы. То есть во время выполнения программы в том месте, где программист вызывает метод класса, компилятор закладывает возможность вызова методов разных классов, связанных между собой наследованием (не путайте с перегрузкой имен функций — какая из одноименных функций будет вызвана, решает компилятор на этапе компиляции!).</p>
<p>Специфика:</p>
<ul>
<li><p>свойством полиморфизма могут обладать только методы класса (а обычные функции — не могут!),</p></li>
<li><p>механизм полиморфизма задействуется компилятором только в тех случаях, когда вызов метода осуществляется посредством адреса объекта, то есть посредством указателя или ссылки (в тех случаях, когда вызов метода осуществляется посредством объекта, компилятор генерирует обычный вызов метода класса — <a href="#вызов-public-метода-класса-нестатического.-указатель-this">раздел «Вызов нестатического метода класса»</a>)</p></li>
<li><p>при использовании виртуальных методов,</p></li>
</ul>
<p>с одной стороны, программист получает несомненное преимущество - возможность объединения и манипуляции объектами производного типа посредством указателей или ссылок базового типа (при этом текст программы становится более компактным).</p>
<p>с другой стороны, (так как чудес не бывает) увеличивается объем используемой памяти и в некоторых случаях время выполнения.</p>
<h3 id="раннее-и-позднее-связывание">Раннее и позднее связывание</h3>
<p>C++ — гибридный язык. Он совмещает как процедурные, так и объектно- ориентированные возможности. Поэтому C++ использует и раннее, и позднее связывание и предоставляет программисту преимущества (и недостатки!) и одного, и другого.</p>
<p>Замечание: следует понимать, что при использовании раннего связывания программисту приходится реализовывать сложную логику работы программы «руками», например, используя громоздкие конструкции типа <code>switch-case</code>, в то время как при позднем связывании платой за облегчение жизни программиста является «более тяжелый» исполняемый код, занимающий больше памяти и/или дольше работающий.</p>
<p>Для того, чтобы продемонстрировать удобство использования полиморфизма, решим одну и ту же задачу с помощью раннего и позднего связывания.</p>
<h4 id="раннее-связывание">1.1.10. Раннее связывание</h4>
<p>Раннее связывание — это просто перегрузка имен функций. Этот механизм работает на этапе компиляции, то есть при наличии нескольких функций с одинаковым именем компилятор генерирует вызов конкретного тела функции. В случае перегрузки имен глобальных функций компилятор определяет, которую из функций следует вызвать в зависимости от количества и/или типа параметров. Это также справедливо при перегрузке имен методов одного и того же класса. Но при наследовании добавляется еще одна возможность — перегрузка методов, которые выглядят абсолютно одинаково (но действия совершают разные), например:</p>
<!-- TODO -->
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> ANIMAL_TYPE <span class="op">{</span> ANY<span class="op">,</span> DOG<span class="op">,</span> CAT <span class="op">};</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal <span class="co">//базовый класс, описывающий любое обобщенное животное</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;???&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//заглушка, так как не очень понятно: что может «говорить»</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//такое обобщенное животное</span></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dog <span class="op">:</span> <span class="kw">public</span> Animal <span class="co">//производный класс, абстрагирующий собаку</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Гав !&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">//реализации данного метода для класса Dog предполагает одну</span></span>
<span id="cb117-18"><a href="#cb117-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">//функциональность</span></span>
<span id="cb117-19"><a href="#cb117-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb117-20"><a href="#cb117-20" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Cat <span class="op">:</span> <span class="kw">public</span> Animal <span class="co">//производный класс, абстрагирующий кошку</span></span>
<span id="cb117-21"><a href="#cb117-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb117-22"><a href="#cb117-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb117-23"><a href="#cb117-23" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb117-24"><a href="#cb117-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb117-25"><a href="#cb117-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Мяу!&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb117-26"><a href="#cb117-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">//а от кошки в точно такой же ситуации ожидается другая</span></span>
<span id="cb117-27"><a href="#cb117-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">//функциональность</span></span>
<span id="cb117-28"><a href="#cb117-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb117-29"><a href="#cb117-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb117-30"><a href="#cb117-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb117-31"><a href="#cb117-31" aria-hidden="true" tabindex="-1"></a>    Animal a<span class="op">;</span></span>
<span id="cb117-32"><a href="#cb117-32" aria-hidden="true" tabindex="-1"></a>    Dog d<span class="op">;</span></span>
<span id="cb117-33"><a href="#cb117-33" aria-hidden="true" tabindex="-1"></a>    Cat c<span class="op">;</span></span>
<span id="cb117-34"><a href="#cb117-34" aria-hidden="true" tabindex="-1"></a>    F1<span class="op">(&amp;</span>a<span class="op">);</span> <span class="co">//будет выведено: &quot;???&quot;</span></span>
<span id="cb117-35"><a href="#cb117-35" aria-hidden="true" tabindex="-1"></a>    F1<span class="op">(&amp;</span>d<span class="op">);</span> <span class="co">//&quot;???&quot;</span></span>
<span id="cb117-36"><a href="#cb117-36" aria-hidden="true" tabindex="-1"></a>    F1<span class="op">(&amp;</span>c<span class="op">);</span> <span class="co">//&quot;???&quot;</span></span>
<span id="cb117-37"><a href="#cb117-37" aria-hidden="true" tabindex="-1"></a>    F2<span class="op">(&amp;</span>a<span class="op">,</span> ANY<span class="op">);</span> <span class="co">//&quot;???&quot;</span></span>
<span id="cb117-38"><a href="#cb117-38" aria-hidden="true" tabindex="-1"></a>    F2<span class="op">(&amp;</span>d<span class="op">,</span> DOG<span class="op">);</span> <span class="co">//&quot;Гав!&quot;</span></span>
<span id="cb117-39"><a href="#cb117-39" aria-hidden="true" tabindex="-1"></a>    F2<span class="op">(&amp;</span>c<span class="op">,</span> CAT<span class="op">);</span> <span class="co">//&quot;Мяу!&quot;</span></span>
<span id="cb117-40"><a href="#cb117-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb117-41"><a href="#cb117-41" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F1<span class="op">(</span><span class="at">const</span> Animal<span class="op">*</span> p<span class="op">)</span><span class="co">//глобальная функция, которая принимает в</span></span>
<span id="cb117-42"><a href="#cb117-42" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//качестве параметра указатель базового типа</span></span>
<span id="cb117-43"><a href="#cb117-43" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//Animal*, а сам объект, адрес которого</span></span>
<span id="cb117-44"><a href="#cb117-44" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//получает функция, может быть как базового</span></span>
<span id="cb117-45"><a href="#cb117-45" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//типа Animal, так и любого производного</span></span>
<span id="cb117-46"><a href="#cb117-46" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//типа — Dog или Cat</span></span>
<span id="cb117-47"><a href="#cb117-47" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb117-48"><a href="#cb117-48" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>Voice<span class="op">();</span> <span class="co">//так как указатель базового типа (не имеет</span></span>
<span id="cb117-49"><a href="#cb117-49" aria-hidden="true" tabindex="-1"></a>                <span class="co">//значения, какого типа объект!!!), во всех случаях</span></span>
<span id="cb117-50"><a href="#cb117-50" aria-hidden="true" tabindex="-1"></a>                <span class="co">//будет вызван метод базового класса Animal</span></span>
<span id="cb117-51"><a href="#cb117-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb117-52"><a href="#cb117-52" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F2<span class="op">(</span><span class="at">const</span> Animal<span class="op">*</span> p<span class="op">,</span> ANIMAL_TYPE type<span class="op">)</span></span>
<span id="cb117-53"><a href="#cb117-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">//глобальная функция, которая принимает в качестве параметра</span></span>
<span id="cb117-54"><a href="#cb117-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">//указатель базового типа Animal*, а сам объект, адрес которого</span></span>
<span id="cb117-55"><a href="#cb117-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">//получает функция, может быть как базового типа Animal, так и</span></span>
<span id="cb117-56"><a href="#cb117-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">//любого производного типа — Dog или Cat ⇒ так как нам нужна</span></span>
<span id="cb117-57"><a href="#cb117-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">//разная функциональность для разных производных классов, а в</span></span>
<span id="cb117-58"><a href="#cb117-58" aria-hidden="true" tabindex="-1"></a>    <span class="co">//нашем распоряжении только указатель базового типа, приходится</span></span>
<span id="cb117-59"><a href="#cb117-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">//вводить дополнительный признак: с каким именно объектом мы</span></span>
<span id="cb117-60"><a href="#cb117-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">//имеем дело</span></span>
<span id="cb117-61"><a href="#cb117-61" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb117-62"><a href="#cb117-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>type<span class="op">)</span> <span class="co">//признак — какое животное</span></span>
<span id="cb117-63"><a href="#cb117-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb117-64"><a href="#cb117-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> DOG<span class="op">:</span></span>
<span id="cb117-65"><a href="#cb117-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb117-66"><a href="#cb117-66" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> Dog<span class="op">*</span> pd <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> Dog<span class="op">*&gt;(</span>p<span class="op">);</span></span>
<span id="cb117-67"><a href="#cb117-67" aria-hidden="true" tabindex="-1"></a>            <span class="co">//так как p содержит адрес «собаки», приводим указатель</span></span>
<span id="cb117-68"><a href="#cb117-68" aria-hidden="true" tabindex="-1"></a>            <span class="co">//базового типа к Dog*</span></span>
<span id="cb117-69"><a href="#cb117-69" aria-hidden="true" tabindex="-1"></a>        pd<span class="op">-&gt;</span>Voice<span class="op">();</span><span class="co">//вызывается метол класса Dog</span></span>
<span id="cb117-70"><a href="#cb117-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb117-71"><a href="#cb117-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb117-72"><a href="#cb117-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CAT<span class="op">:</span></span>
<span id="cb117-73"><a href="#cb117-73" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb117-74"><a href="#cb117-74" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> Cat<span class="op">*</span> pc <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> Cat<span class="op">*&gt;(</span>p<span class="op">);</span></span>
<span id="cb117-75"><a href="#cb117-75" aria-hidden="true" tabindex="-1"></a>            <span class="co">//так как p содержит адрес «кошки», приводим указатель</span></span>
<span id="cb117-76"><a href="#cb117-76" aria-hidden="true" tabindex="-1"></a>            <span class="co">//базового типа к Cat*</span></span>
<span id="cb117-77"><a href="#cb117-77" aria-hidden="true" tabindex="-1"></a>        pc<span class="op">-&gt;</span>Voice<span class="op">();</span><span class="co">//вызывается метод класса Cat</span></span>
<span id="cb117-78"><a href="#cb117-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb117-79"><a href="#cb117-79" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb117-80"><a href="#cb117-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb117-81"><a href="#cb117-81" aria-hidden="true" tabindex="-1"></a>        p<span class="op">-&gt;</span>Voice<span class="op">();</span> <span class="co">//вызывается метод базового класса Animal</span></span>
<span id="cb117-82"><a href="#cb117-82" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb117-83"><a href="#cb117-83" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: следует учитывать правила, которые действуют в случае наследования при перегрузке имен функций. Метод производного класса замещает для компилятора одноименный метод базового класса:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*);</span></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>f<span class="op">(</span><span class="dv">3</span><span class="op">);</span> <span class="co">//ошибка: невозможно сконвертировать int в const char*</span></span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">//(то есть посредством объекта производного типа</span></span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">//компилятор «не видит» одноименный метод базового</span></span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">//класса)</span></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="позднее-связывание.-виртуальные-функции">1.1.11. Позднее связывание. Виртуальные функции</h4>
<p>Позднее связывание имеет смысл только для классов, связанных наследованием. Для того чтобы метод класса C++ стал полиморфным, при его объявлении нужно указать ключевое слово <code>virtual</code>. Если реализация функции отделена от объявления, то при определении ключевое слово <code>virtual</code> нe должно фигурировать, иначе компилятор выдаст ошибку. Полиморфные методы должны не только называться одинаково, но у них также должны совпадать количество и типы параметров, а также тип возвращаемого значения, а вот реализации у таких функций разные. Позднее связывание — это механизм этапа выполнения, то есть, какая из функций будет вызвана, определяется только во время выполнения программы.</p>
<p>Модифицируем предыдущий пример:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="co">//базовый класс, описывающий любое обобщенное животное</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;???&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//метод базового класса стал виртуальным</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dog <span class="op">:</span> <span class="kw">public</span> Animal</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Гав!&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">//в производном классе ключевое слово virtual не обязательно</span></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">//(если Вы его не напишите, метод не перестанет быть</span></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//виртуальным), главное, чтобы в базовом классе метод был</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//объявлен виртуальным. С точки зрения документирования</span></span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Вашего кода рекомендуется этим ключевым словом напоминать</span></span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">//программисту о том, что метод виртуальный</span></span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Cat <span class="op">:</span> <span class="kw">public</span> Animal</span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Mяу!&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>    Animal a<span class="op">;</span></span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a>    Dog d<span class="op">;</span></span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>    Cat c<span class="op">;</span></span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a>    F<span class="op">(&amp;</span>a<span class="op">);</span> <span class="co">//???</span></span>
<span id="cb119-29"><a href="#cb119-29" aria-hidden="true" tabindex="-1"></a>    F<span class="op">(&amp;</span>d<span class="op">);</span> <span class="co">//Гав!</span></span>
<span id="cb119-30"><a href="#cb119-30" aria-hidden="true" tabindex="-1"></a>    F<span class="op">(&amp;</span>c<span class="op">);</span> <span class="co">//Мяу!</span></span>
<span id="cb119-31"><a href="#cb119-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb119-32"><a href="#cb119-32" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">(</span><span class="at">const</span> Animal<span class="op">*</span> p<span class="op">)</span><span class="co">//глобальная функция, которая принимает в</span></span>
<span id="cb119-33"><a href="#cb119-33" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//качестве параметра указатель базового типа</span></span>
<span id="cb119-34"><a href="#cb119-34" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//Animal*, а сам объект, адрес которого</span></span>
<span id="cb119-35"><a href="#cb119-35" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//получает функция, может быть как базового</span></span>
<span id="cb119-36"><a href="#cb119-36" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//типа Animal, так и любого производного типа</span></span>
<span id="cb119-37"><a href="#cb119-37" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//— Dog или Cat</span></span>
<span id="cb119-38"><a href="#cb119-38" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb119-39"><a href="#cb119-39" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>Voice<span class="op">();</span><span class="co">//так как метод виртуальный, посредством указателя</span></span>
<span id="cb119-40"><a href="#cb119-40" aria-hidden="true" tabindex="-1"></a>               <span class="co">//базового типа во время выполнения будет вызываться</span></span>
<span id="cb119-41"><a href="#cb119-41" aria-hidden="true" tabindex="-1"></a>               <span class="co">//метод «целевого» класса (то есть того класса,</span></span>
<span id="cb119-42"><a href="#cb119-42" aria-hidden="true" tabindex="-1"></a>               <span class="co">//какого типа на самом деле объект)</span></span>
<span id="cb119-43"><a href="#cb119-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Замечание очевидное (на всякий случай): сигнатуры перегружаемых виртуальных функций должны быть одинаковыми! То есть функции должны иметь одинаковое количество параметров, одинаковые типы параметров и возвращаемого значения ⇒</p>
<p><code class="sourceCode cpp">Animal<span class="op">::</span>f<span class="op">()</span></code> и <code class="sourceCode cpp">Dog<span class="op">::</span>f<span class="op">(</span><span class="dt">int</span><span class="op">)</span></code> никаким полиморфизмом не связаны!!! Это просто перегрузка имен функций.</p>
</blockquote>
<h4 id="механизм-вызова-виртуальной-функции">1.1.12. Механизм вызова виртуальной функции</h4>
<p>Чудес не бывает, поэтому за короткий и удобный код. написанный программистом, кто-то должен «расплачиваться». Очевидно, что нагрузка при реализации полиморфизма ложится на компилятора. Рассмотрим, как реализован механизм «позднего связывания» в случае простого (не множественного) наследования:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VF1<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VF2<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b<span class="op">;</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VF1<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VF2<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> B</span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c<span class="op">;</span></span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VF1<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VF2<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Механизм вызова виртуальной функции:</p>
<ul>
<li><p>как только в объявлении класса появляется виртуальная функция, компилятор для данного класса (а также для каждого производного) в единственном экземпляре формирует таблицу виртуальных функций <code>vtab</code>, в которую с известным ему смещением заносит адреса всех виртуальных методов класса. Перегруженные виртуальные функции имеют одинаковые смещения в таблицах виртуальных функций для разных классов, связанных наследованием.</p></li>
<li><p>при создании каждого экземпляра такого класса компилятор расплачивается выделением дополнительной памяти. Теперь каждый экземпляр класса содержит не только поля, предназначенные для хранения данных, но и служебное поле для хранения указателя на таблицу виртуальных функций данного класса — <code>vptr</code>. Так как программист всегда явно указывает, объект какого класса он хочет создать, в самом объекте <code>vptr</code> всегда содержит адрес «своей» таблицы виртуальных функций.</p></li>
<li><p>вызов виртуальной функции посредством адреса объекта в отличие от обычного метода класса происходит поэтапно:</p>
<p>а) зная адрес объекта и местоположение в объекте <code>vptr</code> ( указателя на таблицу виртуальных функций) и смещение адреса требуемой функции в таблице vtab, компилятор вычисляет адрес виртуальной функции в таблице виртуальных функций очевидным образом: <code>vрtr[смещение]</code>.</p>
<p>б) по вычисленному адресу передает управление (таким образом осуществляет вызов виртуальной функции целевого класса во время выполнения), передавая в качестве дополнительного параметра, как и в случае обычных методов класса, адрес того объекта, для которого вызывается виртуальная функция:</p>
<p>Замечание: при вызове виртуальной функции компилятор не знает, какого типа объект (ему эта информация не нужна). Для вызова компилятору достаточно располагать следующей информацией: адрес объекта, расположение в объекте указателя <code>vptr</code> и смещение адреса требуемого метода в таблице <code>vtab</code>.</p></li>
</ul>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p><img src="media/image24.svg" /></p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    B b1<span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span></code></pre></div>
<p><img src="media/image25.svg" /></p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>    C с<span class="op">(</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">);</span></span></code></pre></div>
<p><img src="media/image26.svg" /></p>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>    GF1<span class="op">(&amp;</span>a<span class="op">);</span> <span class="co">//в функции посредством указателя базового типа будет</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>             <span class="co">//косвенно посредством таблицы виртуальных функций</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>             <span class="co">//вызван метод A::VF1(), так как объект типа A</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>    GF1<span class="op">(&amp;</span>b<span class="op">);</span> <span class="co">//в функции посредством указателя базового типа будет</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>             <span class="co">//косвенно посредством таблицы виртуальных функций</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>             <span class="co">//вызван метод B::VF1(), так как объект типа В</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>    GF1<span class="op">(&amp;</span>c<span class="op">);</span> <span class="co">//C::VF1(), так как объект типа C</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>    GF2<span class="op">(</span>a<span class="op">);</span> <span class="co">//в функции посредством ссылки базового типа будет</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">//косвенно посредством таблицы виртуальных функций</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">//вызван метод A::VF1() , так как объект типа A</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>    GF2<span class="op">(</span>b<span class="op">);</span> <span class="co">//B::VF1()</span></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a>    GF2<span class="op">(</span>c<span class="op">);</span> <span class="co">//C::VF1()</span></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a><span class="co">//но!</span></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>VF1<span class="op">();</span> <span class="co">//а при вызове виртуального метода посредством объекта</span></span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a>             <span class="co">//вызов формируется на этапе компиляции (как и для</span></span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true" tabindex="-1"></a>             <span class="co">//обычного метода класса), то есть а данном случае</span></span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true" tabindex="-1"></a>             <span class="co">//таблица виртуальных функций не задействуется,</span></span>
<span id="cb124-19"><a href="#cb124-19" aria-hidden="true" tabindex="-1"></a>             <span class="co">//косвенный вызов не генерируется. Вызывается метод</span></span>
<span id="cb124-20"><a href="#cb124-20" aria-hidden="true" tabindex="-1"></a>             <span class="co">//A::VF1()</span></span>
<span id="cb124-21"><a href="#cb124-21" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>VF1<span class="op">();</span> <span class="co">//В::VF1()</span></span>
<span id="cb124-22"><a href="#cb124-22" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>VF1<span class="op">();</span> <span class="co">//C::VF1()</span></span>
<span id="cb124-23"><a href="#cb124-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb124-24"><a href="#cb124-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> GF1<span class="op">(</span>A<span class="op">*</span> p<span class="op">)</span> <span class="co">//функция принимает указатель базового типа, а сам</span></span>
<span id="cb124-25"><a href="#cb124-25" aria-hidden="true" tabindex="-1"></a>               <span class="co">//объект может быть как базового, так и любого</span></span>
<span id="cb124-26"><a href="#cb124-26" aria-hidden="true" tabindex="-1"></a>               <span class="co">//производного типа</span></span>
<span id="cb124-27"><a href="#cb124-27" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb124-28"><a href="#cb124-28" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>VF1<span class="op">();</span><span class="co">//вызов метода генерируется «косвенно» посредством</span></span>
<span id="cb124-29"><a href="#cb124-29" aria-hidden="true" tabindex="-1"></a>             <span class="co">//таблицы виртуальных функций целевого класса</span></span>
<span id="cb124-30"><a href="#cb124-30" aria-hidden="true" tabindex="-1"></a>             <span class="co">//компилятор сгенерирует код (*p-&gt;vptr[i])(р);, где р</span></span>
<span id="cb124-31"><a href="#cb124-31" aria-hidden="true" tabindex="-1"></a>             <span class="co">//будет в методе VF1 фигурировать как this</span></span>
<span id="cb124-32"><a href="#cb124-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb124-33"><a href="#cb124-33" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> GF2<span class="op">(</span>A<span class="op">&amp;</span> r<span class="op">)</span> <span class="co">//функция принимает ссылку базового типа, а сам</span></span>
<span id="cb124-34"><a href="#cb124-34" aria-hidden="true" tabindex="-1"></a>               <span class="co">//объект может быть как базового, так и любого</span></span>
<span id="cb124-35"><a href="#cb124-35" aria-hidden="true" tabindex="-1"></a>               <span class="co">//производного типа</span></span>
<span id="cb124-36"><a href="#cb124-36" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb124-37"><a href="#cb124-37" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>VF1<span class="op">();</span><span class="co">//вызов метода генерируется «косвенно» посредством</span></span>
<span id="cb124-38"><a href="#cb124-38" aria-hidden="true" tabindex="-1"></a>            <span class="co">//таблицы виртуальных функций целевого класса</span></span>
<span id="cb124-39"><a href="#cb124-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Замечание: так как при появлении виртуальных функций компилятор отводит дополнительную память для хранения указателя <code>vptr</code>. соответственно формируются результаты оператора <code>sizeof</code>:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>A<span class="op">);</span> <span class="co">//???</span></span></code></pre></div>
</blockquote>
<blockquote>
<p>Вопрос:</p>
<ol type="1">
<li>можно ли вызывать виртуальные методы в конструкторах?</li>
<li>в деструкторах?</li>
</ol>
</blockquote>
<h4 id="виртуальные-деструкторы">1.1.13. Виртуальные деструкторы</h4>
<p>Большинство методов класса (кроме конструкторов) могут быть, а иногда и должны быть виртуальными, в том числе и деструктор (несмотря на то, что в разных классах имена этих методов разные!!!, но смысл одинаковый).</p>
<p>Например: сначала рассмотрим случай, когда деструкторы не виртуальные:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Animal<span class="op">();</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dog <span class="op">:</span> <span class="kw">public</span> Animal</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Dog<span class="op">();</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Объединим всех животных в зоопарк: это возможно сделать только</span></span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">//посредством указателей базового типа:</span></span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">*</span> zoo<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="kw">new</span> Animal<span class="op">(</span>параметры<span class="op">),</span> <span class="kw">new</span> Cat<span class="op">(...),</span></span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> Dog<span class="op">(...)</span> <span class="op">};</span></span>
<span id="cb126-17"><a href="#cb126-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Подумайте, почему нельзя определить массив</span></span>
<span id="cb126-18"><a href="#cb126-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Animal zoo[] = { Animal (...), Cat (...), Dog (...) }; ???</span></span>
<span id="cb126-19"><a href="#cb126-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-20"><a href="#cb126-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>zoo<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>Animal<span class="op">*);</span> i<span class="op">++)</span></span>
<span id="cb126-21"><a href="#cb126-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb126-22"><a href="#cb126-22" aria-hidden="true" tabindex="-1"></a>        zoo<span class="op">[</span>i<span class="op">]-&gt;</span>Voice<span class="op">();</span><span class="co">//вызов виртуального метода целевого класса</span></span>
<span id="cb126-23"><a href="#cb126-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> zoo<span class="op">[</span>i<span class="op">];</span> <span class="co">//при i=0 вызовется деструктор Animal, при</span></span>
<span id="cb126-24"><a href="#cb126-24" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//i=1 вызовется _только деструктор базового</span></span>
<span id="cb126-25"><a href="#cb126-25" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//класса_, так как указатель типа Animal* ⇒</span></span>
<span id="cb126-26"><a href="#cb126-26" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//производная часть CaL не будет корректно</span></span>
<span id="cb126-27"><a href="#cb126-27" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//освобождена при i-2 вызовется тоже _только</span></span>
<span id="cb126-28"><a href="#cb126-28" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//деструктор базового класса_, ⇒ производная</span></span>
<span id="cb126-29"><a href="#cb126-29" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//часть Dog не будет корректно освобождена</span></span>
<span id="cb126-30"><a href="#cb126-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb126-31"><a href="#cb126-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Объявляем деструкторы виртуальными:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Animal<span class="op">();</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dog <span class="op">:</span> <span class="kw">public</span> Animal</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Dog<span class="op">();</span> <span class="co">//ключевое слово virtual в производном классе</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//необязательно.</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">*</span> zoo<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="kw">new</span> Animal<span class="op">(</span>параметры<span class="op">),</span> <span class="kw">new</span> Cat<span class="op">(...),</span></span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> Dog<span class="op">(...)</span> <span class="op">};</span></span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>zoo<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>Animal<span class="op">*);</span> i<span class="op">++)</span></span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a>        zoo<span class="op">[</span>i<span class="op">]-&gt;</span>Voice<span class="op">();</span><span class="co">//вызов виртуального метода целевого класса</span></span>
<span id="cb127-19"><a href="#cb127-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> zoo<span class="op">[</span>i<span class="op">];</span> <span class="co">//при i=0 вызовется деструктор Animal, при</span></span>
<span id="cb127-20"><a href="#cb127-20" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//i=1 вызовется сначала деструктор Cat, а</span></span>
<span id="cb127-21"><a href="#cb127-21" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//потом деструктор базового класса Animal,</span></span>
<span id="cb127-22"><a href="#cb127-22" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//при i=2 вызовется сначала деструктор Dog, а</span></span>
<span id="cb127-23"><a href="#cb127-23" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//потом деструктор базового класса Animal</span></span>
<span id="cb127-24"><a href="#cb127-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb127-25"><a href="#cb127-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Замечание: объявлять деструктор вообще незачем, тем более делать его виртуальным, если он (или деструктор класса-потомка) не делает каких-нибудь существенных действий — например, освобождает динамически захваченную память.</p>
</blockquote>
<h4 id="спецификатор-разрешения-области-видимости-при-наследовании">1.1.14. Спецификатор разрешения области видимости при наследовании</h4>
<p>Если в базовом и производном от него классах объявлены переменные или методы с одинаковыми именами, то «увидеть» соответствующие <code>public</code> элементы базового класса посредством объекта производного класса или <code>protected</code> члены базового класса из методов производного можно с помощью оператора разрешения области видимости «<code>имя_класса::</code>» Например:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VF<span class="op">();</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VF<span class="op">();</span></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> p <span class="op">=</span> <span class="kw">new</span> B<span class="op">();</span></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a><span class="co">//посредством указатели (или ссылки)</span></span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>VF<span class="op">();</span> <span class="co">//генерируется косвенный вызов посредством таблицы</span></span>
<span id="cb128-18"><a href="#cb128-18" aria-hidden="true" tabindex="-1"></a>             <span class="co">//виртуальных функций — будет вызвана B::VF()</span></span>
<span id="cb128-19"><a href="#cb128-19" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>A<span class="op">::</span>VF<span class="op">();</span> <span class="co">//компилятору явно дано указание ⇒ вызов</span></span>
<span id="cb128-20"><a href="#cb128-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">//генерируется на этапе компиляции — будет вызвана</span></span>
<span id="cb128-21"><a href="#cb128-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">//A::VF()</span></span>
<span id="cb128-22"><a href="#cb128-22" aria-hidden="true" tabindex="-1"></a><span class="co">//посредством объекта</span></span>
<span id="cb128-23"><a href="#cb128-23" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span></span>
<span id="cb128-24"><a href="#cb128-24" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>A<span class="op">::</span>VF<span class="op">();</span></span>
<span id="cb128-25"><a href="#cb128-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>или внутри метода класса (это прием, который используется, например, в библиотеке классов MFC):</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> B<span class="op">::</span>VF<span class="op">()</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">::</span>VF<span class="op">();</span> <span class="co">//вызов метода базового класса для выполнения работы с</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>             <span class="co">//базовой частью объекта</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> <span class="co">//работа со своей производной частью</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: в случае виртуальных функций явное указание области видимости предписывает компилятору <em>на этапе компиляции</em> сгенерировать вызов метода <em>указанного класса</em>, тем самым, отменяя в данном конкретном случае позднее связывание.</p>
<h4 id="прием-проектирования">1.1.15. Прием проектирования</h4>
<div class="sourceCode" id="cb130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fGeneral<span class="op">()</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>        fPrivate<span class="op">();</span> <span class="co">//базовая часть работы всегда!</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>        fVirtual<span class="op">();</span> <span class="co">//а здесь посредством указателя this вызывается</span></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//метод целевого класса в зависимости от типа</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//объекта!</span></span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fPrivate<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> fVirtual<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb130-16"><a href="#cb130-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb130-17"><a href="#cb130-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb130-18"><a href="#cb130-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> fVirtual<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb130-19"><a href="#cb130-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb130-20"><a href="#cb130-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-21"><a href="#cb130-21" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pA <span class="op">=</span> <span class="kw">new</span> A<span class="op">();</span></span>
<span id="cb130-22"><a href="#cb130-22" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pB <span class="op">=</span> <span class="kw">new</span> B<span class="op">();</span></span>
<span id="cb130-23"><a href="#cb130-23" aria-hidden="true" tabindex="-1"></a>    pA<span class="op">-&gt;</span>fGeneral<span class="op">();</span> <span class="co">//A::fGeneral(), A::fVirtual</span></span>
<span id="cb130-24"><a href="#cb130-24" aria-hidden="true" tabindex="-1"></a>    pB<span class="op">-&gt;</span>fGeneral<span class="op">();</span> <span class="co">//A::fGeneral(), B::fVirtual</span></span></code></pre></div>
<h4 id="изменение-спецификатора-доступа-в-производном-классе">1.1.16. Изменение спецификатора доступа в производном классе</h4>
<p>Замечание: вряд ли стоит изменять спецификатор доступа виртуального метода в производных классах, поэтому можно рассматривать приведенный ниже пример в качестве трюка:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> F<span class="op">();</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> F<span class="op">();</span> <span class="co">//перегруженный метод находится в защищенной</span></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//секции</span></span>
<span id="cb131-11"><a href="#cb131-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb131-12"><a href="#cb131-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">(</span>A<span class="op">*</span> р<span class="op">)</span></span>
<span id="cb131-13"><a href="#cb131-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb131-14"><a href="#cb131-14" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>F<span class="op">();</span><span class="co">//если объект В, то будет вызвана private метод класса</span></span>
<span id="cb131-15"><a href="#cb131-15" aria-hidden="true" tabindex="-1"></a>           <span class="co">//В!!!</span></span>
<span id="cb131-16"><a href="#cb131-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="конструктор-копирования-и-виртуальные-функции">1.1.17. Конструктор копирования и виртуальные функции</h4>
<div class="sourceCode" id="cb132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span> <span class="co">//таблица виртуальных функций класса В</span></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>    A а <span class="op">=</span> b<span class="op">;</span> <span class="co">//а создается объект класса A, поэтому сначала</span></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>             <span class="co">//конструктор формирует A::vptr=&amp;A::vtab, а потом</span></span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>             <span class="co">//переписывает базовую часть объекта b в а посредством</span></span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>             <span class="co">//конструктора копирования класса A</span></span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="чисто-виртуальные-pure-virtual-функции-и-абстрактные-классы">1.1.18. Чисто виртуальные (pure virtual) функции и абстрактные классы</h4>
<p>Иногда при построении иерархии классов базовый класс является настолько обобщенным, что объектов такого типа просто не существует. Например, до сих пор мы создавали экземпляры класса <code>Animal</code>, но на самом деле такого «обобщенного» животного в природе нет, зато есть кошки, собаки… Такой базовый класс хранит общие для всех животных данные (пол. возраст…) и посредством методов базового класса реализуется общее для всех животных поведение. Но реализацию некоторых методов (<code>Voice</code>) можно написать только для конкретного животного, а в базовом классе вложить какой-то смысл в такой метод невозможно (что может «сказать» какое-то обобщенное животное?). Поэтому до сих пор метод базового класса <code>Voice</code> был просто заглушкой (пустое тело функции или <code>"???"</code>). Посредством использования чисто виртуальных функций программист может сообщить компилятору, что данный класс является абстракцией, поэтому реализацию такого метода компилятор должен искать в производных классах.</p>
<p>Чисто виртуальная функция объявляется в базовом классе следующим образом:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> VirtFunc<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//=0 делает функцию чисто виртуальной.Чисто виртуальный</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//метод может, но не обязан иметь тело</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Класс, содержащий хотя бы одну pure virtual-функцию, называется <strong>абстрактным</strong>. Следствия:</p>
<ul>
<li><p>компилятор не позволит создавать объекты такого класса:</p></li>
<li><p>абстрактный класс может использоваться только в качестве базового для других классов;</p></li>
<li><p>реализация чисто виртуальной функции не обязательна;</p></li>
<li><p>компилятор будет следить за тем, чтобы в производных классах такой метод был реализован;</p></li>
<li><p>можно пользоваться указателем или ссылкой базового типа (на абстрактный класс).</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Обратите внимание: не требуется определение чистой</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//виртуальной функции! (реализация может быть, но она</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//необязательна!! !)</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dog <span class="op">:</span> <span class="kw">public</span> Animal</span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Гав!&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">//реализация чисто виртуальной функции в производном классе</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Dog</span></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Cat <span class="op">:</span><span class="kw">public</span> Animal</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Voice<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Mяy!&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">//реализация чисто виртуальной функции в производном классе</span></span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Cat</span></span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">(</span><span class="at">const</span> Animal<span class="op">*</span> p<span class="op">)</span></span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb134-28"><a href="#cb134-28" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>Voice<span class="op">();</span> <span class="co">//вызов метода целевого класса</span></span>
<span id="cb134-29"><a href="#cb134-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb134-30"><a href="#cb134-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb134-31"><a href="#cb134-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb134-32"><a href="#cb134-32" aria-hidden="true" tabindex="-1"></a><span class="co">//  Animal an; //ошибка компилятора — нельзя создать экземпляр</span></span>
<span id="cb134-33"><a href="#cb134-33" aria-hidden="true" tabindex="-1"></a>               <span class="co">//абстрактного класса</span></span>
<span id="cb134-34"><a href="#cb134-34" aria-hidden="true" tabindex="-1"></a>    Dog dog<span class="op">;</span></span>
<span id="cb134-35"><a href="#cb134-35" aria-hidden="true" tabindex="-1"></a>    F<span class="op">(&amp;</span>dog<span class="op">);</span> <span class="co">//корректно — функция принимает указатель базового типа</span></span>
<span id="cb134-36"><a href="#cb134-36" aria-hidden="true" tabindex="-1"></a>             <span class="co">//⇒ компилятор неявно преобразует указатель Dog* в</span></span>
<span id="cb134-37"><a href="#cb134-37" aria-hidden="true" tabindex="-1"></a>             <span class="co">//указатель Animal*</span></span>
<span id="cb134-38"><a href="#cb134-38" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">*</span> zoo<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="kw">new</span> Dog<span class="op">,</span> <span class="kw">new</span> Cat<span class="op">,</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb134-39"><a href="#cb134-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">//корректно — массив указателей базового типа, а сами</span></span>
<span id="cb134-40"><a href="#cb134-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">//объекты производных типов</span></span>
<span id="cb134-41"><a href="#cb134-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>zoo<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>Animal<span class="op">*);</span> i<span class="op">++)</span></span>
<span id="cb134-42"><a href="#cb134-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb134-43"><a href="#cb134-43" aria-hidden="true" tabindex="-1"></a>        zoo<span class="op">[</span>i<span class="op">]-&gt;</span>Voice<span class="op">();</span> <span class="co">//вызов виртуального метода целевого класса</span></span>
<span id="cb134-44"><a href="#cb134-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Если массив больше не нужен, не забудьте освободить память</span></span>
<span id="cb134-45"><a href="#cb134-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> zoo<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb134-46"><a href="#cb134-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb134-47"><a href="#cb134-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Замечание: класс, содержащий только чисто виртуальные функции, называется классом-протоколом (задает для производных классов только интерфейс без какой-либо реализации и заставляет каждый производный класс иметь собственную реализацию заданного интерфейса).</p>
</blockquote>
<h3 id="наследование-интерфейса-и-наследование-реализации-при-открытом-наследовании">Наследование интерфейса и наследование реализации при открытом наследовании</h3>
<p>При открытом наследовании базовый класс может предоставлять производным:</p>
<ul>
<li><p><strong>реализацию</strong> — некоторую общую для всех потомков функциональность (то есть не предполагается, что в производном классе в указанное базовым классом действие можно вложить другой смысл). Например: метод базового класса void <code class="sourceCode cpp">Animal<span class="op">::</span>IncYear<span class="op">(){</span> <span class="va">m_age</span><span class="op">++;</span> <span class="op">}</span></code> не может вести себя по-другому в производных классах:</p></li>
<li><p><strong>интерфейс</strong> — только обозначение действия, так как базовый класс в этом случае «знает», что такое действие должно иметь место в производных классах, но «не знает» как такое действие реализовать в базовом.</p>
<p>Например: <code class="sourceCode cpp"><span class="kw">virtual</span> <span class="dt">void</span> Animal<span class="op">::</span>Voice<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></code></p></li>
<li><p><strong>реализацию «по умолчанию» + интерфейс</strong> (то есть производный класс может пользоваться функциональностью базового или вложить свой собственный смысл в указанное действие). Например: <code class="sourceCode cpp"><span class="kw">virtual</span> <span class="dt">void</span> Animal<span class="op">::</span>WhenDoISleep<span class="op">()</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;At night&quot;</span><span class="op">;</span> <span class="op">}</span></code> — поведение по умолчанию</p>
<p><code class="sourceCode cpp"><span class="kw">virtual</span> <span class="dt">void</span> Dog<span class="op">::</span>WhenDoISleep<span class="op">()</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;20 hours a day&quot;</span><span class="op">;</span> <span class="op">}</span></code> — производный класс может вложить новый смысл в данное действие, перегрузив виртуальный метод, или пользоваться базовой версией по умолчанию. То есть, если в производном классе не определен метод <code class="sourceCode cpp">WhenDolSleep<span class="op">()</span></code>, то животное будет спать по умолчанию по ночам.</p></li>
</ul>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Voice<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//объявление pure virtual функции эта абстракция должна быть</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">//определена в производных классах, так как каждое животное</span></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//«говорит» по-своему и нельзя придумать что- либо общее.</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> WhenDoISleep<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;At night&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//может быть переопределена в производных классах или нет,</span></span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">//тогда такие производные классы пользуются базовой версией,</span></span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">//которая делает что-то по умолчанию: Animal::WhenDoISleep()</span></span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> IncYear<span class="op">();</span></span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//не предполагает, что она будет вести себя иначе в</span></span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//производных классах</span></span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dog <span class="op">:</span> <span class="kw">public</span> Animal</span>
<span id="cb135-17"><a href="#cb135-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb135-18"><a href="#cb135-18" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb135-19"><a href="#cb135-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Voice<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Gav&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb135-20"><a href="#cb135-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> WhenDoISleep<span class="op">()</span></span>
<span id="cb135-21"><a href="#cb135-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb135-22"><a href="#cb135-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;20 hours a day&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb135-23"><a href="#cb135-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">//а можно и не переопределять, и пусть спит по умолчанию ночью</span></span>
<span id="cb135-24"><a href="#cb135-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<blockquote>
<p>Правило №4: различайте наследование интерфейса и реализации!</p>
</blockquote>
<p><img src="media/image27.svg" /></p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    Animal<span class="op">*</span> zoo<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="kw">new</span> Dog<span class="op">(),</span> <span class="kw">new</span> Cat<span class="op">()</span> <span class="op">};</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>zoo<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>zoo<span class="op">[</span><span class="dv">0</span><span class="op">]);</span> i<span class="op">++)</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>        zoo<span class="op">[</span>i<span class="op">]-&gt;</span>IncYear<span class="op">();</span> <span class="co">//вызывается метод базового класса</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>        zoo<span class="op">[</span>i<span class="op">]-&gt;</span>Voice<span class="op">();</span>   <span class="co">//вызывается метод «целевого» класса</span></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>        zoo<span class="op">[</span>i<span class="op">]-&gt;</span>WhenDoISleep<span class="op">();</span> <span class="co">//если в производном классе такой</span></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>                                <span class="co">//метод не определен, то вызывается</span></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a>                                <span class="co">//метод базового класса, иначе метод</span></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a>                                <span class="co">//«целевого» класса</span></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="механизм-наследования-интерфейса-и-реализации-посредством-таблиц-виртуальных-функций">Механизм наследования интерфейса и реализации посредством таблиц виртуальных функций</h3>
<p>Примеры формирования таблиц виртуальных функций:</p>
<ol type="1">
<li>Использование производным классом функциональности базового класса</li>
</ol>
<div class="sourceCode" id="cb137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//так как появился виртуальный метод, компилятор создаст для</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//класса A таблицу виртуальных функций и занесет в нее адрес</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//метода класса A</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+-------+</span></span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//|A::vtab|</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+=======+</span></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//|&amp;(A::f)|</span></span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+-------+</span></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> В <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">//виртуальный метод f() _не перегружен!!!_ ⇒ класс В будет</span></span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">//пользоваться базовой реализацией</span></span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-21"><a href="#cb137-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Так как в базовом классе есть виртуальный метод, для</span></span>
<span id="cb137-22"><a href="#cb137-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">//производного класса В компилятор создаст свою таблицу</span></span>
<span id="cb137-23"><a href="#cb137-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">//виртуальных функций, но так как в классе В виртуальный метод</span></span>
<span id="cb137-24"><a href="#cb137-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">//отсутствует, то в таблицу будет занесен адрес метода базового</span></span>
<span id="cb137-25"><a href="#cb137-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">//класса</span></span>
<span id="cb137-26"><a href="#cb137-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+-------+</span></span>
<span id="cb137-27"><a href="#cb137-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">//|В::vtab|</span></span>
<span id="cb137-28"><a href="#cb137-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+=======+</span></span>
<span id="cb137-29"><a href="#cb137-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">//|&amp;(A::f)|</span></span>
<span id="cb137-30"><a href="#cb137-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+-------+</span></span>
<span id="cb137-31"><a href="#cb137-31" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb137-32"><a href="#cb137-32" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> С <span class="op">:</span> <span class="kw">public</span> В</span>
<span id="cb137-33"><a href="#cb137-33" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb137-34"><a href="#cb137-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb137-35"><a href="#cb137-35" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb137-36"><a href="#cb137-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span></span>
<span id="cb137-37"><a href="#cb137-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">//виртуальный метод перегружен, поэтому в таблицу виртуальных</span></span>
<span id="cb137-38"><a href="#cb137-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">//функций компилятор занесет адрес метода класса C</span></span>
<span id="cb137-39"><a href="#cb137-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+-------+</span></span>
<span id="cb137-40"><a href="#cb137-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">//|C::vtab|</span></span>
<span id="cb137-41"><a href="#cb137-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+=======+</span></span>
<span id="cb137-42"><a href="#cb137-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">//|&amp;(C::f)|</span></span>
<span id="cb137-43"><a href="#cb137-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">//+-------+</span></span>
<span id="cb137-44"><a href="#cb137-44" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb137-45"><a href="#cb137-45" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb137-46"><a href="#cb137-46" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb137-47"><a href="#cb137-47" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pA <span class="op">=</span> <span class="kw">new</span> A<span class="op">;</span></span>
<span id="cb137-48"><a href="#cb137-48" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pB <span class="op">=</span> <span class="kw">new</span> В<span class="op">;</span></span>
<span id="cb137-49"><a href="#cb137-49" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pC <span class="op">=</span> <span class="kw">new</span> С<span class="op">;</span></span>
<span id="cb137-50"><a href="#cb137-50" aria-hidden="true" tabindex="-1"></a>    pA<span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//A::f();</span></span>
<span id="cb137-51"><a href="#cb137-51" aria-hidden="true" tabindex="-1"></a>    pB<span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//A::f();</span></span>
<span id="cb137-52"><a href="#cb137-52" aria-hidden="true" tabindex="-1"></a>    pC<span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//C::f();</span></span>
<span id="cb137-53"><a href="#cb137-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li>Более сложные случаи:</li>
</ol>
<div class="sourceCode" id="cb138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m_а<span class="op">;</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">();</span><span class="co">//метод не виртуальный, поэтому в таблицу виртуальных</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>             <span class="co">//функций адрес не заносится. Более того, если в классе</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>             <span class="co">//виртуальных методов нет, то таблицу виртуальных</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>             <span class="co">//функций компилятор для класса A создавать не будет!</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> В <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span> <span class="co">//метод объявлен как виртуальный, поэтому</span></span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//компилятор создает таблицу виртуальных</span></span>
<span id="cb138-18"><a href="#cb138-18" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//функций и заносит в нее адрес метода класса В</span></span>
<span id="cb138-19"><a href="#cb138-19" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//+-------+</span></span>
<span id="cb138-20"><a href="#cb138-20" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//|В::vtab|</span></span>
<span id="cb138-21"><a href="#cb138-21" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//+=======+</span></span>
<span id="cb138-22"><a href="#cb138-22" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//|&amp;(В::f)|</span></span>
<span id="cb138-23"><a href="#cb138-23" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//+-------+</span></span>
<span id="cb138-24"><a href="#cb138-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb138-25"><a href="#cb138-25" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> С <span class="op">:</span> <span class="kw">public</span> В</span>
<span id="cb138-26"><a href="#cb138-26" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb138-27"><a href="#cb138-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_c</span><span class="op">;</span></span>
<span id="cb138-28"><a href="#cb138-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb138-29"><a href="#cb138-29" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb138-30"><a href="#cb138-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span> <span class="co">//виртуальный метод перегружен (ключевое слово</span></span>
<span id="cb138-31"><a href="#cb138-31" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//virtual необязательно), поэтому в таблицу</span></span>
<span id="cb138-32"><a href="#cb138-32" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//виртуальных функций компилятор занесет адрес</span></span>
<span id="cb138-33"><a href="#cb138-33" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//метода класса С</span></span>
<span id="cb138-34"><a href="#cb138-34" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//+-------+</span></span>
<span id="cb138-35"><a href="#cb138-35" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//|C::vtab|</span></span>
<span id="cb138-36"><a href="#cb138-36" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//+=======+</span></span>
<span id="cb138-37"><a href="#cb138-37" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//|&amp;(C::f)|</span></span>
<span id="cb138-38"><a href="#cb138-38" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//+-------+</span></span>
<span id="cb138-39"><a href="#cb138-39" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb138-40"><a href="#cb138-40" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb138-41"><a href="#cb138-41" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb138-42"><a href="#cb138-42" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pA <span class="op">=</span> <span class="kw">new</span> A<span class="op">;</span></span></code></pre></div>
<p><img src="media/image28.svg" /></p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>    pA<span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//так как в классе A нет виртуальных функций,</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>             <span class="co">//компилятор генерирует обычный вызов не виртуального</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>             <span class="co">//метода A::f() (таблиц виртуальных функций не</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>             <span class="co">//используется, так как для класса A компилятор ее не</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>             <span class="co">//создает !!!)</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>    В<span class="op">*</span> рВ<span class="dv">1</span> <span class="op">=</span> <span class="kw">new</span> В<span class="op">;</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> рA1 <span class="op">=</span> рВ<span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p><img src="media/image29.svg" /></p>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>    рA1<span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//обычный вызов не виртуального метода A::f()</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>    рВ<span class="dv">1</span><span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//косвенный вызов B::f() посредством таблицы</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>              <span class="co">//виртуальных функций</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>    С<span class="op">*</span> рС <span class="op">=</span> <span class="kw">new</span> С<span class="op">;</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> рA2 <span class="op">=</span> рС<span class="op">;</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>    В<span class="op">*</span> рВ<span class="dv">2</span> <span class="op">=</span> рС<span class="op">;</span></span></code></pre></div>
<p><img src="media/image30.svg" /></p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>    рA2<span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//обычный вызов не виртуального метола A::f()</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    рВ<span class="dv">2</span><span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//косвенный вызов С::f() посредством таблицы</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>              <span class="co">//виртуальных функций</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    рС<span class="op">-&gt;</span>f<span class="op">();</span> <span class="co">//косвенный вызов С::f() посредством таблицы</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>             <span class="co">//виртуальных функций</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="тема-iii.-понятие-friend">Тема III. Понятие <code>friend</code></h1>
<h2 id="friend-привилегированные-функции-и-классы"><code>friend</code> (привилегированные) функции и классы</h2>
<p>Одним из достоинств классов считается «сокрытие» данных, но, общеизвестно, что как только возникает какое-либо правило, так сразу же возникает и необходимость в исключениях из этого правила. Поэтому, как только появились спецификаторы доступа private и protected, так сразу же возникла необходимость иметь средство непосредственного доступа к таким элементам класса, которое и было реализовано посредством <code>friend</code>-функций или классов.</p>
<p><em>Замечание:</em> существует мнение (и я с ним полностью согласна), что введение понятия <code>friend</code> — это в большинстве случаев предоставление программисту средства исправить плохо продуманную иерархию классов, и, если возникает необходимость в таких функциях или классах, то зачастую это признак того, что иерархия классов нуждается в исправлении. Но! В некоторых случаях, а именно когда речь идет:</p>
<ul>
<li><p>о перегруженных глобальными функциями операторах</p></li>
<li><p>или о вспомогательных классах</p></li>
</ul>
<p>ключевое слово <code>friend</code> оказывается очень даже полезным.</p>
<h3 id="внешняя-глобальная-friend-функция">Внешняя (глобальная) <code>friend</code>-функция</h3>
<p>Внешняя <code>friend</code>-функция это обычная глобальная функция, которой просто предоставлены специальные привилегии доступа к защищенным элементам того класса, в котором она объявлена как <code>friend</code>.</p>
<p>Пример (в приведенном примере с точки зрения проектирования корректнее было бы пользоваться <code>public</code> методами для получения защищенных данных):</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_left</span><span class="op">,</span> <span class="va">m_top</span><span class="op">,</span> <span class="va">m_right</span><span class="op">,</span> <span class="va">m_bottom</span><span class="op">;</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a>Rect BoundingRect<span class="op">(</span><span class="at">const</span> Rect<span class="op">&amp;</span> r1<span class="op">,</span> <span class="at">const</span> Rect<span class="op">&amp;</span> r2<span class="op">)</span></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//это не метод класса, а обычная глобальная функция ⇒ любая</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">//попытка обращения к защищенным членам класса Rect вызывает </span></span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">//ошибку компилятора</span></span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l <span class="op">=</span> <span class="op">(</span>r1<span class="op">.</span><span class="va">m_left</span> <span class="op">&lt;</span> r2<span class="op">.</span><span class="va">m_left</span><span class="op">)</span> <span class="op">?</span> r1<span class="op">.</span><span class="va">m_left</span> <span class="op">:</span> r2<span class="op">.</span><span class="va">m_left</span><span class="op">;</span></span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">//ошибка — нарушение прав доступа</span></span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb142-14"><a href="#cb142-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Для того, чтобы в глобальной функции Вы могли обращаться к защищенным переменным класса, эта функция должна быть объявлена в классе с ключевым словом <code>friend</code>:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> Rect BoundingRect<span class="op">(</span><span class="at">const</span> Rect<span class="op">&amp;,</span> <span class="at">const</span> Rect<span class="op">&amp;);</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//объявление глобальной friend-функции</span></span></code></pre></div>
<blockquote>
<p>Замечание: не имеет значения, в какой секции (<code>private</code>, <code>protected</code> или <code>public</code>) объявлена <code>friend</code> функция, так как она не является членом класса.</p>
</blockquote>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>Rect BoundingRect<span class="op">(</span><span class="at">const</span> Rect<span class="op">&amp;</span> r1<span class="op">,</span> <span class="at">const</span> Rect<span class="op">&amp;</span> r2<span class="op">)</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//так как эта глобальная функция «стала другом» класса Rect, в</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">//теле этой функции компилятор позволит обращаться к защищенным </span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">//членам этого класса</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l <span class="op">=</span> <span class="op">(</span>rl<span class="op">.</span><span class="va">m_left</span> <span class="op">&lt;</span> r2<span class="op">.</span><span class="va">m_left</span><span class="op">)</span> <span class="op">?</span> rl<span class="op">.</span><span class="va">m_left</span> <span class="op">:</span> r2<span class="op">.</span><span class="va">m_left</span><span class="op">;</span> <span class="co">//ОК</span></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Замечание: для всех остальных функций правила доступа остаются прежними, то есть компилятор выдаст ошибку при попытке обращения к защищенному члену класса.</p>
</blockquote>
<div class="sourceCode" id="cb145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>    Rect r <span class="op">=</span> BoundingRect<span class="op">(</span>Rect<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">),</span> Rect<span class="op">(</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">));</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a><span class="co">//  r.l = 1; //ошибка доступа</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 1: дружба с функцией автоматически не передается по наследству</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">;</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="dt">void</span> F<span class="op">(</span>B<span class="op">&amp;</span> b<span class="op">);</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">(</span>B<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> b<span class="op">.</span><span class="va">m_a</span><span class="op">;</span> <span class="co">//OK, так как функция является другом</span></span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//класса А</span></span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true" tabindex="-1"></a><span class="co">//std::cout &lt;&lt; b.m_b; //ошибка — нет доступа к В::m_b. Для того,</span></span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//чтобы иметь доступ к защищенным переменным </span></span>
<span id="cb146-17"><a href="#cb146-17" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//производного класса, функция должна быть </span></span>
<span id="cb146-18"><a href="#cb146-18" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//другом этого производного класса</span></span>
<span id="cb146-19"><a href="#cb146-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 2: с другой стороны, дружественная производному классу функция имеет право обращаться к <code>protected</code> (не <code>private</code>!) членам базового класса:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a1</span><span class="op">;</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a2</span><span class="op">;</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="dt">void</span> F<span class="op">(</span>B<span class="op">&amp;</span> b<span class="op">);</span></span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">(</span>B<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a><span class="co">//  std::cout&lt;&lt;b.m_al; //ошибка — нет доступа</span></span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> b<span class="op">.</span><span class="va">m_a2</span><span class="op">;</span> <span class="co">//OK</span></span>
<span id="cb147-16"><a href="#cb147-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> b<span class="op">.</span><span class="va">m_b</span><span class="op">;</span> <span class="co">//OK</span></span>
<span id="cb147-17"><a href="#cb147-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="friend-класс"><code>friend</code>-класс</h3>
<p>Можно сделать все методы одного класса «Дружественными» другому классу, то есть позволить компилятору в любом методе <code>friend</code>-класса обращаться к защищенным членам данного класса, например:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Circle.h</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circle</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">,</span> r<span class="op">;</span></span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a>    Circle<span class="op">(</span><span class="at">const</span> Rect<span class="op">&amp;</span> r<span class="op">);</span> <span class="co">//объявление конструктора, который</span></span>
<span id="cb148-7"><a href="#cb148-7" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//«вписывает» создаваемый кружок в </span></span>
<span id="cb148-8"><a href="#cb148-8" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//заданный в качестве параметра </span></span>
<span id="cb148-9"><a href="#cb148-9" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//прямоугольник</span></span>
<span id="cb148-10"><a href="#cb148-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb148-11"><a href="#cb148-11" aria-hidden="true" tabindex="-1"></a><span class="co">//Circle.срр</span></span>
<span id="cb148-12"><a href="#cb148-12" aria-hidden="true" tabindex="-1"></a>Circle<span class="op">::</span>Circle<span class="op">(</span><span class="at">const</span> Rect<span class="op">&amp;</span> r<span class="op">)</span><span class="co">//реализация конструктора</span></span>
<span id="cb148-13"><a href="#cb148-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb148-14"><a href="#cb148-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> w <span class="op">=</span> r<span class="op">.</span><span class="va">m_right</span> <span class="op">-</span> r<span class="op">.</span><span class="va">m_left</span><span class="op">;</span> <span class="co">//ошибка доступа</span></span>
<span id="cb148-15"><a href="#cb148-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> h <span class="op">=</span> r<span class="op">.</span><span class="va">m_bottom</span> <span class="op">-</span> r<span class="op">.</span><span class="va">m_top</span><span class="op">;</span> <span class="co">//ошибка доступа</span></span>
<span id="cb148-16"><a href="#cb148-16" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> r<span class="op">.</span><span class="va">m_left</span> <span class="op">+</span> w <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb148-17"><a href="#cb148-17" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> r<span class="op">.</span><span class="va">m_top</span> <span class="op">+</span> h <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb148-18"><a href="#cb148-18" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="op">(</span>w <span class="op">&gt;</span> h<span class="op">)</span> <span class="op">?</span> h <span class="op">/</span> <span class="dv">2</span> <span class="op">:</span> w <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb148-19"><a href="#cb148-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Объявим класс <code>Circle</code> другом класса <code>Rect</code>:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="kw">class</span> Circle<span class="op">;</span> <span class="co">//все методы класса Circle имеют право</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//обращаться к защищенным членам класса Rect</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a><span class="co">//Circle.срр</span></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>Circle<span class="op">::</span>Circle<span class="op">(</span><span class="at">const</span> Rect<span class="op">&amp;</span> r<span class="op">)</span><span class="co">//теперь методы класса Circle имеют</span></span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//право обращаться к защищенным членам </span></span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//класса Rect</span></span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> w <span class="op">=</span> r<span class="op">.</span><span class="va">m_right</span> <span class="op">-</span> r<span class="op">.</span><span class="va">m_left</span><span class="op">;</span> <span class="co">//ОК</span></span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> h <span class="op">=</span> r<span class="op">.</span><span class="va">m_bottom</span> <span class="op">-</span> r<span class="op">.</span><span class="va">m_Lop</span><span class="op">;</span> <span class="co">//ОК</span></span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb149-14"><a href="#cb149-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: «дружба» классов:</p>
<ol type="1">
<li><p>не наследуется</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Z <span class="op">{</span> <span class="kw">friend</span> <span class="kw">class</span> X<span class="op">;</span> <span class="op">};</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Y <span class="op">:</span> <span class="kw">public</span> X <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span></code></pre></div>
<p>Методы производного класса <code>Y</code> не имеют права обращаться к защищенным членам класса <code>Z</code></p>
<div class="sourceCode" id="cb151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Z <span class="op">{</span> <span class="dt">int</span> <span class="va">m_z</span><span class="op">;</span> <span class="kw">friend</span> <span class="kw">class</span> X<span class="op">;</span> <span class="op">};</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X</span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fX<span class="op">(</span>Z<span class="op">&amp;</span> z<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> z<span class="op">.</span><span class="va">m_z</span><span class="op">;</span> <span class="op">}</span> <span class="co">//OK</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Y <span class="op">:</span> <span class="kw">public</span> X</span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fY<span class="op">(</span>Z<span class="op">&amp;</span> z<span class="op">)</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">//std::cout&lt;&lt;z.m_z; //ошибка доступа</span></span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>не является транзитивной (если класс <code>X</code> объявлен <code>friend</code>-классом в классе <code>Y</code>, а класс <code>Z</code> объявлен <code>friend</code>-классом в классе <code>X</code>, то класс <code>Z</code> не является <code>friend</code>-классом <code>X</code>).</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X <span class="op">{</span> <span class="kw">friend</span> <span class="kw">class</span> Y<span class="op">;</span> <span class="op">};</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Y <span class="op">{</span> <span class="kw">friend</span> <span class="kw">class</span> Z<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<p>Методы класса <code>Z</code> не имеют права обращаться к защищенным членам класса <code>X</code>.</p></li>
</ol>
<h3 id="friend-метод-другого-класса">friend-метод другого класса</h3>
<p>Можно дать права не всем, а выборочно некоторым методам другого класса обращаться к защищенным переменным данного класса, например:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> Circle<span class="op">::</span>Circle<span class="op">(</span><span class="at">const</span> Rect<span class="op">&amp;);</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//только данный метод класса Circle имеет право обращаться к</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//защищенным членам класса Rect -&gt; в любом другом методе при </span></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">//аналогичной попытке компилятор выдаст ошибку</span></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h1 id="тема-iv.-перегрузка-операторов">Тема IV. Перегрузка операторов</h1>
<p>Предоставление возможности обращаться с объектами пользовательского типа также как с переменными базового типа.</p>
<h2 id="перегрузка-операторов-для-базовых-и-пользовательских-типов">Перегрузка операторов для базовых и пользовательских типов</h2>
<p>Компилятор генерирует разные низкоуровневые инструкции, встречая одно и то же действие, но над разными типами.</p>
<p>Для базовых типов также существует перегрузка операторов, которую осуществляет компилятор самостоятельно (<em>встроенные операторы</em>):</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">,</span> z<span class="op">;</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span> <span class="co">//add</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x<span class="op">,</span> y<span class="op">,</span> z<span class="op">;</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span> <span class="co">//fadd</span></span></code></pre></div>
<p>Язык C++ допускает перегрузку операторов (overloading), то есть способность переопределения привычных операторов типа <code>+</code>, <code>*</code>, <code>&gt;</code>, <code>&lt;</code>, <code>=</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>[]</code>, <code>()</code>, … но только для Ваших пользовательских типов данных (полный список операторов, которые можно перегружать, приведен в <strong>MSDN Library — «Redefinable Operators»</strong>. Там же перечислены операторы, которые перегружать нельзя).</p>
<p>Но. в отличие от базовых типов, компилятор «не знает» как интерпретировать следующую запись и выдаст ошибку: «в классе не определен оператор <code>+</code>»</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>    Point pt1<span class="op">,</span> pt2<span class="op">,</span> pt3<span class="op">;</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>    pt3 <span class="op">=</span> pt1 <span class="op">+</span> pt2<span class="op">;</span> <span class="co">//ошибка</span></span></code></pre></div>
<p>Только Вы можете определить, каким образом следует поступать компилятору, когда он встречает в тексте программы оператор, который должен воздействовать на Ваш тип. Целью перегрузки операторов является простота и интуитивная интерпретация операторов.</p>
<h2 id="специфика-перегружаемых-операторов">Специфика перегружаемых операторов</h2>
<p>Перегрузка операторов — один из видов перегрузки имен функций. Просто у такой функции несколько необычное имя. Если Вы перегружаете оператор ♥, то должны создать в Вашем классе функцию с именем <code>operator♥</code>, которую компилятор будет вызывать всякий раз, когда по отношению к объекту данного класса применяется указанный оператор ♥</p>
<p>Но так как функция эта все же специфичная, вводятся некоторые дополнительные правила:</p>
<ul>
<li><p>нельзя создавать собственные операторы, а можно только перегружать существующие (и то не все):</p></li>
<li><p>перегруженный оператор действует только по отношению к объектам того класса, для которого он переопределен (например, <code>operator+</code> класса <code>A</code> не имеет никакого отношения к <code>operator+</code> класса <code>B</code>);</p></li>
<li><p>нельзя менять число операндов оператора (например, нельзя перегрузить оператор <code>*</code> (умножения) таким образом, чтобы в нем использовался один операнд); <!-- На самом деле можно определить T operator*() --></p></li>
<li><p>перегруженные операторы наследуют приоритеты и ассоциативность от встроенных операторов;</p></li>
<li><p>оператор перегружается только относительно пользовательского типа данных (обычно класса) ⇒ нельзя перегружать встроенные операторы (например, оператор целочисленного сложения). Чтобы обеспечить выполнение этого условия, компилятор требует, чтобы хотя бы один аргумент каждого перегруженного оператора относился к пользовательскому типу;</p></li>
<li><p>нельзя перегружать операторы <code>.</code> <code>::</code> <code>.*</code> <code>?:</code></p></li>
<li><p>нет правил, которые предписывали бы сохранение смысла оператора, но по возможности рекомендуется это делать (никто не запрещает вложить в реализацию оператор сложения смысл оператора вычитания, но вряд ли это улучшит «читабельность» Вашего кода):</p></li>
<li><p>как и любая другая функция, перегруженный оператор может иметь сколько угодно реализаций, «различимых» по типу параметров компилятором;</p></li>
<li><p>оператор, перегруженный с помощью метода класса, может быть виртуальным и даже чисто виртуальным;</p></li>
<li><p>оператор, перегруженный с помощью метода класса, не может быть статическим:</p></li>
<li><p>не существует ограничений на тип возвращаемого значения, но следует учитывать «преемственность» использования перегружаемого оператора применительно к базовым типам и эффективность реализации.</p></li>
</ul>
<h2 id="способы-перегрузки-операторов">Способы перегрузки операторов</h2>
<p>Для того, чтобы перегрузить оператор ♥, необходимо объявить и определить функцию с именем <code>operator♥</code>. Эта функция может быть глобальной или методом класса (но не обоими вариантами сразу).</p>
<p>Все переопределяемые операторы делятся на унарные (действие производится над одним объектом) и бинарные (действие производится над двумя объектами). Тернарный оператор перегружать запрещено.</p>
<p><img src="media/image31.svg" /></p>
<p>Пример:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> А<span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>A x<span class="op">,</span> y<span class="op">,</span> z<span class="op">;</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> х <span class="op">+</span> у<span class="op">;</span> <span class="co">//нормальная синтаксическая форма записи. Компилятор</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>           <span class="co">//сгенерирует или вызов public метода operator+ класса А,</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>           <span class="co">//или вызов глобальной функции (в зависимости от</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>           <span class="co">//реализации)</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="kw">operator</span><span class="op">+(</span>х<span class="op">,</span> у<span class="op">);</span> <span class="co">//функциональная форма вызова глобальной функции</span></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> x<span class="op">.</span><span class="kw">operator</span><span class="op">+(</span>у<span class="op">);</span> <span class="co">//функциональная форма вызова метода класса</span></span></code></pre></div>
<p><strong>Рекомендация</strong>: если оператор может быть перегружен как глобальной функцией, так и методом класса — предпочитайте перегрузку в форме метода класса!</p>
<p><strong>Исключения</strong> (когда перегрузка методом класса невозможна):</p>
<ul>
<li><p>первый операнд относится к базовому типу, например <code class="sourceCode cpp">z <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> x</code>;</p></li>
<li><p>тип первого операнда библиотечный</p></li>
</ul>
<p>В таких ситуациях перегрузка возможна только посредством глобальных функций.</p>
<h2 id="порядок-поиска-компилятором-перегруженного-оператора">Порядок поиска компилятором перегруженного оператора</h2>
<p>Если компилятор встречает оператор, он должен решить, как его компилировать. Например, для бинарного оператора:</p>
<ul>
<li><p>если оба аргумента относятся к базовым типам, используется встроенный оператор:</p></li>
<li><p>если слева — операнд пользовательского типа, компилятор ищет оператор в форме метода класса. Если находит, генерирует вызов метода класса:</p></li>
<li><p>если перегрузки в форме метода не найдено или слева операнд базового типа, компилятор ищет перегрузку в форме глобальной функции Если такая форма существует, использует ее при компиляции:</p></li>
<li><p>если все перечисленные варианты испробованы, а перегрузки не найдено, выдает ошибку.</p></li>
</ul>
<p>Замечание: если оператор перегружен и методом, и глобальной функцией, то при нормальной форме вызова компилятор не может различить какую именно форму перегрузки требуется вызвать. В такой ситуации некоторые компиляторы:</p>
<p>а) выдают ошибку двойственность ⇒ ошибка компилятора</p>
<p>б) другие компиляторы могут предпочесть метод ⇒ глобальная функция будет проигнорирована.</p>
<h2 id="перегрузка-операторов-методом-класса">Перегрузка операторов методом класса</h2>
<blockquote>
<p><em>Замечание:</em> операторы <code>=</code>, <code>()</code>, <code>[]</code>, <code>-&gt;</code> могут быть перегружены только с помощью метода класса.</p>
</blockquote>
<h3 id="operator-memberwise-assignment"><code>operator=</code> (memberwise assignment)</h3>
<p>В качестве примера рассмотрим перегрузку оператора «<code>=</code>» (присваивания). Оператор присваивания — наиболее часто встречаемый оператор класса. Он настолько тесно связан с понятием класса (так же, как конструктор копирования), что если Вы явно не реализуете такой оператор в классе, то компилятор сгенерирует автоматический оператор присваивания сам. Такой автоматический оператор присваивания «умеет»:</p>
<ul>
<li><p>поэлементно копировать данные базового типа из одного объекта в другой;</p></li>
<li><p>вызывать оператор присваивания базового класса (явно определенный программистом или автоматический)</p></li>
<li><p>вызывать оператор присваивания для встроенных объектов.</p></li>
</ul>
<p>Компилятор не может сгенерировать автоматический оператор присваивания в следующих случаях:</p>
<ul>
<li><p>в классе объявлен константный объект;</p></li>
<li><p>в классе объявлена ссылка:</p></li>
<li><p>в базовом классе оператор присваивания объявлен private;</p></li>
<li><p>во встроенном объекте оператор присваивания объявлен private.</p></li>
</ul>
<blockquote>
<p>Следствие: для сложных классов пишите свои операторы присваивания.</p>
</blockquote>
<p>Замечание: оператор присваивания не наследуется! Это означает: если в производном классе оператор присваивания явно программистом не определен, то компилятор генерирует автоматический оператор присваивания, а не использует метод базового класса.</p>
<p>Замечание: оператор присваивания (также называемый оператором копирующего присваивания — memberwise assignment) очень похож на конструктор копирования, но существует принципиальная разница:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>Point pt1<span class="op">,</span> pt2<span class="op">;</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>Point pt3 <span class="op">=</span> pt1<span class="op">;</span> <span class="co">//объявление с инициализацией создается новый</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//объект *вызывается конструктор копирования*</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>pt2 <span class="op">=</span> pt1<span class="op">;</span> <span class="co">//одному существующему объекту присваивается значение</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>           <span class="co">//другого существующего объекта *вызывается оператор</span></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>           <span class="co">//присваивания*</span></span></code></pre></div>
<p>В качестве примера перегрузим оператор присваивания для класса Point, хотя для такого простого класса компилятор прекрасно бы сгенерировал автоматический оператор присваивания (и, возможно, эффективнее, чем сделаем это мы):</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>    Point pt1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">),</span> pt2<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>    pt2 <span class="op">=</span> pt1<span class="op">;</span> <span class="co">//нормальная форма вызова. Если в классе Point не</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>               <span class="co">//перегружен оператор присваивания, то компилятор</span></span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a>               <span class="co">//вызовет автоматический (при этом содержимое pt1</span></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>               <span class="co">//копируется в pt2, затирая прежние значения pt2), а</span></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a>               <span class="co">//если Вы перегрузили оператор присваивания, то</span></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a>               <span class="co">//компилятор вызовет Ваш метод класса и будут выполнены</span></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a>               <span class="co">//действия, предусмотренные программистом</span></span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>    pt2<span class="op">.</span><span class="kw">operator</span><span class="op">=(</span>pt1<span class="op">);</span> <span class="co">//функциональная форма вызова</span></span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Замечание: для компилятора обе формы эквивалентны. Программисту привычнее писать выражения в нормальной форме, но в большинстве случаев для того, чтобы понять, какого типа параметры должна принимать перегруженная функция и каков тип возвращаемого значения, стоит написать функциональную форму вызова.</p>
</blockquote>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_x</span><span class="op">,</span> <span class="va">m_y</span><span class="op">;</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span> <span class="va">m_x</span> <span class="op">=</span> x<span class="op">;</span> <span class="va">m_y</span> <span class="op">=</span> y<span class="op">;</span> <span class="op">}</span></span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> refPt<span class="op">);</span></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//объявление оператора присваивания.Ключевое слово const</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//необязательно, но говорит о хорошем стиле</span></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//программирования.В этом случае компилятор не позволит</span></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//модифицировать параметр(то есть значение справа от знака</span></span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//равенства)</span></span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a><span class="co">//Реализация оператора присваивания</span></span>
<span id="cb159-14"><a href="#cb159-14" aria-hidden="true" tabindex="-1"></a>Point<span class="op">&amp;</span> Point<span class="op">::</span><span class="kw">operator</span><span class="op">=</span> <span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> refPt<span class="op">)</span></span>
<span id="cb159-15"><a href="#cb159-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb159-16"><a href="#cb159-16" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_x</span> <span class="op">=</span> refPt<span class="op">.</span><span class="va">m_x</span><span class="op">;</span></span>
<span id="cb159-17"><a href="#cb159-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_y</span> <span class="op">=</span> refPt<span class="op">.</span><span class="va">m_y</span><span class="op">;</span></span>
<span id="cb159-18"><a href="#cb159-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb159-19"><a href="#cb159-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="тип-возвращаемого-оператором-присваивания-значения">1.1.19. Тип возвращаемого оператором присваивания значения</h4>
<p>Нет ограничений на тип возвращаемого любым перегруженным оператором значения, поэтому, пожалуй, в большинстве случаев следует учитывать следующие соображения:</p>
<ul>
<li><p>использование перегруженного оператора ничем не должно отличаться от использования этого оператора для базовых типов;</p></li>
<li><p>предпочитать эффективный вариант.</p></li>
</ul>
<p>Рассмотрим три варианта:</p>
<ol type="1">
<li></li>
</ol>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> refPt<span class="op">)</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_x</span> <span class="op">=</span> refPt<span class="op">.</span><span class="va">m_x</span><span class="op">;</span> <span class="va">m_y</span> <span class="op">=</span> refPt<span class="op">.</span><span class="va">m_y</span><span class="op">;</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a>    Point pt1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">),</span> pt2<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">),</span> pt3<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a>    pt2 <span class="op">=</span> pt1<span class="op">;</span> <span class="co">//в данном примере возвращаемое значение не</span></span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a>               <span class="co">//требуется, так как в результате вызова метода будет</span></span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true" tabindex="-1"></a>               <span class="co">//требуемым образом модифицирован объект слева от</span></span>
<span id="cb160-15"><a href="#cb160-15" aria-hidden="true" tabindex="-1"></a>               <span class="co">//знака равенства</span></span>
<span id="cb160-16"><a href="#cb160-16" aria-hidden="true" tabindex="-1"></a>    pt3 <span class="op">=</span> pt2 <span class="op">=</span> pt1<span class="op">;</span> <span class="co">//а в этом случае компилятор выдаст ошибку,</span></span>
<span id="cb160-17"><a href="#cb160-17" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//которая станет очевидна, если написать такое</span></span>
<span id="cb160-18"><a href="#cb160-18" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//цепочечное присваивание в функциональной</span></span>
<span id="cb160-19"><a href="#cb160-19" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//форме:</span></span>
<span id="cb160-20"><a href="#cb160-20" aria-hidden="true" tabindex="-1"></a>    pt3<span class="op">.</span><span class="kw">operator</span><span class="op">=(</span>pt2<span class="op">.</span><span class="kw">operator</span><span class="op">=(</span>pt1<span class="op">));</span></span>
<span id="cb160-21"><a href="#cb160-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">//скобки не обязательны и расставлены только для того, чтобы</span></span>
<span id="cb160-22"><a href="#cb160-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">//подчеркнуть право ассоциативность оператора присваивания.</span></span>
<span id="cb160-23"><a href="#cb160-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Проблема заключается в том, что аргументом для вызова</span></span>
<span id="cb160-24"><a href="#cb160-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">//pt3.operator= является значение, возвращаемое</span></span>
<span id="cb160-25"><a href="#cb160-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">//pt2.operator=, а в данном варианте реализации наш</span></span>
<span id="cb160-26"><a href="#cb160-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">//перегруженный оператор ничего не возвращает!</span></span>
<span id="cb160-27"><a href="#cb160-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li>Для обеспечения цепочечного присваивания <code>operator=</code> должен возвращать уже модифицированное значение левого операнда, например:</li>
</ol>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>    Point <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> refPt<span class="op">)</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_x</span> <span class="op">=</span> refPt<span class="op">.</span><span class="va">m_x</span><span class="op">;</span> <span class="va">m_y</span> <span class="op">=</span> refPt<span class="op">.</span><span class="va">m_y</span><span class="op">;</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span> <span class="co">//при возвращении по значению для формирования</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//возвращаемого значения компилятор создает</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//копию того объекта, для которого был вызван</span></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//метод посредством конструктора копирования</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//-&gt; дополнительная память для возвращаемого</span></span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//значения и дополнительное время на</span></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//выполнение конструктора копирования</span></span>
<span id="cb161-14"><a href="#cb161-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb161-15"><a href="#cb161-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb161-16"><a href="#cb161-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb161-17"><a href="#cb161-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb161-18"><a href="#cb161-18" aria-hidden="true" tabindex="-1"></a>    Point pt1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">),</span> pt2<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">),</span> pt3<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb161-19"><a href="#cb161-19" aria-hidden="true" tabindex="-1"></a>    pt3 <span class="op">=</span> pt2 <span class="op">=</span> pt1<span class="op">;</span> <span class="co">//теперь цепочечное присваивание выполняется</span></span>
<span id="cb161-20"><a href="#cb161-20" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//корректно, но не Эффективно</span></span>
<span id="cb161-21"><a href="#cb161-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="3" type="1">
<li>Эффективнее не заставлять компилятор делать копию того объекта, для которого вызывается <code>operator=</code> а просто вернуть адрес этого объекта. Если возвращать адрес посредством указателя, цепочечное присваивание имело бы довольно непривычную форму, поэтому адрес логичнее возвращать по ссылке.</li>
</ol>
<p>Замечание: мы имеем право возвращать адрес, так как сам объект гарантированно существует в вызывающей функции</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> refPt<span class="op">)</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_x</span> <span class="op">=</span> refPt<span class="op">.</span><span class="va">m_x</span><span class="op">;</span> <span class="va">m_y</span> <span class="op">=</span> refPt<span class="op">.</span><span class="va">m_y</span><span class="op">;</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">//в качестве возвращаемого значения компилятор формирует адрес</span></span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">//объекта слева от знака равенства (адрес того объекта, для</span></span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">//которого вызывается метод)</span></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a>    Point pt1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">),</span> pt2<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">),</span> pt3<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a>    pt3 <span class="op">=</span> pt2 <span class="op">=</span> pt1<span class="op">;</span> <span class="co">//теперь цепочечное присваивание выполняется</span></span>
<span id="cb162-14"><a href="#cb162-14" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//корректно и эффективно</span></span>
<span id="cb162-15"><a href="#cb162-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="оператор-присваивания-и-нетривиальные-классы">1.1.20. Оператор присваивания и нетривиальные классы</h4>
<p>Для простых классов (таких как класс <code>Point</code>) не стоит явно реализовывать оператор присваивания, так как для них прекрасно подходит оператор присваивания, который автоматически умеет генерировать компилятор. Но для чуть более сложных классов (таких как <code>Animal</code>) программист обязан реализовать корректный оператор присваивания, так как использование автоматического приведет к ошибкам времени исполнения:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>    Animal an1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> MALE<span class="op">,</span> <span class="kw">false</span><span class="op">,</span> <span class="st">&quot;Bobik&quot;</span><span class="op">),</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>           an2<span class="op">(</span><span class="dv">5</span><span class="op">,</span> MALE<span class="op">,</span> <span class="kw">true</span><span class="op">,</span> <span class="st">&quot;Lord&quot;</span><span class="op">);</span> <span class="co">//создание локальных объектов</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>    an2 <span class="op">=</span> an1<span class="op">;</span> <span class="co">//вызов автоматического оператора присваивания</span></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">//вызов деструкторов локальных объектов</span></span></code></pre></div>
<p>Ситуация напоминает проблему, которая возникала при использовании автоматического конструктора копирования, но усугубляется тем. что оба объекта на момент вызова оператора присваивания существуют, поэтому для каждого объекта была динамически выделена память.</p>
<p><img src="media/image32.svg" /></p>
<p>Так как в данном случае нас не устраивает автоматический оператор присваивания, реализуем собственный.</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">&amp;</span> Animal<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Animal<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Простые данные просто копируем (то же самое сделал бы</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//автоматический оператор присваивания)</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_nAge</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_nAge</span><span class="op">;</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_Sex</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_Sex</span><span class="op">;</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_bMaster</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_bMaster</span><span class="op">;</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//А для указателя создаем свою динамическую копию</span></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_pName</span><span class="op">;</span> <span class="co">//сначала освобождаем предыдущий блок памяти</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_pName</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">char</span><span class="op">[</span>strlen<span class="op">(</span>r<span class="op">.</span><span class="va">m_pName</span><span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span> <span class="co">//а потом выделяем</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>                                               <span class="co">//новый для копии</span></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a>                                               <span class="co">//строки</span></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a>    strcpy<span class="op">(</span><span class="va">m_pName</span><span class="op">,</span> r<span class="op">.</span><span class="va">m_pName</span><span class="op">);</span> <span class="co">//и копируем содержимое</span></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span> <span class="co">//для обеспечения цепочечного присваивания</span></span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//возвращаем по ссылке адрес данного объекта</span></span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Теперь в нижеприведенном фрагменте кода все будет корректно:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>    Animal an1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> MALE<span class="op">,</span> <span class="kw">false</span><span class="op">,</span> <span class="st">&quot;Bobik&quot;</span><span class="op">),</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>           an2<span class="op">(</span><span class="dv">5</span><span class="op">,</span> MALE<span class="op">,</span> <span class="kw">true</span><span class="op">,</span> <span class="st">&quot;Lord&quot;</span><span class="op">);</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    an2 <span class="op">=</span> an1<span class="op">;</span> <span class="co">//вызов перегруженного оператора присваивания</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//вызов деструкторов локальных объектов (для каждого объекта</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a> <span class="co">//деструктор освобождает свой динамически выделенный блок памяти)</span></span></code></pre></div>
<p>А в следующем примере опять возникнет ошибка времени исполнения, так как мы не предусмотрели защиту от ситуации, когда слева и справа от знака равенства находится один и тот же объект:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>    Animal an1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> MALE<span class="op">,</span> <span class="kw">false</span><span class="op">,</span> <span class="st">&quot;Bobik&quot;</span><span class="op">);</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    an1 <span class="op">=</span> an1<span class="op">;</span> <span class="co">//при освобождении блока памяти «приемника» мы</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>               <span class="co">//одновременно сделаем недействительным блок памяти</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>               <span class="co">//«источника», так как это один и тот же объект</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Модифицируем оператор присваивания: если адрес объекта, для которого вызывается метод, совпадает с адресом объекта, полученного в качестве параметра, происходит «присваивание самому себе», поэтому ничего копировать не нужно, а только следует для обеспечения цепочечного присваивания вернуть <code>*this</code>.</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>Animal<span class="op">&amp;</span> Animal<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Animal<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>r<span class="op">)</span> <span class="co">//а) более общий случай, чем</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//(m pName!= r.m_pName)</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//б) проверка (*this!=r) требует перегрузки</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//оператора ==</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_nAge</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_nAge</span><span class="op">;</span></span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_Sex</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_Sex</span><span class="op">;</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_bMaster</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_bMaster</span><span class="op">;</span></span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_pName</span><span class="op">;</span></span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_pName</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">char</span><span class="op">[</span>strlen<span class="op">(</span>r<span class="op">.</span><span class="va">m_pName</span><span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a>        strcpy<span class="op">(</span><span class="va">m_pName</span><span class="op">,</span> r<span class="op">.</span><span class="va">m_pName</span><span class="op">);</span></span>
<span id="cb167-14"><a href="#cb167-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb167-15"><a href="#cb167-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb167-16"><a href="#cb167-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Правило:</p>
<ul>
<li><p>убедитесь, что не происходит присваивания вида <code>х=х</code></p></li>
<li><p>удалите предыдущие данные</p></li>
<li><p>скопируйте новые (все!) данные</p></li>
<li><p>возвратите <code>*this</code></p></li>
</ul>
<h4 id="оператор-присваивания-и-наследование">1.1.21. Оператор присваивания и наследование</h4>
<p>Ситуация с нетривиальными классами усугубляется при наследовании. Если в производном классе оператор присваивания не реализован, то в автоматическом операторе присваивания производного класса компилятор сам вызовет оператор присваивания базового класса. Но если Вы взяли реализацию оператора присваивания на себя, то компилятор ничего автоматически делать за Вас не будет, то есть:</p>
<ul>
<li><p>(как и в случае конструктора копирования) перегруженный оператор присваивания производного класса работает только со своей (производной) частью объекта;</p></li>
<li><p>если нет явного вызова оператора присваивания базового класса, базовая часть остается прежней!</p></li>
</ul>
<p>Поэтому программист должен предусмотреть явный вызов оператора присваивания базового класса:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>Dog<span class="op">&amp;</span> Dog<span class="op">::</span><span class="kw">operator</span><span class="op">=</span> <span class="op">(</span><span class="at">const</span> Dog<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>r<span class="op">)</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Способы вызова оператора присваивания базового класса</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>        Animal<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span>r<span class="op">);</span> <span class="co">//функциональный вызов метода</span></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>                              <span class="co">//operator= базового класса Animal</span></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_cast</span><span class="op">&lt;</span>Animal<span class="op">*&gt;(</span><span class="kw">this</span><span class="op">)</span> <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">//или нормальная форма вызова (посредством явного</span></span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">//приведения типа заставляем компилятор интерпретировать</span></span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">//указатель производного типа как указатель базового</span></span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">//типа)</span></span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_cast</span><span class="op">&lt;</span>Animal<span class="op">&amp;&gt;(*</span><span class="kw">this</span><span class="op">)</span> <span class="op">=</span> r<span class="op">;</span> <span class="co">//аналогично</span></span>
<span id="cb168-14"><a href="#cb168-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-15"><a href="#cb168-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">//копирование производной части</span></span>
<span id="cb168-16"><a href="#cb168-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb168-17"><a href="#cb168-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb168-18"><a href="#cb168-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb168-19"><a href="#cb168-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="оператор-присваивания-и-перегрузка">1.1.22. Оператор присваивания и перегрузка</h4>
<p>Если конструктор копирования может быть только один и тип его параметра предопределен, то оператор присваивания может быть перегружен сколько угодно раз.</p>
<p>Замечание: автоматически компилятор генерирует только оператор присваивания вида: <code class="sourceCode cpp">А<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> А<span class="op">&amp;)</span></code>.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>    Point pt1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">),</span> pt2<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>    pt1 <span class="op">=</span> pt2<span class="op">;</span> <span class="co">//для такого случая (и если класс простой) компилятор</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>               <span class="co">//сгенерирует автоматический оператор присваивания сам</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> z <span class="op">=</span> <span class="dv">55</span><span class="op">;</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>    pt1 <span class="op">=</span> z<span class="op">;</span> <span class="co">//или pt1.operator=(z); — а здесь выдаст ошибку, если</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>             <span class="co">//Вы не перегрузите оператор присваивания таким</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a>             <span class="co">//образом, чтобы он принимал параметр требуемого типа</span></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Для того, чтобы компилятор «знал», что ему следует делать, встречая такое выражение, введем в класс <code>Point</code> оператор присваивания, который принимает параметр нужного типа:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_x</span><span class="op">,</span> m_у<span class="op">;</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> <span class="va">m_x</span> <span class="op">=</span> n<span class="op">;</span> m_у <span class="op">=</span> n<span class="op">;</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h4 id="оптимизация-оператора-присваивания">1.1.23. Оптимизация оператора присваивания</h4>
<p>Если речь идет о динамическом выделении памяти, то по возможности следует избегать фрагментации heap-a. В частности такую возможность можно (и нужно) предусмотреть при реализации оператора присваивания. В качестве примера рассмотрим класс, инкапсулирующий одномерный динамический массив:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Array</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_size</span><span class="op">;</span> <span class="co">//количество элементов в массиве</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_capacity</span><span class="op">;</span> <span class="co">//количество элементов, для которых динамически</span></span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//выделена память (емкость) &gt;= m_size</span></span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> <span class="va">m_p</span><span class="op">;</span> <span class="co">//указатель на динамический массив</span></span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a>    Array<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="co">//конструктор, в котором динамически выделяется</span></span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>            <span class="co">//память</span></span>
<span id="cb171-10"><a href="#cb171-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_size</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb171-11"><a href="#cb171-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_capacity</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb171-12"><a href="#cb171-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_p</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb171-13"><a href="#cb171-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb171-14"><a href="#cb171-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Array<span class="op">()</span> <span class="op">{</span> <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_p</span><span class="op">;</span> <span class="op">}</span> <span class="co">//деструктор, в котором динамически</span></span>
<span id="cb171-15"><a href="#cb171-15" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//выделенная память освобождается</span></span>
<span id="cb171-16"><a href="#cb171-16" aria-hidden="true" tabindex="-1"></a>    Array<span class="op">(</span><span class="at">const</span> Array<span class="op">&amp;</span> other<span class="op">);</span> <span class="co">//конструктор копирования обязательно</span></span>
<span id="cb171-17"><a href="#cb171-17" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//должен быть явно ( и корректно)</span></span>
<span id="cb171-18"><a href="#cb171-18" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//реализован для такого класса</span></span>
<span id="cb171-19"><a href="#cb171-19" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//программистом</span></span>
<span id="cb171-20"><a href="#cb171-20" aria-hidden="true" tabindex="-1"></a>    Array<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span><span class="at">const</span> Array<span class="op">&amp;</span> other<span class="op">);</span> <span class="co">//оператор присваивания</span></span>
<span id="cb171-21"><a href="#cb171-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Реализация оператора присваивания.</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>Array<span class="op">&amp;</span> Array<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Array<span class="op">&amp;</span> other<span class="op">)</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>other<span class="op">)</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">m_capacity</span> <span class="op">&lt;</span> other<span class="op">.</span><span class="va">m_size</span><span class="op">)</span><span class="co">//если выделенной памяти не</span></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>                                      <span class="co">//хватает</span></span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_p</span><span class="op">;</span><span class="co">//старый блок освобождаем</span></span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a>            <span class="va">m_p</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">[</span>other<span class="op">.</span><span class="va">m_size</span><span class="op">];</span><span class="co">//выделяем новый</span></span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">m_capacity</span> <span class="op">=</span> other<span class="op">.</span><span class="va">m_size</span><span class="op">;</span></span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb172-12"><a href="#cb172-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_size</span> <span class="op">=</span> other<span class="op">.</span><span class="va">m_size</span><span class="op">;</span><span class="co">//формируем новый размер</span></span>
<span id="cb172-13"><a href="#cb172-13" aria-hidden="true" tabindex="-1"></a>        memcpy<span class="op">(</span><span class="va">m_p</span><span class="op">,</span> other<span class="op">.</span><span class="va">m_p</span><span class="op">,</span> <span class="va">m_size</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span> <span class="co">//копируем</span></span>
<span id="cb172-14"><a href="#cb172-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb172-15"><a href="#cb172-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb172-16"><a href="#cb172-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="интересные-приемы-программирования">1.1.24. Интересные приемы программирования</h4>
<p>Если посмотреть на реализации конструктора копирования и оператора присваивания для нетривиальных классов, то можно увидеть много общего, поэтому некоторые программисты предпочитают реализовывать конструктор копирования посредством оператора присваивания:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>Array<span class="op">::</span>Array<span class="op">(</span><span class="at">const</span> Array<span class="op">&amp;</span> other<span class="op">)</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_capacity</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//для того, чтобы в операторе присваивания была</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//выделена новая память</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_p</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//для того, чтобы оператор delete, который будет вызван</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>             <span class="co">//в операторе присваивания сработал корректно (с</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>             <span class="co">//нулевым указателем оператор delete ничего делать не</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>             <span class="co">//будет, а если оставить случайное значение, то скорее</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>             <span class="co">//всего произойдет ошибка времени выполнения)</span></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span><span class="kw">this</span> <span class="op">=</span> other<span class="op">;</span> <span class="co">//нормальная форма вызова оператора присваивания</span></span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Следующий прием позволяет:</p>
<ul>
<li><p>явно не освобождать предыдущий блок захваченной динамически памяти</p></li>
<li><p>не писать проверки на присваивание вида <code>х=х</code>:</p></li>
</ul>
<p>Вводим в класс Array вспомогательный метод:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Array<span class="op">::</span>Swap<span class="op">(</span>Array<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//обмениваем значения простых данных посредством</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//вспомогательного временного объекта</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> <span class="va">m_size</span><span class="op">;</span></span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_size</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_size</span><span class="op">;</span></span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span><span class="va">m_size</span> <span class="op">=</span> size<span class="op">;</span></span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> capacity <span class="op">=</span> <span class="va">m_capacity</span><span class="op">;</span></span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_capacity</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_capacity</span><span class="op">;</span></span>
<span id="cb174-10"><a href="#cb174-10" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span><span class="va">m_capacity</span> <span class="op">=</span> capacity<span class="op">;</span></span>
<span id="cb174-11"><a href="#cb174-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//обмениваем значения адресов динамических массивов</span></span>
<span id="cb174-12"><a href="#cb174-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> р <span class="op">=</span> <span class="va">m_p</span><span class="op">;</span></span>
<span id="cb174-13"><a href="#cb174-13" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_p</span> <span class="op">=</span> r<span class="op">.</span>m_р<span class="op">;</span></span>
<span id="cb174-14"><a href="#cb174-14" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span><span class="va">m_p</span> <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb174-15"><a href="#cb174-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb174-16"><a href="#cb174-16" aria-hidden="true" tabindex="-1"></a>Array<span class="op">&amp;</span> Array<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Array<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb174-17"><a href="#cb174-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb174-18"><a href="#cb174-18" aria-hidden="true" tabindex="-1"></a>    Array tmp <span class="op">=</span> r<span class="op">;</span><span class="co">//копия параметра</span></span>
<span id="cb174-19"><a href="#cb174-19" aria-hidden="true" tabindex="-1"></a>    Swap<span class="op">(</span>tmp<span class="op">);</span> <span class="co">//обмен данными текущего объекта с копией.</span></span>
<span id="cb174-20"><a href="#cb174-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb174-21"><a href="#cb174-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//для копии будет вызван деструктор, но к этому моменту в копии</span></span>
<span id="cb174-22"><a href="#cb174-22" aria-hidden="true" tabindex="-1"></a> <span class="co">//будут «старые» данные, которые как раз и нужно уничтожить</span></span></code></pre></div>
<p>Это красивый прием, но он не позволяет сделать никаких оптимизаций, поэтому лично я им не пользуюсь.</p>
<h3 id="стандарт-с11-move-operator">Стандарт С++11 move <code>operator=</code></h3>
<p>(текст отсутствует!)</p>
<h3 id="перегрузка-оператора">Перегрузка оператора <code>[]</code></h3>
<p>Рассмотренный в предыдущем разделе класс <code>Array</code> является оберткой для одномерного динамического массива, поэтому логично предоставить пользователю такого класса возможность обращаться к элементам массива посредством привычного для программиста оператора индексирования:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>    Array a<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>        a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span> <span class="co">//нормальная форма вызова оператора индексирования</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>        a<span class="op">.</span><span class="kw">operator</span><span class="op">[](</span>i<span class="op">)</span> <span class="op">=</span> i<span class="op">;</span> <span class="co">//функциональная форма вызова оператора</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//индексирования</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Для этого в классе Array должен быть перегружен <code>operator[]</code>:</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">&amp;</span> Array<span class="op">::</span><span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> n<span class="op">)</span> <span class="co">//возвращать следует по ссылке для</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//того, чтобы можно было</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//использовать возвращаемое</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//значение как справа, так и слева</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>                                <span class="co">//от знака= (запись/чтение)</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> n <span class="op">&lt;</span> <span class="va">m_size</span><span class="op">)</span> <span class="cf">return</span> <span class="va">m_p</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//генерация исключения</span></span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечания:</p>
<ul>
<li><p>перегруженный оператор индексирования должен возвращать не значение требуемого элемента массива, а его адрес, для того чтобы вызов этого метода можно было использовать слева от знака равенства (то есть по возвращенному адресу присвоить новое значение). Указатель в качестве возвращаемого значения использовать неудобно, поэтому принято возвращать ссылку;</p></li>
<li><p>для обычных массивов для повышения эффективности вычислений компилятор не проверяет «выход» значения индекса за пределы массива, но в своем классе в перегруженном операторе индексирования мы можем обезопасить себя от такой ситуации (<a href="#тема-xii.-исключительные-ситуации-exceptions">тема «Обработка исключений»</a>);</p></li>
<li><p>для обычных массивов индекс может быть только целым. Тип параметра перегруженного оператора индексирования может быть любым (пример — в <a href="#тема-vi.-встроенные-объекты-composition.-отношение-между-классами-содержит">разделе «Встроенные объекты»</a>);</p></li>
<li><p>так как для константных объектов компилятор данный метод вызвать не позволит, обычно в класс вводят еще один перегруженный константный оператор индексирования, а компилятор вызывает тот или иной метод, исходя из константности объекта:</p></li>
</ul>
<div class="sourceCode" id="cb177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Array<span class="op">::</span><span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span> <span class="at">const</span> <span class="co">//метод предназначен только</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>                                      <span class="co">//для чтения, поэтому не имеет</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>                                     <span class="co">//смысл возвращать адрес</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> <span class="va">m_size</span><span class="op">)</span> <span class="cf">return</span> <span class="va">m_p</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">...</span></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a>    Array a<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> a<span class="op">[</span><span class="dv">5</span><span class="op">];</span> <span class="co">//вызов неконстантного метода</span></span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">//вызов неконстантного метода</span></span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Array a1<span class="op">(</span><span class="dv">20</span><span class="op">);</span></span>
<span id="cb177-13"><a href="#cb177-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp1 <span class="op">=</span> a1<span class="op">[</span><span class="dv">5</span><span class="op">];</span> <span class="co">//константная версия</span></span>
<span id="cb177-14"><a href="#cb177-14" aria-hidden="true" tabindex="-1"></a><span class="co">//  a1[1] = 2; //ошибка</span></span>
<span id="cb177-15"><a href="#cb177-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="перегрузка-оператора---">Перегрузка оператора <code>++</code> (<code>--</code>)</h3>
<p>Специфика операторов инкремента и декремента заключается в том, что этот оператор может быть как постфиксным, так и префиксным, а имя у функции одно и то же — <code>operator++</code>. В ранних версиях C++ не было возможности различить две эти формы, а в современных спецификациях языка разработчики ввели несколько искусственный способ, по которому компилятор может различить префиксную и постфиксную формы, поэтому для каждой формы определяют свою версию перегруженного оператора:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_x</span><span class="op">,</span> <span class="va">m_y</span><span class="op">;</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">);</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">++();</span> <span class="co">//префиксный инкремент (подчиняется</span></span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//правилам: унарный оператор, перегруженный</span></span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//метолом класса, не принимает параметров)</span></span>
<span id="cb178-9"><a href="#cb178-9" aria-hidden="true" tabindex="-1"></a>    Point <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span> unused<span class="op">);</span> <span class="co">//постфиксный принимает фиктивный</span></span>
<span id="cb178-10"><a href="#cb178-10" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//параметр (компилятор в качестве</span></span>
<span id="cb178-11"><a href="#cb178-11" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//передаваемого значения формирует</span></span>
<span id="cb178-12"><a href="#cb178-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span>                                <span class="co">//0)</span></span></code></pre></div>
<p>Реализация префиксного инкремента:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>Point<span class="op">&amp;</span> Point<span class="op">::</span>operalor<span class="op">++()</span> <span class="co">//возвращается адрес модифицированного</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//объекта</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_i</span>х<span class="op">++;</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>    m iy<span class="op">++;</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Реализация постфиксного инкремента:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>Point Point<span class="op">::</span><span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="co">//не имеем права возвращать адрес</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//локального объекта, поэтому</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>                            <span class="co">//возвращать нужно только по значению</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Point<span class="op">(</span><span class="va">m_x</span><span class="op">++,</span> <span class="va">m_y</span><span class="op">++);</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>    Point pt1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">),</span> pt2<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">3</span><span class="op">),</span> pt3<span class="op">;</span></span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a>    pt3 <span class="op">=</span> pt1<span class="op">++;</span> <span class="co">//встречая такую запись, компилятор генерирует</span></span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//вызов функции с фиктивным параметром —</span></span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//эквивалентно pt1.operator++(0);</span></span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a>    pt1<span class="op">.</span><span class="kw">operator</span><span class="op">++(</span><span class="dv">0</span><span class="op">);</span> <span class="co">//функциональная форма вызова постфиксного</span></span>
<span id="cb180-13"><a href="#cb180-13" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//инкремента</span></span>
<span id="cb180-14"><a href="#cb180-14" aria-hidden="true" tabindex="-1"></a>    pt3 <span class="op">=</span> <span class="op">++</span>pt2<span class="op">;</span> <span class="co">//pt2.operator++();</span></span>
<span id="cb180-15"><a href="#cb180-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="перегрузка-оператора-приведения-типа">Перегрузка оператора приведения типа</h3>
<p>Специфика: нельзя задать тип возвращаемого значения, потому что данный тип представляет собой имя функции</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> ar<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> с<span class="op">;</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">char</span><span class="op">*</span> р<span class="op">,</span> <span class="dt">char</span> cc<span class="op">,</span> <span class="dt">int</span> nn<span class="op">);</span></span>
<span id="cb181-8"><a href="#cb181-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="dt">char</span><span class="op">*</span> <span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> ar<span class="op">;</span> <span class="op">}</span></span>
<span id="cb181-9"><a href="#cb181-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="dt">char</span><span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> с<span class="op">;</span> <span class="op">}</span></span>
<span id="cb181-10"><a href="#cb181-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="dt">int</span><span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb181-11"><a href="#cb181-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb181-12"><a href="#cb181-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb181-13"><a href="#cb181-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb181-14"><a href="#cb181-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Прим. редактора: не компилируется</span></span>
<span id="cb181-15"><a href="#cb181-15" aria-hidden="true" tabindex="-1"></a>    A а<span class="op">(</span><span class="st">&quot;QWERTYqq&quot;</span><span class="op">,</span> <span class="ch">&#39;W&#39;</span><span class="op">,</span> <span class="dv">33</span><span class="op">);</span></span>
<span id="cb181-16"><a href="#cb181-16" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(</span>a<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span><span class="co">//operator char*()</span></span>
<span id="cb181-17"><a href="#cb181-17" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;(</span>a<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span><span class="co">//operator char()</span></span>
<span id="cb181-18"><a href="#cb181-18" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">(</span>a<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span><span class="co">//operator int()</span></span>
<span id="cb181-19"><a href="#cb181-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Если по контексту использования компилятор может «догадаться»</span></span>
<span id="cb181-20"><a href="#cb181-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//какую из форм перегрузки он должен использовать:</span></span>
<span id="cb181-21"><a href="#cb181-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> x1 <span class="op">=</span> a<span class="op">;</span><span class="co">//operator char</span></span>
<span id="cb181-22"><a href="#cb181-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> х<span class="dv">2</span> <span class="op">=</span> a<span class="op">;</span><span class="co">//operator char*</span></span>
<span id="cb181-23"><a href="#cb181-23" aria-hidden="true" tabindex="-1"></a>    х<span class="dv">2</span> <span class="op">=</span> a<span class="op">.</span><span class="kw">operator</span> <span class="dt">char</span><span class="op">*</span> <span class="op">();</span><span class="co">//функциональная форма</span></span>
<span id="cb181-24"><a href="#cb181-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> х<span class="dv">3</span> <span class="op">=</span> а<span class="op">;</span><span class="co">//operator int</span></span>
<span id="cb181-25"><a href="#cb181-25" aria-hidden="true" tabindex="-1"></a><span class="co">//  double res = 3*a + а;//ошибка — ambiguous operator* компилятор</span></span>
<span id="cb181-26"><a href="#cb181-26" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//не знает к какому типу преобразовать а</span></span>
<span id="cb181-27"><a href="#cb181-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: главная проблема таких функций заключается в том. что они могут неявно вызываться компилятором, когда Вы этого не ожидаете. В таких случаях поведение программы не подчиняется интуитивному анализу, поэтому ее очень трудно отлаживать.</p>
<h3 id="перегрузка-оператора--.-умные-указатели">Перегрузка оператора <code>-&gt;</code>. Умные указатели</h3>
<p>Если Вы динамически выделили память, то всегда есть вероятность того, что Вы забудете ее освободить:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>    А<span class="op">*</span> р <span class="op">=</span> <span class="kw">new</span> А<span class="op">;</span> <span class="co">//динамический объект</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>    А а<span class="op">;</span> <span class="co">//локальный стековый</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//работа с обоими</span></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//забыли освободись память</span></span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//для локального объекта компилятор вызовет деструктор</span></span></code></pre></div>
<p>А динамический объект программист забыл уничтожить, поэтому:</p>
<ul>
<li><p>память «потекла», так как видимость и существование локальной переменной р закончилась, поэтому память будет освобождена ОС только при завершении приложения</p></li>
<li><p>деструктор тоже вызван не будет</p></li>
</ul>
<p>Чтобы обезопасить себя от такой ситуации, неплохо было бы «завернуть» такой потенциально опасный указатель в оболочку, которая с гарантией память освободит. Джефф Элджер называет такие классы-обертки «умными указателями».</p>
<p>Например, есть некоторый класс <code>A</code>, а мне для решения моей задачи нужны объекты такого типа:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span> <span class="op">}</span></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> func<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Вводим вспомогательный класс <code>ptr</code> и «заворачиваем» потенциально опасный указатель <code>A*</code> в этот класс-обертку. Специфика:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ptr</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> <span class="va">m_p</span><span class="op">;</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>    ptr<span class="op">(</span><span class="dt">int</span> а <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="va">m_p</span> <span class="op">=</span> <span class="kw">new</span> A<span class="op">(</span>а<span class="op">);</span> <span class="op">}</span> <span class="co">//конструктор класса-обертки</span></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>                                       <span class="co">//принимает параметр для</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>                                       <span class="co">//целевого класса</span></span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>ptr<span class="op">()</span> <span class="op">{</span> <span class="kw">delete</span> <span class="va">m_p</span><span class="op">;</span> <span class="op">}</span> <span class="co">//в деструкторе память освобождаем</span></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_p</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">//объектом класса-обертки позволяем пользоваться таким же</span></span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">//образом, как целевым указателем A* посредством перегрузки</span></span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">//operator-&gt;</span></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> A<span class="op">*</span> <span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_p</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//перегрузка оператора приведения типа таким</span></span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">//образом, чтобы везде, где нужен указатель A*,</span></span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">//можно было использовать объект типа ptr</span></span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Модифицируем целевой класс <code>A</code> таким образом, чтобы пользователю было запрещено самому создавать объекты типа <code>A</code>. а пользоваться этим классом разрешаем только посредством обертки:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span><span class="co">//делаем конструктор защищенным, теперь создавать объекты</span></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>          <span class="co">//класса А может только метод класса ptr!!!</span></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span> <span class="op">}</span></span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> func<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="kw">class</span> ptr<span class="op">;</span> <span class="co">//а классу-обертке предоставляются все права</span></span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span>                    <span class="co">//для обращения к защищенным членам класса A</span></span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>A<span class="op">*);</span> <span class="co">//для примера введем еще глобальную функцию, которая</span></span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">//принимает указатель А*</span></span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">//A a(1); //ошибка доступа (конструктор защищен)</span></span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a>        ptr my<span class="op">(</span><span class="dv">1</span><span class="op">);</span> <span class="co">//в конструкторе ptr динамически создается объект</span></span>
<span id="cb185-18"><a href="#cb185-18" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//целевого типа</span></span>
<span id="cb185-19"><a href="#cb185-19" aria-hidden="true" tabindex="-1"></a>        f<span class="op">(</span>my<span class="op">);</span><span class="co">//оператор преобразования типа -&gt; на самом деле —</span></span>
<span id="cb185-20"><a href="#cb185-20" aria-hidden="true" tabindex="-1"></a>              <span class="co">//f(my-&gt;m_p)</span></span>
<span id="cb185-21"><a href="#cb185-21" aria-hidden="true" tabindex="-1"></a>        my<span class="op">-&gt;</span>func<span class="op">();</span><span class="co">//operator-&gt; =&gt; на самом деле</span></span>
<span id="cb185-22"><a href="#cb185-22" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//my.operator-&gt;()-&gt;func();</span></span>
<span id="cb185-23"><a href="#cb185-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span><span class="co">//деструктор ~my, в котором намять будет освобождена</span></span>
<span id="cb185-24"><a href="#cb185-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Проблема: пока нет никаких препятствий при использовании класса <code>ptr</code> сделать:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>    ptr my<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>    А<span class="op">*</span> рА <span class="op">=</span> my<span class="op">;</span> <span class="co">//будет вызван оператор приведения типа</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> рА<span class="op">;</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//а в деструкторе my будет тоже вызван оператор delete, что скорее</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a> <span class="co">//всего приведет к ошибке времени выполнения</span></span></code></pre></div>
<p>Для предотвращения таких ситуаций можно запретить пользователю вызывать деструктор класса <code>A</code>, сделав его защищенным:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span> <span class="op">{</span> <span class="op">}</span> <span class="co">//пусть деструктор ничего не делает, но таким образом мы</span></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>             <span class="co">//запретим даже посредством оператора delete вызывать</span></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span>           <span class="co">//его извне</span></span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a>    ptr my<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> рA <span class="op">=</span> my<span class="op">;</span> <span class="co">//будет вызван оператор приведения типа</span></span>
<span id="cb187-11"><a href="#cb187-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//delete рА; //ошибка нет доступа</span></span>
<span id="cb187-12"><a href="#cb187-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Проблема: так как в классе <code>ptr</code> в качестве члена данных содержится указатель на динамически создаваемый объект, то при использовании автоматического конструктора копирования и оператора присваивания класса <code>ptr</code> в следующем фрагменте ожидаются большие неприятности времени выполнения:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>    ptr my1<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>    ptr my2 <span class="op">=</span> myl<span class="op">;</span> <span class="co">//конструктор копирования</span></span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>    myl <span class="op">=</span> my2<span class="op">;</span> <span class="co">//оператор присваивания</span></span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//~my1, ~my2 — ошибка времени выполнения!!!</span></span></code></pre></div>
<p>Решения:</p>
<ol type="a">
<li><p>просто запретить и то. и другое, объявив их защищенными (private или protected) в классе ptr</p></li>
<li><p>реализовать их корректно!</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">(</span><span class="at">const</span> ptr<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_p</span> <span class="op">=</span> <span class="kw">new</span> А<span class="op">(*(</span>r<span class="op">.</span><span class="va">m_p</span><span class="op">));</span><span class="co">//присваивает указателю адрес своей</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>                          <span class="co">//копии, созданной с помощью</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>                         <span class="co">//конструктора копирования</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> ptr<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span><span class="va">m_p</span> <span class="op">=</span> <span class="op">*(</span>r<span class="op">.</span><span class="va">m_p</span><span class="op">);</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>альтернативой является прием, который используется при реализации класса auto_ptr стандартной библиотеки: у объекта всегда один владелец, а при копировании или присваивании объект просто меняет владельца (то есть объект передается от одного объекта к другому как эстафетная палочка)!!!</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">(</span>ptr<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_p</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_p</span><span class="op">;</span></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span><span class="va">m_p</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>ptr<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>r<span class="op">)</span></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> <span class="va">m_p</span><span class="op">;</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_p</span> <span class="op">=</span> r<span class="op">.</span><span class="va">m_p</span><span class="op">;</span></span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a>        r<span class="op">.</span><span class="va">m_p</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb190-15"><a href="#cb190-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<h3 id="перегрузка-оператора-.-функциональные-объекты">Перегрузка оператора <code>()</code>. Функциональные объекты</h3>
<p>Функциональный объект — это класс, в котором перегружен оператор вызов функции — <code>()</code>. Объекты-функции работают почти так же как указатели на функции, но обладают большими возможностями (могут содержать дополнительные данные в своих переменных класса).</p>
<p>Замечание: преимущества использования функциональных объектов начинают проявляться при задании предикатов в обобщенных алгоритмах стандартной библиотеки (везде, где обобщенный алгоритм требует в качестве параметра указатель на функцию, можно использовать функциональный объект).</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_nX</span><span class="op">,</span> <span class="va">m_nY</span><span class="op">;</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> dx<span class="op">,</span> <span class="dt">int</span> dy<span class="op">)</span> <span class="op">{</span> <span class="va">m_nX</span> <span class="op">+=</span> dx<span class="op">;</span> <span class="va">m_nY</span> <span class="op">+=</span> dy<span class="op">;</span> <span class="op">}</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> r<span class="op">)</span></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_nX</span> <span class="op">+=</span> r<span class="op">.</span><span class="va">m_nX</span><span class="op">;</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_nY</span> <span class="op">+=</span> r<span class="op">.</span><span class="va">m_nY</span><span class="op">;</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb191-13"><a href="#cb191-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb191-14"><a href="#cb191-14" aria-hidden="true" tabindex="-1"></a>    Point ar<span class="op">[]{</span> Point<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">),</span> Point<span class="op">(</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">),</span> Point<span class="op">(</span><span class="dv">4</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span> <span class="op">};</span></span>
<span id="cb191-15"><a href="#cb191-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb191-16"><a href="#cb191-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb191-17"><a href="#cb191-17" aria-hidden="true" tabindex="-1"></a>        ar<span class="op">[</span>i<span class="op">](</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">);</span></span>
<span id="cb191-18"><a href="#cb191-18" aria-hidden="true" tabindex="-1"></a>        ar<span class="op">[</span>i<span class="op">](</span>Point<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">));</span><span class="co">//создается временный объект и для ar[i]</span></span>
<span id="cb191-19"><a href="#cb191-19" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//вызывается operator()(const Point &amp; r)</span></span>
<span id="cb191-20"><a href="#cb191-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb191-21"><a href="#cb191-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="специфика-при-использовании-перегруженных-операторов-в-классах-с-конструктором-принимающим-один-параметр">Специфика при использовании перегруженных операторов в классах с конструктором, принимающим один параметр</h3>
<div class="sourceCode" id="cb192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span> <span class="op">}</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>    A <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> A<span class="op">&amp;</span> r<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> A<span class="op">(</span><span class="va">m_a</span> <span class="op">+</span> r<span class="op">.</span><span class="va">m_a</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a>    A al<span class="op">(</span><span class="dv">1</span><span class="op">),</span> a2<span class="op">;</span></span>
<span id="cb192-10"><a href="#cb192-10" aria-hidden="true" tabindex="-1"></a>    a2 <span class="op">=</span> a1 <span class="op">+</span> <span class="dv">3</span><span class="op">;</span> <span class="co">//в данном выражении компилятор для второго</span></span>
<span id="cb192-11"><a href="#cb192-11" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//операнда с помощью конструктора с одним</span></span>
<span id="cb192-12"><a href="#cb192-12" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//параметром неявно приводит операнд типа int к</span></span>
<span id="cb192-13"><a href="#cb192-13" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//типу A, создавая временный объект, и вызывает</span></span>
<span id="cb192-14"><a href="#cb192-14" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//перегруженный operator+, как если бы Вы написали</span></span>
<span id="cb192-15"><a href="#cb192-15" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//а2 = а1 + A(3);</span></span>
<span id="cb192-16"><a href="#cb192-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: неявное преобразование можно запретить, объявив конструктор с ключевым словом <code>explicit</code>.</p>
<h2 id="перегрузка-оператора-с-помощью-глобальной-функции">Перегрузка оператора с помощью глобальной функции</h2>
<p>Если Вы хотите, чтобы компилятор вызывал перегруженный Вами оператор для класса <code>A</code>. глобальная функция должна иметь по крайней мере один параметр типа <code>A</code>. Для удобства (чтобы можно было в такой глобальной функции обращаться к защищенным переменным класса <code>A</code>) такую функцию можно объявить <code>friend</code>-функцией класса <code>A</code>. Но это необязательно!</p>
<h3 id="перегрузка-оператора-проверка-на-равенство">Перегрузка оператора «<code>==</code>» (проверка на равенство)</h3>
<p>Согласно рекомендациям такой оператор предпочтительнее перегружать методом класса, но для примера реализуем перегрузку глобальной функцией.</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Animal<span class="op">&amp;,</span> <span class="at">const</span> Animal<span class="op">&amp;);</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//объявление глобальной friend-функиии перегруженного</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//оператора ==</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a><span class="co">//Реализация глобальной friend-функции перегрузки оператора ==</span></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Animal<span class="op">&amp;</span> ref1<span class="op">,</span> <span class="at">const</span> Animal<span class="op">&amp;</span> ref2<span class="op">)</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>ref1<span class="op">.</span><span class="va">m_age</span> <span class="op">==</span> ref2<span class="op">.</span><span class="va">m_age</span></span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">&amp;&amp;</span> ref1<span class="op">.</span><span class="va">m_sex</span> <span class="op">==</span> ref2<span class="op">.</span><span class="va">m_sex</span></span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">&amp;&amp;</span> <span class="op">(</span>strcmp<span class="op">(</span>ref1<span class="op">.</span><span class="va">m_pName</span><span class="op">,</span> ref2<span class="op">.</span><span class="va">m_pName</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb193-15"><a href="#cb193-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb193-16"><a href="#cb193-16" aria-hidden="true" tabindex="-1"></a>    Animal an1<span class="op">(...),</span> an2<span class="op">(...);</span></span>
<span id="cb193-17"><a href="#cb193-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>an2 <span class="op">==</span> an1<span class="op">)</span> <span class="co">//нормальная форма вызова. Исходя из тина</span></span>
<span id="cb193-18"><a href="#cb193-18" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//объектов an1 и ап2 компилятор генерирует вывоз</span></span>
<span id="cb193-19"><a href="#cb193-19" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//глобальной функции operator == с параметрами —</span></span>
<span id="cb193-20"><a href="#cb193-20" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//ссылками на an1 и ап2</span></span>
<span id="cb193-21"><a href="#cb193-21" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> <span class="st">&quot;an1 == an2&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb193-22"><a href="#cb193-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;an1 != an2&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb193-23"><a href="#cb193-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">operator</span><span class="op">==(</span>an1<span class="op">,</span> an2<span class="op">)</span> <span class="op">==</span> <span class="kw">true</span><span class="op">)</span> <span class="co">//то же самое — функциональная</span></span>
<span id="cb193-24"><a href="#cb193-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span>                           <span class="co">//форма вызова</span></span>
<span id="cb193-25"><a href="#cb193-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Для производных классов:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Dog<span class="op">&amp;</span> refl<span class="op">,</span> <span class="at">const</span> Dog<span class="op">&amp;</span> ref2<span class="op">)</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Сравниваем базовые части посредством уже реализованного</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//оператора== для класса Animal</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">operator</span><span class="op">==(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> Animal<span class="op">&amp;&gt;(</span>ref1<span class="op">),</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> Animal<span class="op">&amp;&gt;(</span>ref2<span class="op">))</span> <span class="op">==</span> <span class="kw">false</span><span class="op">)</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//приводить явно второй параметр в VC необязательно, но</span></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//может зависеть от реализации</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Если базовые части совпадают, сравниваем производные</span></span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>ref1<span class="op">.</span><span class="va">m_bHasMaster</span> <span class="op">==</span> ref2<span class="op">.</span><span class="va">m_bHasMaster</span></span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">&amp;&amp;</span> <span class="op">(</span>strcmp<span class="op">(</span>ref1<span class="op">.</span><span class="va">m_pMasterName</span><span class="op">,</span> ref2<span class="op">.</span><span class="va">m_pMaslexName</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb194-13"><a href="#cb194-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb194-14"><a href="#cb194-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb194-15"><a href="#cb194-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb194-16"><a href="#cb194-16" aria-hidden="true" tabindex="-1"></a>    Dog dogl<span class="op">(...),</span> dog2<span class="op">(...);</span></span>
<span id="cb194-17"><a href="#cb194-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>dog1 <span class="op">==</span> dog2<span class="op">)</span></span>
<span id="cb194-18"><a href="#cb194-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb194-19"><a href="#cb194-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="перегрузка-оператора-вывод-в-библиотечный-ostream">Перегрузка оператора <code>&lt;&lt;</code> (вывод в библиотечный <code>ostream</code>)</h3>
<p>Хотелось бы выводить содержимое объектов пользовательского типа на консоль (или в файл) также просто и элегантно, как мы до сих пор выводили значения переменных базового типа:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>    Animal а<span class="op">(</span><span class="dv">5</span><span class="op">,</span> MALE<span class="op">,</span> <span class="st">&quot;Bobik&quot;</span><span class="op">);</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> a <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="co">//при этом хотелось бы увидеть на</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//экране что-нибудь типа: animal:</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>                                <span class="co">//age=5 sex=male name=Bobik</span></span></code></pre></div>
<p>Если в предыдущем примере оператор <code>==</code> можно было перегрузить как методом класса (предпочтительнее), так и глобальной функцией, то перегрузка оператора <code>&lt;&lt;</code> для вывода в поток это исключение, когда перегрузка возможна только глобальной функцией, так как операнд слева (<code>std::cout</code>) библиотечного типа <code>ostream</code>.</p>
<p>Замечание: в классе <code>ostream</code> стандартной библиотеки перегружен методами класса <code>operator&lt;&lt;</code>, который «умеет» выводить значения базовых типов, а про Ваш пользовательский тип компилятор ничего не знает, и вряд ли стоит модифицировать код стандартной библиотеки, поэтому перегрузка возможна только глобальной функцией.</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Animal</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="at">const</span> Animal<span class="op">&amp;</span> an<span class="op">);</span></span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//для того, чтобы иметь возможность в этой глобальной</span></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">//функции обращаться к защищенным переменным класса Animal,</span></span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span>      <span class="co">//объявляем ее friend</span></span>
<span id="cb196-8"><a href="#cb196-8" aria-hidden="true" tabindex="-1"></a>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="at">const</span> Animal<span class="op">&amp;</span> an<span class="op">)</span></span>
<span id="cb196-9"><a href="#cb196-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb196-10"><a href="#cb196-10" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;animal: age=&quot;</span> <span class="op">&lt;&lt;</span> an<span class="op">.</span><span class="va">m_age</span></span>
<span id="cb196-11"><a href="#cb196-11" aria-hidden="true" tabindex="-1"></a>       <span class="op">&lt;&lt;</span> <span class="st">&quot; sex=&quot;</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>an<span class="op">.</span><span class="va">m_sex</span> <span class="op">==</span> MALE <span class="op">?</span> <span class="st">&quot;male&quot;</span> <span class="op">:</span> <span class="st">&quot;female&quot;</span><span class="op">)</span></span>
<span id="cb196-12"><a href="#cb196-12" aria-hidden="true" tabindex="-1"></a>       <span class="op">&lt;&lt;</span> <span class="st">&quot; name=&quot;</span> <span class="op">&lt;&lt;</span> an<span class="op">.</span><span class="va">m_pName</span><span class="op">;</span></span>
<span id="cb196-13"><a href="#cb196-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb196-14"><a href="#cb196-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: если хочется выводить в файл информацию в таком же виде, как на экран, то можно использовать один и тот же перегруженный оператор, так как классы <code>ostream</code> и <code>ofstream</code> (для файлового вывода) связаны наследованием:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>    Animal а<span class="op">(</span><span class="dv">5</span><span class="op">,</span> МАLЕ<span class="op">,</span> <span class="st">&quot;Bobik&quot;</span><span class="op">);</span></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ofstream<span class="op"> </span>file<span class="op">(</span><span class="st">&quot;dat.txt&quot;</span><span class="op">);</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>    file <span class="op">&lt;&lt;</span> a <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Попробуйте перегрузить оператор для вывода объекта типа <code>Dog</code>.</p>
<h3 id="перегрузка-перегруженных-глобальными-функциями-операторов">Перегрузка перегруженных глобальными функциями операторов</h3>
<p>Как и обычную глобальную функцию, перегруженный оператор можно в свою очередь перегрузить сколько угодно раз. Главное, чтобы компилятор при вызове функции смог различить по типу параметров, какую из перегруженных версий вызывать. Замечание: так как количество параметров в данном случае предопределено, то перегрузка возможна только по типу параметров.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>    A a1<span class="op">(</span><span class="dv">1</span><span class="op">),</span> a2<span class="op">(</span><span class="dv">2</span><span class="op">),</span> a3<span class="op">;</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//в двух следующих выражениях предпочтительнее было бы</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//перегрузить оператор методом класса:</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>    a3 <span class="op">=</span> a1 <span class="op">+</span> a2<span class="op">;</span> <span class="co">//или а3 = operator+(al, а2);</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a>    a3 <span class="op">=</span> a1 <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">//или а3 = operator+(a1, 1);</span></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//а здесь перегрузка возможна только глобальной функцией, так</span></span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//как левый операнд базового типа:</span></span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>    a3 <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> a2<span class="op">;</span> <span class="co">//или а3 = operator+(2, а2);</span></span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb198-13"><a href="#cb198-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb198-14"><a href="#cb198-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb198-15"><a href="#cb198-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb198-16"><a href="#cb198-16" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb198-17"><a href="#cb198-17" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> n<span class="op">);</span></span>
<span id="cb198-18"><a href="#cb198-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">//перегрузка оператора + глобальной функцией</span></span>
<span id="cb198-19"><a href="#cb198-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> A <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> A<span class="op">&amp;</span> r1<span class="op">,</span> <span class="at">const</span> A<span class="op">&amp;</span> r2<span class="op">)</span></span>
<span id="cb198-20"><a href="#cb198-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb198-21"><a href="#cb198-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb198-22"><a href="#cb198-22" aria-hidden="true" tabindex="-1"></a>            A<span class="op">(</span>r1<span class="op">.</span><span class="va">m_a</span> <span class="op">+</span> r2<span class="op">.</span><span class="va">m_a</span><span class="op">);</span></span>
<span id="cb198-23"><a href="#cb198-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb198-24"><a href="#cb198-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> A <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> A<span class="op">&amp;</span> r1<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb198-25"><a href="#cb198-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb198-26"><a href="#cb198-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb198-27"><a href="#cb198-27" aria-hidden="true" tabindex="-1"></a>            A<span class="op">(</span>r1<span class="op">.</span><span class="va">m_a</span> <span class="op">+</span> n<span class="op">);</span></span>
<span id="cb198-28"><a href="#cb198-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb198-29"><a href="#cb198-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> A <span class="kw">operator</span><span class="op">+(</span><span class="dt">int</span> n<span class="op">,</span> <span class="at">const</span> A<span class="op">&amp;</span> r2<span class="op">)</span></span>
<span id="cb198-30"><a href="#cb198-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb198-31"><a href="#cb198-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb198-32"><a href="#cb198-32" aria-hidden="true" tabindex="-1"></a>            A<span class="op">(</span>n <span class="op">+</span> r2<span class="op">.</span><span class="va">m_a</span><span class="op">);</span></span>
<span id="cb198-33"><a href="#cb198-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb198-34"><a href="#cb198-34" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="правила-выбора-формы-перегрузки-операторов">Правила выбора формы перегрузки операторов</h2>
<ul>
<li><p>виртуальные функции должны быть членами класса</p></li>
<li><p>при использовании библиотечных классов операторы всегда перегружаются глобальными функциями. Если такая функция должна иметь доступ к защищенным данным, объявляйте ее в классе <code>friend</code></p></li>
<li><p>если аргумент слева базового типа, объявляйте перегруженный оператор глобальной функцией. Если такая функция должна иметь доступ к защищенным данным, объявляйте ее в классе <code>friend</code></p></li>
<li><p>в остальных случаях рекомендуется перегружать оператор методом класса</p></li>
</ul>
<h1 id="тема-v.-сложные-указатели.-указатели-на-члены-класса">Тема V. Сложные указатели. Указатели на члены класса</h1>
<p>В некоторых случаях нужно уметь объявлять и использовать указатели на члены класса (реже на переменные, чаще на методы).</p>
<p>Для демонстрации создадим простенькую иерархию классов:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_Private_a</span><span class="op">;</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_Public_a</span><span class="op">;</span> <span class="co">//для примера в нарушение правил ООП</span></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//объявим общедоступную переменную</span></span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">int</span> a2 <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="va">m_Private_a</span> <span class="op">=</span> a1<span class="op">;</span> <span class="va">m_Public_a</span> <span class="op">=</span> a2<span class="op">;</span> <span class="op">}</span></span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">();</span></span>
<span id="cb199-9"><a href="#cb199-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> vf<span class="op">();</span></span>
<span id="cb199-10"><a href="#cb199-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb199-11"><a href="#cb199-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb199-12"><a href="#cb199-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb199-13"><a href="#cb199-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb199-14"><a href="#cb199-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb199-15"><a href="#cb199-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> vf<span class="op">();</span></span>
<span id="cb199-16"><a href="#cb199-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb199-17"><a href="#cb199-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb199-18"><a href="#cb199-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb199-19"><a href="#cb199-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">//указатели на переменные класса</span></span>
<span id="cb199-20"><a href="#cb199-20" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb199-21"><a href="#cb199-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-22"><a href="#cb199-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">//а)</span></span>
<span id="cb199-23"><a href="#cb199-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">//int* р = &amp;А::m_Private_a;//ошибка доступа — cannot access</span></span>
<span id="cb199-24"><a href="#cb199-24" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//private member</span></span>
<span id="cb199-25"><a href="#cb199-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> р <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">.</span><span class="va">m_Public_a</span><span class="op">;</span><span class="co">//р - обычный указатель, содержит адрес </span></span>
<span id="cb199-26"><a href="#cb199-26" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//переменной m_Public_a объекта а</span></span>
<span id="cb199-27"><a href="#cb199-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-28"><a href="#cb199-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">//использование такого указателя ничем не отличается от </span></span>
<span id="cb199-29"><a href="#cb199-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">//использования указателя на обычную переменную</span></span>
<span id="cb199-30"><a href="#cb199-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> t <span class="op">=</span> <span class="op">*</span>р<span class="op">;</span></span>
<span id="cb199-31"><a href="#cb199-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-32"><a href="#cb199-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">//б)</span></span>
<span id="cb199-33"><a href="#cb199-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">//int А::*рА1 = &amp;A::m_Private_a;//cannot access private member</span></span>
<span id="cb199-34"><a href="#cb199-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> A<span class="op">::*</span>pA <span class="op">=</span> <span class="op">&amp;</span>A<span class="op">::</span><span class="va">m_Public_a</span><span class="op">;</span></span>
<span id="cb199-35"><a href="#cb199-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">//a такая переменная pA содержит не адрес, а смещение </span></span>
<span id="cb199-36"><a href="#cb199-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">//переменной m_Public_a относительно начала объекта</span></span>
<span id="cb199-37"><a href="#cb199-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb199-38"><a href="#cb199-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">//использование такого «указателя» специфично</span></span>
<span id="cb199-39"><a href="#cb199-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> a<span class="op">.*</span>pA<span class="op">;</span><span class="co">//а пользоваться этим смещением синтаксически</span></span>
<span id="cb199-40"><a href="#cb199-40" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//можно как указателем (но только посредством </span></span>
<span id="cb199-41"><a href="#cb199-41" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//объекта или указателя на объект)</span></span>
<span id="cb199-42"><a href="#cb199-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-43"><a href="#cb199-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Указатели на невиртуальные и нестатические методы класса</span></span>
<span id="cb199-44"><a href="#cb199-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">//void (*pf) () =А::f;//ошибка компилятора</span></span>
<span id="cb199-45"><a href="#cb199-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(</span>A<span class="op">::*</span>pf<span class="op">)()</span> <span class="op">=</span> A<span class="op">::</span>f<span class="op">;</span><span class="co">//такой указатель рf содержит просто </span></span>
<span id="cb199-46"><a href="#cb199-46" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//адрес функции, но при вызове такой </span></span>
<span id="cb199-47"><a href="#cb199-47" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//функции компилятор должен сформировать </span></span>
<span id="cb199-48"><a href="#cb199-48" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//дополнительный параметр - адрес того </span></span>
<span id="cb199-49"><a href="#cb199-49" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//объекта, для которого вызывается метод</span></span>
<span id="cb199-50"><a href="#cb199-50" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//(this)</span></span>
<span id="cb199-51"><a href="#cb199-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>a<span class="op">.*</span>pf<span class="op">)();</span><span class="co">//поэтому вызывать нужно посредством объекта или</span></span>
<span id="cb199-52"><a href="#cb199-52" aria-hidden="true" tabindex="-1"></a>              <span class="co">//указателя на объект</span></span>
<span id="cb199-53"><a href="#cb199-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-54"><a href="#cb199-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Указатели на виртуальные методы класса</span></span>
<span id="cb199-55"><a href="#cb199-55" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> p1 <span class="op">=</span> <span class="kw">new</span> A<span class="op">;</span></span>
<span id="cb199-56"><a href="#cb199-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(</span>A<span class="op">::*</span>pvf1<span class="op">)()</span> <span class="op">=</span> <span class="op">&amp;</span>A<span class="op">::</span>vf<span class="op">;</span></span>
<span id="cb199-57"><a href="#cb199-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">//такой указатель содержит не адрес </span></span>
<span id="cb199-58"><a href="#cb199-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">//функции, а адрес «заглушки», в которой</span></span>
<span id="cb199-59"><a href="#cb199-59" aria-hidden="true" tabindex="-1"></a>        <span class="co">//а) по полученному адресу из объекта извлекается адрес</span></span>
<span id="cb199-60"><a href="#cb199-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">//б) по индексу, составленному с vf, извлекается из vtab </span></span>
<span id="cb199-61"><a href="#cb199-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">//   адрес метода</span></span>
<span id="cb199-62"><a href="#cb199-62" aria-hidden="true" tabindex="-1"></a>        <span class="co">//в) косвенно вызывается метод</span></span>
<span id="cb199-63"><a href="#cb199-63" aria-hidden="true" tabindex="-1"></a>    p1<span class="op">-&gt;</span>vf<span class="op">();</span></span>
<span id="cb199-64"><a href="#cb199-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>p1<span class="op">-&gt;*</span>pvf1<span class="op">)();</span></span>
<span id="cb199-65"><a href="#cb199-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-66"><a href="#cb199-66" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> p2 <span class="op">=</span> <span class="kw">new</span> B<span class="op">;</span></span>
<span id="cb199-67"><a href="#cb199-67" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(</span>B<span class="op">::*</span>pvf2<span class="op">)()</span> <span class="op">=</span> B<span class="op">::</span>vf<span class="op">;</span><span class="co">//то же самое значение, что и в pvf1</span></span>
<span id="cb199-68"><a href="#cb199-68" aria-hidden="true" tabindex="-1"></a>    p2<span class="op">-&gt;</span>vf<span class="op">();</span></span>
<span id="cb199-69"><a href="#cb199-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>p2<span class="op">-&gt;*</span>pvf1<span class="op">)();</span></span>
<span id="cb199-70"><a href="#cb199-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: так как статический метод класса по сути является глобальной функцией (<a href="#статические-методы">раздел «Статические методы класса»</a>), указатель на статический метод ничем не отличается от указателя на обычную глобальную функцию.</p>
<p>Пример использования:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//оба метода имеют одинаковый вид:</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fl<span class="op">();</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f2<span class="op">();</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true" tabindex="-1"></a>    A ar<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> A<span class="op">(</span><span class="dv">1</span><span class="op">),</span> A<span class="op">(</span><span class="dv">5</span><span class="op">),</span> A<span class="op">(</span><span class="dv">2</span><span class="op">),</span> A<span class="op">(-</span><span class="dv">1</span><span class="op">),</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb200-13"><a href="#cb200-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(</span>A<span class="op">::*</span>pSample<span class="op">)()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//указатель на метод класса А, который</span></span>
<span id="cb200-14"><a href="#cb200-14" aria-hidden="true" tabindex="-1"></a>                              <span class="co">//не принимает параметров и ничего не </span></span>
<span id="cb200-15"><a href="#cb200-15" aria-hidden="true" tabindex="-1"></a>                              <span class="co">//возвращает</span></span>
<span id="cb200-16"><a href="#cb200-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Какой из методов требуется вызвать для каждого элемента массива, </span></span>
<span id="cb200-17"><a href="#cb200-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">//определяю случайным образом во время выполнения:</span></span>
<span id="cb200-18"><a href="#cb200-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>rand<span class="op">()</span> <span class="op">%</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb200-19"><a href="#cb200-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb200-20"><a href="#cb200-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb200-21"><a href="#cb200-21" aria-hidden="true" tabindex="-1"></a>        pSample <span class="op">=</span> A<span class="op">::</span>f1<span class="op">;</span></span>
<span id="cb200-22"><a href="#cb200-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb200-23"><a href="#cb200-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb200-24"><a href="#cb200-24" aria-hidden="true" tabindex="-1"></a>        pSample <span class="op">=</span> A<span class="op">::</span>f2<span class="op">;</span></span>
<span id="cb200-25"><a href="#cb200-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb200-26"><a href="#cb200-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb200-27"><a href="#cb200-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>ar<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>A<span class="op">);</span> i<span class="op">++)</span></span>
<span id="cb200-28"><a href="#cb200-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>ar<span class="op">[</span>i<span class="op">].*</span>pSample<span class="op">)();</span> <span class="co">//вызов метода для каждого элемента</span></span>
<span id="cb200-29"><a href="#cb200-29" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//массива посредством сформированного </span></span>
<span id="cb200-30"><a href="#cb200-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>                           <span class="co">//указателя</span></span></code></pre></div>
<h1 id="тема-vi.-встроенные-объекты-composition.-отношение-между-классами-содержит">Тема VI. Встроенные объекты (composition). Отношение между классами «содержит»</h1>
<h2 id="понятие-встроенного-объекта">Понятие встроенного объекта</h2>
<p>В качестве переменной класса <code>А</code> может фигурировать объект другого класса. <code>B</code> этом случае говорят, что объект класса <code>А</code> <strong>содержит</strong> объект класса <code>B</code>. Или объект класса <code>B</code> <strong>встроен</strong> или <strong>внедрен</strong> в объект класса <code>А</code> Например:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_x</span><span class="op">,</span> <span class="va">m_y</span><span class="op">;</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span> <span class="va">m_x</span> <span class="op">=</span> x<span class="op">;</span> <span class="va">m_y</span> <span class="op">=</span> y<span class="op">;</span> <span class="op">}</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>    Point <span class="va">m_LeftTop</span><span class="op">;</span> <span class="co">//встроенный объект</span></span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a>    Point <span class="va">m_RightBottom</span><span class="op">;</span> <span class="co">//встроенный объект</span></span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb201-14"><a href="#cb201-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="конструирование-и-уничтожение-встроенных-объектов">Конструирование и уничтожение встроенных объектов</h2>
<div class="sourceCode" id="cb202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    Rect r<span class="op">;</span> <span class="co">//создание объекта типа Rect</span></span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Последовательность создания объекта типа выглядит следующим образом:</p>
<ul>
<li><p>компилятор, заранее зная, сколько памяти потребуется для объекта <code>Rect</code> (вместе с внедренными объектами <code>Point</code>), сразу же выделяет соответствующий объем памяти;</p></li>
<li><p>если бы класс Rect был производным, компилятор сначала вызвал бы конструктор базового класса;</p></li>
<li><p>вызываются конструкторы (в нашем случае <strong>по умолчанию)</strong> внедряемых объектов <code>Point</code>. <em>Замечание:</em> члены класса инициализируются в порядке их объявления в классе;</p></li>
<li><p>вызывается конструктор <code>Rect</code> (в нашем случае по <strong>умолчанию).</strong></p></li>
</ul>
<p><em>Замечание:</em> порядок разрушения объекта прямо противоположен порядку его создания. То есть в деструкторе <code>Rect</code> встроенные объекты <code>Point</code> гарантированно еще существуют!</p>
<h2 id="передача-параметров-конструктора-встроенным-объектам.-список-инициализации-конструктора">Передача параметров конструктора встроенным объектам. Список инициализации конструктора</h2>
<p>Так как сначала вызываются конструкторы встроенных объектов, возникает та же проблема, что и при передаче параметров базовому классу. Существуют два способа передать параметры конструктора встроенным объектам:</p>
<ul>
<li><p>присваивание в теле конструктора;</p></li>
<li><p>список инициализации конструктора.</p></li>
</ul>
<p>Отличие:</p>
<table style="width:94%;">
<colgroup>
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>Присваивание в теле конструктора</th>
<th>Список инициализации</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><ol type="1">
<li>Компилятор, заранее зная, сколько памяти потребуется объекта <code>Rect</code> (вместе с внедренными объектами <code>Point</code>), сразу же выделяет соответствующий объем памяти.</li>
</ol></td>
<td>⇒</td>
</tr>
<tr class="even">
<td><ol start="2" type="1">
<li>Вызываются конструкторы <strong>по умолчанию</strong> внедряемых объектов <code>Point</code>.</li>
</ol></td>
<td><ol start="2" type="1">
<li>Вызываются конструкторы внедряемых объектов <code>Point</code> сразу с <strong>указанными параметрами</strong>.</li>
</ol></td>
</tr>
<tr class="odd">
<td><ol start="3" type="1">
<li>Вызывается конструктор Rect. В теле конструктора <strong>уже проинициализированные</strong> внедренные объекты принимают новые значения</li>
</ol></td>
<td><ol start="3" type="1">
<li>Вызывается конструктор <code>Rect</code></li>
</ol></td>
</tr>
</tbody>
</table>
<p>Чтобы при конструировании объекта типа <code>Rect</code> компилятор вызывал конструкторы встроенных объектов сразу с <strong>требуемыми значениями</strong>, нужно использовать специальную запись, аналогичную записи для передачи параметров конструктору базового класса:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>    Point <span class="va">m_LeftTop</span><span class="op">,</span> <span class="va">m_RightBottom</span><span class="op">;</span></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span></code></pre></div>
<table style="width:94%;">
<colgroup>
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>Присваивание в теле конструктора</th>
<th>Список инициализации</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>Rect<span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> pt1<span class="op">,</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">const</span> Point<span class="op">&amp;</span> pt2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a><span class="co">//компилятор вызывает default</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a><span class="co">//конструкторы для встроенных</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a><span class="co">//объектов</span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_LeftTop</span> <span class="op">=</span> pt1<span class="op">;</span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_RightBottom</span> <span class="op">=</span> pt2<span class="op">;</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a><span class="co">//уже проинициализированным пo</span></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a><span class="co">//умолчанию объектам</span></span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a><span class="co">//присваиваются новые значения</span></span>
<span id="cb204-11"><a href="#cb204-11" aria-hidden="true" tabindex="-1"></a><span class="co">//с помощью оператора</span></span>
<span id="cb204-12"><a href="#cb204-12" aria-hidden="true" tabindex="-1"></a><span class="co">//присваивания</span></span>
<span id="cb204-13"><a href="#cb204-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>Rect<span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> pt1<span class="op">,</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">const</span> Point<span class="op">&amp;</span> pt2<span class="op">)</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> <span class="va">m_LeftTop</span><span class="op">(</span>pt1<span class="op">)</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> <span class="va">m_RightBottom</span><span class="op">(</span>pt2<span class="op">)</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//компилятор вызывает для</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">//встроенных объектов</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">//конструкторы копирования и</span></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">//сразу же создает их с</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">//требуемыми значениями</span></span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb206"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>Rect<span class="op">(</span><span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> top<span class="op">,</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>     <span class="dt">int</span> right<span class="op">,</span> <span class="dt">int</span> bottom<span class="op">)</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//компилятор вызывает default</span></span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">//конструкторы для встроенных</span></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">//объектов</span></span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a><span class="va">m_LeftTop</span> <span class="op">=</span> Point<span class="op">(</span>left<span class="op">,</span> top<span class="op">);</span></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a><span class="va">m_RightBottom</span> <span class="op">=</span></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">(</span>right<span class="op">,</span> bottom<span class="op">);</span></span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a><span class="co">//создаются автоматические</span></span>
<span id="cb206-10"><a href="#cb206-10" aria-hidden="true" tabindex="-1"></a><span class="co">//неименованные объекты и уже</span></span>
<span id="cb206-11"><a href="#cb206-11" aria-hidden="true" tabindex="-1"></a><span class="co">//проинициализированным по</span></span>
<span id="cb206-12"><a href="#cb206-12" aria-hidden="true" tabindex="-1"></a><span class="co">//умолчанию встроенным объектам</span></span>
<span id="cb206-13"><a href="#cb206-13" aria-hidden="true" tabindex="-1"></a><span class="co">//присваиваются новые значения</span></span>
<span id="cb206-14"><a href="#cb206-14" aria-hidden="true" tabindex="-1"></a><span class="co">//с помощью оператора</span></span>
<span id="cb206-15"><a href="#cb206-15" aria-hidden="true" tabindex="-1"></a><span class="co">//присваивания</span></span>
<span id="cb206-16"><a href="#cb206-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb207"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>Rect<span class="op">(</span><span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> top<span class="op">,</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>     <span class="dt">int</span> right<span class="op">,</span> <span class="dt">int</span> bottom<span class="op">)</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a><span class="op">:</span> <span class="va">m_LeftTop</span><span class="op">(</span>left<span class="op">,</span> top<span class="op">)</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> <span class="va">m_RightBottom</span><span class="op">(</span>right<span class="op">,</span> bottom<span class="op">)</span></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//компилятор вызывает для</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">//встроенных объектов</span></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">//конструкторы с требуемыми</span></span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">//значениями</span></span>
<span id="cb207-9"><a href="#cb207-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<blockquote>
<p>Рекомендация: предпочитайте инициализацию присваиванию в конструкторах. Это уменьшает накладные расходы на лишний вызов функции.</p>
</blockquote>
<p>Замечания:</p>
<ol type="1">
<li>В приведенном примере реализация метода совмещена с объявлением. Если объявление и реализация метода разнесены, то (как и в случае передачи параметров конструктору базового класса) синтаксическая конструкция «<code>:</code>» может быть указана только при определении метода:</li>
</ol>
<div class="sourceCode" id="cb209"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Файл rect.h</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a>    Rect<span class="op">(</span><span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> top<span class="op">,</span> <span class="dt">int</span> right<span class="op">,</span> <span class="dt">int</span> bottom<span class="op">);</span></span>
<span id="cb209-6"><a href="#cb209-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">//объявление конструктора</span></span>
<span id="cb209-7"><a href="#cb209-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb209-8"><a href="#cb209-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-9"><a href="#cb209-9" aria-hidden="true" tabindex="-1"></a><span class="co">//Файл rect.cpp</span></span>
<span id="cb209-10"><a href="#cb209-10" aria-hidden="true" tabindex="-1"></a><span class="co">//Реализация конструктора:</span></span>
<span id="cb209-11"><a href="#cb209-11" aria-hidden="true" tabindex="-1"></a>Rect<span class="op">::</span>Rect<span class="op">(</span><span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> top<span class="op">,</span> <span class="dt">int</span> right<span class="op">,</span> <span class="dt">int</span> bottom<span class="op">)</span></span>
<span id="cb209-12"><a href="#cb209-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> <span class="va">m_LeftTop</span><span class="op">(</span>left<span class="op">,</span> top<span class="op">),</span> <span class="va">m_RightBottom</span><span class="op">(</span>right<span class="op">,</span> bottom<span class="op">)</span></span>
<span id="cb209-13"><a href="#cb209-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb209-14"><a href="#cb209-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb209-15"><a href="#cb209-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li><p>Если программист явно с помощью списка инициализации не указал компилятору как следует создавать встроенные объекты, то они будут проинициализированы с помощью конструктора по умолчанию.</p></li>
<li><p>Переменные базовых типов можно также инициализировать с помощью списка (они тоже являются встроенными низкоуровневыми «объектами», только базового типа):</p></li>
</ol>
<div class="sourceCode" id="cb210"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a>Point<span class="op">::</span>Point<span class="op">()</span> <span class="op">{</span> m_х <span class="op">=</span> <span class="va">m_y</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span> <span class="co">//так мы поступали с переменными </span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//класса базового типа до сих пор</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//(присваивание в теле </span></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//конструктора)</span></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a>Point<span class="op">::</span>Point<span class="op">(</span><span class="dt">int</span> х<span class="op">,</span> <span class="dt">int</span> у<span class="op">)</span> <span class="op">:</span> <span class="va">m_x</span><span class="op">(</span>x<span class="op">),</span> m_у<span class="op">(</span>у<span class="op">)</span> <span class="co">//а можно и так (список</span></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="op">...</span> <span class="op">}</span>                                     <span class="co">//инициализации)</span></span></code></pre></div>
<p>Если для встроенных объектов пользовательского типа использование списка инициализации дает несомненные преимущества, то для базовых типов особого выигрыша не получается, так как в обоих случаях низкоуровневый код генерируется одинаковый.</p>
<ol start="4" type="1">
<li>Если Вы реализовали конструктор по умолчанию класса <code>Rect</code> следующим образом:</li>
</ol>
<div class="sourceCode" id="cb211"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>Rect<span class="op">::</span>Rect<span class="op">()</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//пустое тело</span></span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>это означает, что Вас устраивает конструирование встроенных объектов с помощью <code>default</code> конструктора класса <code>Point</code>. Но, если Вы хотите создавать объекты класса <code>Rect</code> по умолчанию с другими значениями, то можно использовать список инициализации, например:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a>Rect<span class="op">::</span>Rect<span class="op">()</span> <span class="op">:</span> <span class="va">m_LeftTop</span><span class="op">(</span>l<span class="op">,</span> <span class="dv">1</span><span class="op">),</span> <span class="va">m_RightBottom</span><span class="op">(</span><span class="dv">100</span><span class="op">,</span><span class="dv">100</span><span class="op">)</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="5" type="1">
<li>Если класс, с одной стороны, является производным, а, с другой стороны, содержит встроенные объекты, то требуется передать параметры как конструктору базового класса, так и конструкторам встроенных объектов. Для этого все вызовы указываются в одном списке через запятую в любом порядке (а выполняться будут в строго определенном - сначала конструктор базового класса, а потом конструкторы встроенных объектов в порядке следования их в объявлении класса):</li>
</ol>
<div class="sourceCode" id="cb213"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ColoredRect <span class="op">:</span> <span class="kw">public</span> Rect</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_color</span><span class="op">;</span></span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>    ColoredRect<span class="op">(</span><span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> top<span class="op">,</span> <span class="dt">int</span> right<span class="op">,</span> <span class="dt">int</span> bottom<span class="op">,</span> <span class="dt">int</span> color<span class="op">)</span></span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> Rect<span class="op">(</span>left<span class="op">,</span> top<span class="op">,</span> right<span class="op">,</span> bottom<span class="op">),</span> <span class="va">m_color</span><span class="op">(</span>color<span class="op">)</span></span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb213-8"><a href="#cb213-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb213-9"><a href="#cb213-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb213-10"><a href="#cb213-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="когда-без-списка-инициализации-не-обойтись">Когда без списка инициализации не обойтись</h2>
<p>Для рассмотренных примеров можно было использовать список инициализации конструктора или присваивание в теле конструктора. Выбор влиял только на эффективность. Встречаются случаи, когда программист просто обязан использовать список инициализации. Если членами класса являются:</p>
<ul>
<li><p>константные встроенные объекты,</p></li>
<li><p>ссылки.</p></li>
</ul>
<p>И то, и другое должно быть проинициализировано при создании объекта!</p>
<p>Например:</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> <span class="va">m_n</span><span class="op">;</span></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> <span class="va">m_ref</span><span class="op">;</span></span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;</span> r<span class="op">)</span> <span class="op">:</span> <span class="va">m_n</span><span class="op">(</span>n<span class="op">),</span> <span class="va">m_ref</span><span class="op">(</span>r<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//подумайте: можно ли параметр r передавать по значению???</span></span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a><span class="co">//  А(): m_n(0), m_ref(???) { }; //для default конструктора </span></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//непонятно, как сформировать </span></span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//адрес, которым должна быть </span></span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span>                               <span class="co">//проинициализирована ссылка</span></span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a>    A f<span class="op">(</span><span class="dv">5</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb214-16"><a href="#cb214-16" aria-hidden="true" tabindex="-1"></a><span class="co">//  A f1; //ошибка компилятора — все константы и ссылки должны быть</span></span>
<span id="cb214-17"><a href="#cb214-17" aria-hidden="true" tabindex="-1"></a>          <span class="co">//проинициализированы при создании!!!</span></span>
<span id="cb214-18"><a href="#cb214-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="порядок-инициализации-членов-класса">Порядок инициализации членов класса</h2>
<p>Члены класса инициализируются в том порядке, в котором они указаны в классе, поэтому порядок их следования в списке инициализации не имеет ни малейшего значения! Если программист не знает этого правила, могут возникать нетривиальные ошибки, например:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> <span class="va">m_p</span><span class="op">;</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_n</span><span class="op">;</span></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">:</span> <span class="va">m_n</span><span class="op">(</span>a<span class="op">),</span> <span class="va">m_p</span><span class="op">(</span><span class="kw">new</span> <span class="dt">int</span><span class="op">[</span><span class="va">m_n</span><span class="op">])</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//сначала компилятором будет вызван operator new будет </span></span>
<span id="cb215-8"><a href="#cb215-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//вызван со случайным значением m_n, а потом </span></span>
<span id="cb215-9"><a href="#cb215-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//проинициализирована переменная m_n значением параметра п</span></span>
<span id="cb215-10"><a href="#cb215-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="пример-использования-встроенных-объектов-для-построения-квадратов-посредством-прямоугольников">Пример использования встроенных объектов для построения квадратов посредством прямоугольников</h2>
<p>Замечание: этот прием используется в обобщенных классах стандартной библиотеки при создании классов-адаптеров. Идея заключается в том, что класс-адаптер содержит защищенный объект подходящего типа. Так как объект защищен, весь его <code>public</code> интерфейс извне недоступен. Поэтому пользоваться функциональностью такого встроенного объекта можно только из методов класса-владельца. А владелец реализует свои методы, пользуясь только теми возможностями встроенного объекта и только таким образом, как ему удобно. Например, реализуем класс, абстрагирующий квадрат, посредством встроенного объекта класса прямоугольник:</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">,</span> r<span class="op">,</span> t<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a>    Rect<span class="op">(</span><span class="dt">int</span> xl<span class="op">,</span> <span class="dt">int</span> y1<span class="op">,</span> <span class="dt">int</span> x2<span class="op">,</span> <span class="dt">int</span> y2<span class="op">)</span></span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> xl<span class="op">;</span> r <span class="op">=</span> x2<span class="op">;</span> t <span class="op">=</span> y1<span class="op">;</span> b <span class="op">=</span> y2<span class="op">;</span></span>
<span id="cb216-9"><a href="#cb216-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb216-10"><a href="#cb216-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Inflate<span class="op">(</span><span class="dt">int</span> dl<span class="op">,</span> <span class="dt">int</span> dr<span class="op">,</span> <span class="dt">int</span> dt<span class="op">,</span> <span class="dt">int</span> db<span class="op">)</span></span>
<span id="cb216-11"><a href="#cb216-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb216-12"><a href="#cb216-12" aria-hidden="true" tabindex="-1"></a>        l <span class="op">-=</span> dl<span class="op">;</span> r <span class="op">+=</span> dr<span class="op">;</span> t <span class="op">-=</span> dt<span class="op">;</span> b <span class="op">+=</span> db<span class="op">;</span></span>
<span id="cb216-13"><a href="#cb216-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb216-14"><a href="#cb216-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb216-15"><a href="#cb216-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Square</span>
<span id="cb216-16"><a href="#cb216-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb216-17"><a href="#cb216-17" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb216-18"><a href="#cb216-18" aria-hidden="true" tabindex="-1"></a>    Rect <span class="va">m_r</span><span class="op">;</span></span>
<span id="cb216-19"><a href="#cb216-19" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb216-20"><a href="#cb216-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Inflate<span class="op">(</span><span class="dt">int</span> d<span class="op">)</span> <span class="op">{</span> <span class="va">m_r</span><span class="op">.</span>Inflate<span class="op">(</span>d<span class="op">,</span> d<span class="op">,</span> d<span class="op">,</span> d<span class="op">);</span> <span class="op">}</span></span>
<span id="cb216-21"><a href="#cb216-21" aria-hidden="true" tabindex="-1"></a>    Square<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> <span class="dt">int</span> d<span class="op">)</span> <span class="op">:</span> <span class="va">m_r</span><span class="op">(</span>x<span class="op">,</span> y<span class="op">,</span> x <span class="op">+</span> d<span class="op">,</span> y <span class="op">+</span> d<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb216-22"><a href="#cb216-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb216-23"><a href="#cb216-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb216-24"><a href="#cb216-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb216-25"><a href="#cb216-25" aria-hidden="true" tabindex="-1"></a>    Square s<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb216-26"><a href="#cb216-26" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>Inflate<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb216-27"><a href="#cb216-27" aria-hidden="true" tabindex="-1"></a><span class="co">//  s.m_r.Inflate(1, 2, 3,4); //ошибка доступа</span></span>
<span id="cb216-28"><a href="#cb216-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="пример-использования-встроенных-объектов-ассоциативный-массив">Пример использования встроенных объектов «ассоциативный массив»</h2>
<p>Ассоциативным массивом называется массив, в котором хранятся пары ключ/значение. Поиск значения происходит по ключу. В приведенном примере рассматривается не полноценный ассоциативный массив, а, пожалуй, первое приближение к его настоящей реализации. Реализуем «записную книжку», в которой будут храниться пары имя/телефон.</p>
<p>В реализуемом ассоциативном массиве введем ограничение — ключ должен быть уникальным, то есть двух одинаковых имен быть не может.</p>
<p>Замечание: так как речь пойдет о массиве (не имеет значения его внутренняя реализация), то очевидно потребуется перегрузка оператора <code>[]</code>. Если для обычных массивов индекс может быть только целым значением, то перегруженный оператор <code>[]</code> может принимать параметр любого типа.</p>
<p>Пусть ассоциативный массив содержит пары: имя, номер телефона:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">size_t</span> KEY <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Pair</span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//вспомогательный класс для хранения пар ключ/значение</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> name<span class="op">[</span>KEY<span class="op">];</span> <span class="co">//имя</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> phone<span class="op">;</span> <span class="co">//номер телефона</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a>    Pair<span class="op">()</span></span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a>        name<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//пустая строка</span></span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a>        phone <span class="op">=</span> <span class="dv">911</span><span class="op">;</span></span>
<span id="cb217-10"><a href="#cb217-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-11"><a href="#cb217-11" aria-hidden="true" tabindex="-1"></a>    Pair<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> key<span class="op">,</span> <span class="dt">int</span> data<span class="op">)</span></span>
<span id="cb217-12"><a href="#cb217-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-13"><a href="#cb217-13" aria-hidden="true" tabindex="-1"></a>        strncpy<span class="op">(</span>name<span class="op">,</span> key<span class="op">,</span> KEY <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb217-14"><a href="#cb217-14" aria-hidden="true" tabindex="-1"></a>        name<span class="op">[</span>KEY <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//если в строке key символов больше,</span></span>
<span id="cb217-15"><a href="#cb217-15" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//чем KEY</span></span>
<span id="cb217-16"><a href="#cb217-16" aria-hidden="true" tabindex="-1"></a>        phone <span class="op">=</span> data<span class="op">;</span></span>
<span id="cb217-17"><a href="#cb217-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-18"><a href="#cb217-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> k<span class="op">)</span></span>
<span id="cb217-19"><a href="#cb217-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-20"><a href="#cb217-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> strncmp<span class="op">(</span>name<span class="op">,</span> k<span class="op">,</span> KEY<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb217-21"><a href="#cb217-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-22"><a href="#cb217-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="kw">class</span> Book<span class="op">;</span></span>
<span id="cb217-23"><a href="#cb217-23" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb217-24"><a href="#cb217-24" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> NUM <span class="op">=</span> <span class="dv">10</span><span class="op">;</span><span class="co">//пусть в записной книжке не может быть</span></span>
<span id="cb217-25"><a href="#cb217-25" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//больше NUM записей</span></span></code></pre></div>
<p><code>Book</code> — основной класс, абстрагирующий записную книжку. Это не совсем обычный массив, для которого справедлив произвольный доступ. Специфика такого «массива» заключается в том, что чтение и запись в массив осуществляются по-разному, поэтому реализуются эти две операции посредством двух разных методов. Добавляются элементы в такой массив «на свободное место», а при считывании из массива по указанному ключу ищется значение.</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>    Pair ar<span class="op">[</span>NUM<span class="op">];</span> <span class="co">//для упрощения введем встроенный массив</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_n</span><span class="op">;</span><span class="co">//индекс первого свободного в массиве</span></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">//(или количество записей)</span></span>
<span id="cb218-6"><a href="#cb218-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb218-7"><a href="#cb218-7" aria-hidden="true" tabindex="-1"></a>    Book<span class="op">()</span> <span class="op">{</span> <span class="va">m_n</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb218-8"><a href="#cb218-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb218-9"><a href="#cb218-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> key<span class="op">)</span></span>
<span id="cb218-10"><a href="#cb218-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb218-11"><a href="#cb218-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">m_n</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb218-12"><a href="#cb218-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb218-13"><a href="#cb218-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>ar<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> key<span class="op">)</span> <span class="co">//???</span></span>
<span id="cb218-14"><a href="#cb218-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> ar<span class="op">[</span>i<span class="op">].</span>phone<span class="op">;</span></span>
<span id="cb218-15"><a href="#cb218-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb218-16"><a href="#cb218-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">m_n</span> <span class="op">&lt;</span> NUM<span class="op">)</span></span>
<span id="cb218-17"><a href="#cb218-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb218-18"><a href="#cb218-18" aria-hidden="true" tabindex="-1"></a>            strncpy<span class="op">(</span>ar<span class="op">[</span><span class="va">m_n</span><span class="op">].</span>name<span class="op">,</span> key<span class="op">,</span> KEY <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb218-19"><a href="#cb218-19" aria-hidden="true" tabindex="-1"></a>            ar<span class="op">[</span><span class="va">m_n</span><span class="op">].</span>name<span class="op">[</span>KEY <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb218-20"><a href="#cb218-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> ar<span class="op">[</span><span class="va">m_n</span><span class="op">++].</span>phone<span class="op">;</span></span>
<span id="cb218-21"><a href="#cb218-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;full!&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb218-22"><a href="#cb218-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb218-23"><a href="#cb218-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb218-24"><a href="#cb218-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb218-25"><a href="#cb218-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb218-26"><a href="#cb218-26" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb218-27"><a href="#cb218-27" aria-hidden="true" tabindex="-1"></a>    Book b<span class="op">;</span> <span class="co">//создаем пустую записную книжку</span></span>
<span id="cb218-28"><a href="#cb218-28" aria-hidden="true" tabindex="-1"></a>    b<span class="op">[</span><span class="st">&quot;Marina&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1111111</span><span class="op">;</span></span>
<span id="cb218-29"><a href="#cb218-29" aria-hidden="true" tabindex="-1"></a>    b<span class="op">[</span><span class="st">&quot;Аlех&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2222222</span><span class="op">;</span></span>
<span id="cb218-30"><a href="#cb218-30" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> b<span class="op">[</span><span class="st">&quot;Marina&quot;</span><span class="op">];</span> <span class="co">//будет выведено 1111111</span></span>
<span id="cb218-31"><a href="#cb218-31" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> b<span class="op">[</span><span class="st">&quot;Boris&quot;</span><span class="op">];</span> <span class="co">//что будет выведено и почему???</span></span>
<span id="cb218-32"><a href="#cb218-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="указатели-на-объекты-в-качестве-членов-данных-класса">Указатели на объекты в качестве членов данных класса</h2>
<p>В качестве переменной класса может фигурировать указатель на объект другого класса.</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Y</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>    X<span class="op">*</span> <span class="va">m_pX</span><span class="op">;</span> <span class="co">//переменная класса Y, которая является указателем на </span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a>             <span class="co">//объект типа X или массив объектов типа X. При </span></span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>             <span class="co">//создании экземпляра класса X компилятор выделяет </span></span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>             <span class="co">//память под указатель m_рХ, который будет </span></span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>             <span class="co">//инициализирован (или не инициализирован) по общим </span></span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a>             <span class="co">//правилам.</span></span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 1: как только в классе появляется указатель — скорее всего, будет динамически выделяться память, поэтому Ваша задача заключается в <strong>обеспечении корректного значения этого указателя!!!</strong> ⇒ в таком классе должны быть предусмотрены корректно peaлизованные:</p>
<ul>
<li><p>default constructor — <code class="sourceCode cpp">Y<span class="op">(){</span> <span class="va">m_pX</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></code> — вовремя обнуленный указатель избавит Вас от мучительных поисков ошибок, возникающих при случайном использовании неинициализированного указателя!</p></li>
<li><p>деструктор — <code class="sourceCode cpp"><span class="op">~</span>Y<span class="op">(){</span> <span class="kw">delete</span> <span class="op">[]</span> <span class="va">m_pX</span><span class="op">;</span> <span class="op">}</span></code> и при необходимости он должен быть объявлен <code>virtual</code>. (С нулевым указателем <code>delete</code> будет работать корректно, но трудно сказать, какие неприятности Вас ожидают в случае «случайного» значения <code>m_pХ</code>)</p></li>
<li><p>конструктор копирования</p></li>
<li><p>оператор присваивания</p></li>
</ul>
<p>Замечание 2: часто в качестве члена данных класса <code>X</code> фигурирует указатель типа <code>X*</code> (на объект того же типа). Это позволяет создавать сложные структуры данных типа списков и деревьев</p>
<h2 id="ссылки-на-указатели">Ссылки на указатели</h2>
<p>Это прием часто используется для того, чтобы вместо пары функций - <code>Set</code>/<code>Get</code> для получения и присваивания нового значения члену класса — указателю. Особенно этот прием удобен при работе со списками:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pPrevious<span class="op">;</span> <span class="co">//указатель на предыдущий элемент</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pNext<span class="op">;</span> <span class="co">//указатель на следующий элемент</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*&amp;</span> Next<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> pNext<span class="op">;</span> <span class="op">}</span></span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//возвращаемая ссылка на указатель фактически является </span></span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//замаскированным двойным указателем =&gt; эту функцию можно </span></span>
<span id="cb220-9"><a href="#cb220-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//использовать как справа, так и слева от «=» (читать/писать)</span></span>
<span id="cb220-10"><a href="#cb220-10" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*&amp;</span> Previous<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> pPrevious<span class="op">;</span> <span class="op">}</span></span>
<span id="cb220-11"><a href="#cb220-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb220-12"><a href="#cb220-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb220-13"><a href="#cb220-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb220-14"><a href="#cb220-14" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">,</span> a1<span class="op">;</span></span>
<span id="cb220-15"><a href="#cb220-15" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> p <span class="op">=</span> a<span class="op">.</span>Next<span class="op">();</span> <span class="co">//в правой части присвоения</span></span>
<span id="cb220-16"><a href="#cb220-16" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>Previous<span class="op">()</span> <span class="op">=</span> <span class="op">&amp;</span>a1<span class="op">;</span> <span class="co">//в левой части присваивания иначе ошибка</span></span>
<span id="cb220-17"><a href="#cb220-17" aria-hidden="true" tabindex="-1"></a>                        <span class="co">//компилятора «left operand = must be lvalue»</span></span>
<span id="cb220-18"><a href="#cb220-18" aria-hidden="true" tabindex="-1"></a>    A a2 <span class="op">=</span> <span class="op">*(</span>a<span class="op">.</span>Next<span class="op">());</span> <span class="co">//в правой части присваивания</span></span>
<span id="cb220-19"><a href="#cb220-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Иногда объявлению вида <code>А*&amp; Next();</code> соответствует объявление — <code>А* Next() const</code>. Второй вариант позволяет использовать функцию <code>Next()</code> (в правой части оператора присвоения) с <code>const</code>-указателями на объекты <code>А</code>.</p>
<p>Например:</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> А а<span class="dv">2</span><span class="op">;</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>А<span class="op">*</span> рА <span class="op">=</span> a2<span class="op">.</span>Next<span class="op">();</span> <span class="co">//если бы не было второго объявления, здесь</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//компилятор выдал бы ошибку!</span></span></code></pre></div>
<h2 id="объектно-ориентированный-двухсвязный-список-однородный.-вложенные-объявления-классов">Объектно-ориентированный двухсвязный список (однородный). Вложенные объявления классов</h2>
<p>Обычно список реализуется посредством вспомогательного класса-обертки. Каждый объект такого класса-обертки содержит собственно данное и дополнительную служебную информацию (связи с соседними элементами).</p>
<p>Замечание: если хранящиеся данные одного и того же типа (список однородный), то эффективнее хранить эти данные как встроенные объекты. Если же требуется объединить объекты разных производных классов (с общим базовым классом), то единственной возможностью является хранение в «обертке» указателя базового типа (а сами объекты должны быть созданы динамически).</p>
<p><img src="media/image34.svg" /></p>
<p><img src="media/image33.svg" /></p>
<div class="sourceCode" id="cb222"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="co">//list.h</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List</span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Node <span class="co">//вложенное объявление вспомогательного класса. Так </span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>               <span class="co">//как класс Node вспомогательный, то все его члены </span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>          <span class="co">//защищены — private</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="kw">class</span> List<span class="op">;</span> <span class="co">//даю права всем методам класса List </span></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//пользоваться любыми членами класса Node</span></span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a>        Node<span class="op">*</span> pPrev<span class="op">;</span> <span class="co">//указатель на предыдущий элемент</span></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a>        Node<span class="op">*</span> pNext<span class="op">;</span> <span class="co">//указатель на следующий элемент</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a>        Point <span class="va">m_data</span><span class="op">;</span> <span class="co">//данные</span></span>
<span id="cb222-12"><a href="#cb222-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>Node<span class="op">();</span></span>
<span id="cb222-13"><a href="#cb222-13" aria-hidden="true" tabindex="-1"></a>        Node<span class="op">(</span>Node<span class="op">*</span> р<span class="op">,</span> Node<span class="op">*</span> n<span class="op">,</span> <span class="at">const</span> Point<span class="op">*);</span> <span class="co">//конструктор</span></span>
<span id="cb222-14"><a href="#cb222-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb222-15"><a href="#cb222-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Данные класса List. Замечание: списки реализуют по-разному. В </span></span>
<span id="cb222-16"><a href="#cb222-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">//качестве данных можно хранить количество элементов, указатель </span></span>
<span id="cb222-17"><a href="#cb222-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">//на последний элемент в списке...</span></span>
<span id="cb222-18"><a href="#cb222-18" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">*</span> pHead<span class="op">;</span> <span class="co">//для примера мы ограничимся одним- единственным </span></span>
<span id="cb222-19"><a href="#cb222-19" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//данным — указателем на начало списка</span></span>
<span id="cb222-20"><a href="#cb222-20" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb222-21"><a href="#cb222-21" aria-hidden="true" tabindex="-1"></a>    List<span class="op">()</span> <span class="op">{</span> pHead <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb222-22"><a href="#cb222-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>List<span class="op">();</span></span>
<span id="cb222-23"><a href="#cb222-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> Size<span class="op">();</span></span>
<span id="cb222-24"><a href="#cb222-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> AddToHead<span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;);</span> <span class="co">//добавить в начало списка</span></span>
<span id="cb222-25"><a href="#cb222-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> Remove<span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;);</span> <span class="co">//исключить из списка первый элемент,</span></span>
<span id="cb222-26"><a href="#cb222-26" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//значение которого совпадает с </span></span>
<span id="cb222-27"><a href="#cb222-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span>                             <span class="co">//параметром</span></span></code></pre></div>
<div class="sourceCode" id="cb223"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;list.h&quot;</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a>List<span class="op">::</span>Node<span class="op">::~</span>Node<span class="op">()</span><span class="co">//класс тоже является областью видимости</span></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//Наш деструктор умеет исключать удаляемый элемент из списка</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Коррекция следующего</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pNext <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> pNext<span class="op">-&gt;</span>pPrev <span class="op">=</span> pPrev<span class="op">;</span></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Коррекция предыдущего</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pPrev <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> pPrev<span class="op">-&gt;</span>pNext <span class="op">=</span> pNext<span class="op">;</span></span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>List<span class="op">::</span>Node<span class="op">::</span>Node<span class="op">(</span>Node<span class="op">*</span> p<span class="op">,</span> Node<span class="op">*</span> n<span class="op">,</span> <span class="at">const</span> Point<span class="op">*</span> d<span class="op">)</span> <span class="op">:</span></span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_data</span><span class="op">(*</span>d<span class="op">)</span><span class="co">//встроенный объект будет копией параметра</span></span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//Наш конструктор умеет создавать очередной узел и подкачать его в</span></span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">//список, а так как создавать объекты сможет только класс List, то </span></span>
<span id="cb223-13"><a href="#cb223-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">//есть гарантия, что указатели р и n указывают на два соседних </span></span>
<span id="cb223-14"><a href="#cb223-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">//узла списка.</span></span>
<span id="cb223-15"><a href="#cb223-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">//В текущем элементе установили указатели на его соседей</span></span>
<span id="cb223-16"><a href="#cb223-16" aria-hidden="true" tabindex="-1"></a>    pPrev <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb223-17"><a href="#cb223-17" aria-hidden="true" tabindex="-1"></a>    pNext <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb223-18"><a href="#cb223-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Если существует следующий — скорректировали у него</span></span>
<span id="cb223-19"><a href="#cb223-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">//указатель на предыдущий</span></span>
<span id="cb223-20"><a href="#cb223-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> n<span class="op">-&gt;</span>pPrev <span class="op">=</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb223-21"><a href="#cb223-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Если существует предыдущий — скорректировали у него указатель</span></span>
<span id="cb223-22"><a href="#cb223-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">//на следующий</span></span>
<span id="cb223-23"><a href="#cb223-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>p <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> p<span class="op">-&gt;</span>pNext <span class="op">=</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb223-24"><a href="#cb223-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb223-25"><a href="#cb223-25" aria-hidden="true" tabindex="-1"></a>List<span class="op">::~</span>List<span class="op">()</span> <span class="co">//деструктор списка должен обеспечить освобождение</span></span>
<span id="cb223-26"><a href="#cb223-26" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>             <span class="co">//динамически захваченной памяти</span></span>
<span id="cb223-27"><a href="#cb223-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>pHead <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb223-28"><a href="#cb223-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb223-29"><a href="#cb223-29" aria-hidden="true" tabindex="-1"></a>        Node<span class="op">*</span> р <span class="op">=</span> pHead<span class="op">;</span> <span class="co">//указатель на уничтожаемый Node</span></span>
<span id="cb223-30"><a href="#cb223-30" aria-hidden="true" tabindex="-1"></a>        pHead <span class="op">=</span> pHead<span class="op">-&gt;</span>pNext<span class="op">;</span><span class="co">//устанавливаем на следующий</span></span>
<span id="cb223-31"><a href="#cb223-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> р<span class="op">;</span> <span class="co">//удаляем предыдущий</span></span>
<span id="cb223-32"><a href="#cb223-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb223-33"><a href="#cb223-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb223-34"><a href="#cb223-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> List<span class="op">::</span>Size<span class="op">()</span></span>
<span id="cb223-35"><a href="#cb223-35" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb223-36"><a href="#cb223-36" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">*</span> p <span class="op">=</span> pHead<span class="op">;</span></span>
<span id="cb223-37"><a href="#cb223-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb223-38"><a href="#cb223-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>p <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb223-39"><a href="#cb223-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb223-40"><a href="#cb223-40" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> p<span class="op">-&gt;</span>pNext<span class="op">;</span></span>
<span id="cb223-41"><a href="#cb223-41" aria-hidden="true" tabindex="-1"></a>        n<span class="op">++;</span></span>
<span id="cb223-42"><a href="#cb223-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb223-43"><a href="#cb223-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb223-44"><a href="#cb223-44" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> List<span class="op">::</span>AddToHead<span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> o<span class="op">)</span> <span class="co">//добавить в начало списка</span></span>
<span id="cb223-45"><a href="#cb223-45" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb223-46"><a href="#cb223-46" aria-hidden="true" tabindex="-1"></a>    pHead <span class="op">=</span> <span class="kw">new</span> Node<span class="op">(</span><span class="dv">0</span><span class="op">,</span> pHead<span class="op">,</span> <span class="op">&amp;</span>o<span class="op">);</span></span>
<span id="cb223-47"><a href="#cb223-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb223-48"><a href="#cb223-48" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> List<span class="op">::</span>Remove<span class="op">(</span><span class="at">const</span> Point<span class="op">&amp;</span> ref<span class="op">)</span><span class="co">//если такой был найден и удален</span></span>
<span id="cb223-49"><a href="#cb223-49" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//— true, если такого в списке не </span></span>
<span id="cb223-50"><a href="#cb223-50" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>                                  <span class="co">//было — false</span></span>
<span id="cb223-51"><a href="#cb223-51" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">*</span> р <span class="op">=</span> pHead<span class="op">;</span></span>
<span id="cb223-52"><a href="#cb223-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> Size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="cb223-53"><a href="#cb223-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb223-54"><a href="#cb223-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>ref <span class="op">==</span> p<span class="op">-&gt;</span><span class="va">m_data</span><span class="op">)</span> <span class="co">//в классе Point должен быть</span></span>
<span id="cb223-55"><a href="#cb223-55" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span>                     <span class="co">//перегружен operator==</span></span>
<span id="cb223-56"><a href="#cb223-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>p <span class="op">==</span> pHead<span class="op">)</span> pHead <span class="op">=</span> pHead<span class="op">-&gt;</span>pNext<span class="op">;</span></span>
<span id="cb223-57"><a href="#cb223-57" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span> p<span class="op">;</span></span>
<span id="cb223-58"><a href="#cb223-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb223-59"><a href="#cb223-59" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb223-60"><a href="#cb223-60" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> p<span class="op">-&gt;</span>pNext<span class="op">;</span></span>
<span id="cb223-61"><a href="#cb223-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb223-62"><a href="#cb223-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb223-63"><a href="#cb223-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 1: мы реализовали далеко не все операции для работы со списком. Подумайте, что еще обязательно требуется реализовать для такого сложного класса.</p>
<p>Замечание 2: реализаций двухсвязных списков много. Полезным приемом является реализация списка с помощью фиктивных элементов (<code>Node</code>) — «стражей». Именно такую реализацию требуется разработать в лабораторной работе.</p>
<h2 id="специфика-использования-безразмерных-массивов">Специфика использования безразмерных массивов</h2>
<p>Безразмерные массивы (unsized arrays) — это специфическая особенность компилятора Microsoft. Используются только как члены данных классов и структур при соблюдении следующих ограничений:</p>
<ul>
<li><p>безразмерный массив может быть только последним членом данных.</p></li>
<li><p>такой класс не может быть базовым для другого класса</p></li>
<li><p>если объект такого класса встраивается в другой класс, он тоже должен быть последним</p></li>
<li><p>не может иметь виртуального базового класса</p></li>
<li><p>оператор <code>sizeof</code>, примененный к такому классу, возвращает количество байт без учета безразмерного массива</p></li>
<li><p>нельзя создавать массивы объектов такого класса</p></li>
</ul>
<p>Например:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="va">m_n</span><span class="op">;</span> <span class="co">//количество элементов в массиве</span></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="va">m_ar</span><span class="op">[];</span> <span class="co">//безразмерный массив</span></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> p<span class="op">)</span></span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_n</span> <span class="op">=</span> n<span class="op">;</span> strcpy<span class="op">(</span><span class="va">m_ar</span><span class="op">,</span> p<span class="op">);</span></span>
<span id="cb224-9"><a href="#cb224-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb224-10"><a href="#cb224-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Замечание: при создании объектов такого типа тоже следует помнить, что компилятор не знает, сколько памяти требуется выделить для такого массива, поэтому по умолчанию сам ничего не выделяет.</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//так нельзя!</span></span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a>    A а<span class="op">;</span> <span class="co">//для массива память не выделена</span></span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>а<span class="op">);</span> <span class="co">//4</span></span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//по списку инициализаторов компилятор может посчитать, сколько</span></span>
<span id="cb225-7"><a href="#cb225-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//требуется выделить памяти, но для того, чтобы использовать </span></span>
<span id="cb225-8"><a href="#cb225-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//список инициализаторов, все данные должны быть public</span></span>
<span id="cb225-9"><a href="#cb225-9" aria-hidden="true" tabindex="-1"></a><span class="co">//  A al= { sizeof(&quot;ABC&quot;), ABC&quot; }; //ошибка компилятора, так как </span></span>
<span id="cb225-10"><a href="#cb225-10" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">//данные защищены</span></span>
<span id="cb225-11"><a href="#cb225-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//можно явно выделить требуемый объем памяти динамически:</span></span>
<span id="cb225-12"><a href="#cb225-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> ar<span class="op">[</span><span class="dv">80</span><span class="op">];</span></span>
<span id="cb225-13"><a href="#cb225-13" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> ar<span class="op">;</span></span>
<span id="cb225-14"><a href="#cb225-14" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pa <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>A<span class="op">*&gt;</span> <span class="op">(</span></span>
<span id="cb225-15"><a href="#cb225-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> <span class="dt">char</span><span class="op">[</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">+</span> strlen<span class="op">(</span>ar<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">]</span></span>
<span id="cb225-16"><a href="#cb225-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb225-17"><a href="#cb225-17" aria-hidden="true" tabindex="-1"></a>    pa<span class="op">-&gt;</span>set<span class="op">(</span>strlen<span class="op">(</span>ar<span class="op">),</span> ar<span class="op">);</span></span>
<span id="cb225-18"><a href="#cb225-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="предварительное-неполное-объявление-класса-forward-declaration">Предварительное неполное объявление класса (forward declaration)</h2>
<p>На момент использования любого идентификатора компилятор должен знать его свойства, то есть в том месте текста Вашей программы, где компилятор встречает Ваш пользовательский тип, он уже должен «видеть» его объявление. Но иногда встречаются такие ситуации, когда классы «ссылаются» друг на друга:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//объявление класса A</span></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> рВ<span class="op">;</span> <span class="co">//на этот момент времени компилятор должен знать</span></span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true" tabindex="-1"></a>           <span class="co">//свойства B</span></span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb226-6"><a href="#cb226-6" aria-hidden="true" tabindex="-1"></a>    B Func<span class="op">(</span>B<span class="op">&amp;);</span> <span class="co">//аналогично</span></span>
<span id="cb226-7"><a href="#cb226-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb226-8"><a href="#cb226-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B</span>
<span id="cb226-9"><a href="#cb226-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="co">//объявление класса B</span></span>
<span id="cb226-10"><a href="#cb226-10" aria-hidden="true" tabindex="-1"></a>    A а<span class="op">;</span> <span class="co">//а на этот момент времени компилятор должен знать</span></span>
<span id="cb226-11"><a href="#cb226-11" aria-hidden="true" tabindex="-1"></a>         <span class="co">//свойства A</span></span>
<span id="cb226-12"><a href="#cb226-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb226-13"><a href="#cb226-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>В такой ситуации как бы Вы не переставляли местами объявления, компилятор будет выдавать ошибки. Для разрешения таких взаимных зависимостей можно (а иногда и необходимо) указать компилятору, что используемый идентификатор является именем класса, а его объявление компилятор встретит чуть позже. Этот прием называется предварительным неполным объявлением класса. Выручает он не во всех случаях, а только тогда, когда компилятору достаточно знать, что используемое имя — это имя класса:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> В<span class="op">;</span> <span class="co">//предварительное неполное объявление</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> А</span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true" tabindex="-1"></a>    В<span class="op">*</span> pB<span class="op">;</span> <span class="co">//ОК — компилятор знает, сколько отвести памяти под </span></span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true" tabindex="-1"></a>           <span class="co">//указатель, а все остальное можно отложить до </span></span>
<span id="cb227-6"><a href="#cb227-6" aria-hidden="true" tabindex="-1"></a>           <span class="co">//конкретного обращения к этому указателю</span></span>
<span id="cb227-7"><a href="#cb227-7" aria-hidden="true" tabindex="-1"></a>    В Func<span class="op">(</span>B<span class="op">);</span> <span class="co">//ОК</span></span>
<span id="cb227-8"><a href="#cb227-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//В b; //ошибка, так как компилятор должен знать сколько </span></span>
<span id="cb227-9"><a href="#cb227-9" aria-hidden="true" tabindex="-1"></a>           <span class="co">//зарезервировать памяти</span></span>
<span id="cb227-10"><a href="#cb227-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb227-11"><a href="#cb227-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> В <span class="op">{</span> <span class="op">...</span> А а<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<h1 id="тема-vii.-статические-члены-класса">Тема VII. Статические члены класса</h1>
<h2 id="статические-данные">Статические данные</h2>
<p>Часто возникает следующая ситуация: все объекты класса оперируют с одним и тем же, единственным для всех экземпляров, глобальным данным (<strong>данные, которые характеризуют количество или взаимосвязь всех существующих на данный момент объектов данного типа</strong>). То есть появляются переменные, которые имеют отношение к классу в целом, но не входят (не являются частью) в каждый объект данного класса. Для таких данных вводится понятие и ключевое слово <code>static</code>.</p>
<p>Специфика:</p>
<ul>
<li><p>статические переменные класса</p>
<ol type="a">
<li><strong>размещаются в статической области памяти</strong> на стадии компоновки (когда еще не создано ни одного экземпляра класса!) независимо от того, где создается сам объект.</li>
<li><strong>существуют в единственном экземпляре</strong> (то есть компоновщик выделяет под нее память только один раз!) независимо от того, сколько создано экземпляров данного класса. Это означает, что для переменных класса с ключевым словом static при создании экземпляра класса компилятор место не резервирует!</li>
</ol>
<div class="sourceCode" id="cb228"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Х</span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m_х<span class="op">;</span> <span class="co">//обычная переменная класса (в каждом объекте</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a>             <span class="co">//типа X компилятор отводит под такую переменную </span></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a>             <span class="co">//память в объекте)</span></span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">size_t</span> count<span class="op">;</span> <span class="co">//статическая переменная (в объекте</span></span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//память под такую переменную не </span></span>
<span id="cb228-8"><a href="#cb228-8" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//резервируется!)</span></span>
<span id="cb228-9"><a href="#cb228-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb228-10"><a href="#cb228-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb228-11"><a href="#cb228-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>Статическую переменную класса необходимо определить следующим образом (вне функций и тем более вне объявления класса — как глобальные переменные) для того, чтобы компилятор отвел под эту переменную место в статической памяти:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Х.срр</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> X<span class="op">::</span>nCount<span class="op">;</span> <span class="co">//объявление и инициализация статической</span></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//переменной nCount класса X нулем по </span></span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//умолчанию.</span></span></code></pre></div></li>
<li><p>Определяется и инициализируется статическая переменная одинаково — независимо от спецификатора доступа:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> X<span class="op">::</span>nCount <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div></li>
<li><p>Обращение «извне». Статическая переменная класса по сути является глобальной, заключенной в пространство имен (имя класса), поэтому к public статической переменной можно обращаться посредством <code>cout &lt;&lt; X::nCount</code>.</p>
<p>С другой стороны, формально статическая переменная является членом класса поэтому ничто не мешает обращаться к ней посредством объекта: <code>cout &lt;&lt; x.nCount &lt;&lt; pX-&gt;nCount;</code>.</p></li>
<li><p>Обращение к статической переменной внутри методов класса для программиста — ничем не отличается от обращения к обычной переменной класса, для компилятора — подставляет адрес статической переменной, а не вычисляет база + смещение</p></li>
<li><p>Следствие: статические члены класса никогда не должны инициализироваться в конструкторе!</p></li>
</ul>
<p>Для примера рассмотрим класс, который автоматически «контролирует» количество объектов данного типа, существующих на данный момент выполнения программы. Для решения этой задачи заведем статическую переменную-счетчик и предусмотрим модификацию этой переменной при создании нового объекта и при удалении существующего:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X</span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m_х<span class="op">;</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> nCount<span class="op">;</span> <span class="co">//счетчик объектов типа X.</span></span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a>    X<span class="op">()</span> <span class="op">{</span> m_х <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> nCount<span class="op">++;</span> <span class="op">}</span></span>
<span id="cb231-7"><a href="#cb231-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> <span class="co">//подумайте: какие еще методы требуется реализовать?</span></span>
<span id="cb231-8"><a href="#cb231-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>X<span class="op">()</span> <span class="op">{</span> nCount<span class="op">--;</span> <span class="op">}</span></span>
<span id="cb231-9"><a href="#cb231-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb231-10"><a href="#cb231-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb231-11"><a href="#cb231-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb231-12"><a href="#cb231-12" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> X<span class="op">::</span>nCount<span class="op">;</span> <span class="co">//???</span></span>
<span id="cb231-13"><a href="#cb231-13" aria-hidden="true" tabindex="-1"></a>    X x1<span class="op">;</span></span>
<span id="cb231-14"><a href="#cb231-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>x1<span class="op">);</span> <span class="co">//???</span></span>
<span id="cb231-15"><a href="#cb231-15" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> x1<span class="op">.</span>nCount<span class="op">;</span> <span class="co">//???</span></span>
<span id="cb231-16"><a href="#cb231-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb231-17"><a href="#cb231-17" aria-hidden="true" tabindex="-1"></a>        X x2 <span class="op">=</span> x1<span class="op">;</span></span>
<span id="cb231-18"><a href="#cb231-18" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> x2<span class="op">.</span>nCount<span class="op">;</span> <span class="co">//???</span></span>
<span id="cb231-19"><a href="#cb231-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb231-20"><a href="#cb231-20" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> X<span class="op">::</span>nCount<span class="op">;</span> <span class="co">//???</span></span>
<span id="cb231-21"><a href="#cb231-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 1: в отличие от нестатических переменных:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">;</span> <span class="co">//ошибка — использование неопределенного класса A</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>В объявлении класса можно использовать встроенные статические данные того же типа. Например, таким образом можно задать <code>default</code> значение (одинаковое для всех экземпляров класса):</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> A <span class="cf">default</span><span class="op">;</span> <span class="co">//ОК</span></span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><code>.срр</code>:</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>A A<span class="op">::</span><span class="cf">default</span><span class="op">(</span><span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>Такое <code>default</code> значение можно изменить в процессе выполнения, а значения параметров по умолчанию — нет!</p>
<p>Замечание 2: статические константы целого типа можно проинициализировать непосредственно в объявлении класса:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="at">static</span> <span class="dt">int</span> n <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">//это простая константа, вместо которой </span></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//компилятор будет просто подставлять </span></span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//значение. Область видимости такой </span></span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//константы ограничена классом</span></span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> count<span class="op">;</span><span class="co">//=1; — ошибка</span></span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb235-10"><a href="#cb235-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> A<span class="op">::</span>count<span class="op">;</span> <span class="co">//обязательно!</span></span>
<span id="cb235-11"><a href="#cb235-11" aria-hidden="true" tabindex="-1"></a><span class="co">//const int A::n; //необязательно — если хотим зарезервировать память</span></span>
<span id="cb235-12"><a href="#cb235-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb235-13"><a href="#cb235-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb235-14"><a href="#cb235-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> A<span class="op">::</span>n<span class="op">;</span><span class="co">//компилятор подставит 1</span></span>
<span id="cb235-15"><a href="#cb235-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="пример-использования-статических-переменных.-определение-имени-класса-объекта-во-время-выполнения">Пример использования статических переменных. Определение имени класса объекта во время выполнения</h3>
<p>Замечание: приведенный ниже механизм определения класса объекта в период выполнения применяется в библиотеке MFC и появился задолго до того, как определение типа в период выполнения (runtime type information — RTTI) ввели в спецификацию языка C++. И хотя компилятор Visual C++, начиная с версии 4.0 поддерживает синтаксис RTTI, в библиотеке используется прежний механизм. Пример является упрощением.</p>
<p>Все классы MFC (кроме вспомогательных) наследуются от <code>CObject</code>. Если бы мы только хотели узнать имя класса объекта, достаточно было бы определить в классе <code>CObject</code> виртуальную функцию:</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CObject</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> GetClassName<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyObject <span class="op">:</span> <span class="kw">public</span> CObject</span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">char</span> <span class="va">m_name</span><span class="op">[];</span> <span class="co">//это только Объявление, поэтому могу</span></span>
<span id="cb236-9"><a href="#cb236-9" aria-hidden="true" tabindex="-1"></a>                          <span class="co">//размер не указывать (эквивалентно </span></span>
<span id="cb236-10"><a href="#cb236-10" aria-hidden="true" tabindex="-1"></a>                          <span class="co">//объявлению extern сhar m_name[];)</span></span>
<span id="cb236-11"><a href="#cb236-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb236-12"><a href="#cb236-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> GetClassName<span class="op">()</span> <span class="at">const</span></span>
<span id="cb236-13"><a href="#cb236-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb236-14"><a href="#cb236-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_name</span><span class="op">;</span></span>
<span id="cb236-15"><a href="#cb236-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb236-16"><a href="#cb236-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><code>.cpp</code>:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> MyObject<span class="op">::</span><span class="va">m_name</span><span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;MyObject&quot;</span><span class="op">;</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">//а это определение, совмещенное с инициализацией </span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">//(компилятор резервирует память)</span></span></code></pre></div>
<p>То есть смысл в том, что каждый производный класс хранит в статической переменной m_name имя своего класса и переопределяет виртуальную функцию <code>GetClassName()</code>, которая возвращает это имя, тогда</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">(</span>CObject<span class="op">*</span> p<span class="op">)</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> p<span class="op">-&gt;</span>GetClassName<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//посредством таблиц виртуальных функций выводит имя класса </span></span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//«целевого» объекта</span></span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="статические-методы">Статические методы</h2>
<p>Статический метод — это по сути глобальная функция, область видимости которой ограничена именем класса, поэтому (если она <code>public</code>) фактически вызывать ее можно, указывая имя класса и спецификатор разрешения области видимости, но формально она является членом класса, поэтому вызывать ее можно также посредством объекта или указателя на объект.</p>
<p>Самое главное отличие статического метода класса от обычного заключается в том, что компилятор при вызове статической функции не формирует «невидимый» параметр, содержащий адрес объекта, поэтому:</p>
<ul>
<li><p>следствие 1 — в таких функциях указатель <code>this</code> не существует!!!</p></li>
<li><p>следствие 2 — обратиться к нестатическим данным класса в такой функции не возможно</p></li>
<li><p>следствие 3 — статическая функция не может быть <code>virtual</code></p></li>
</ul>
<h3 id="использование-статических-методов-для-доступа-извне-к-private-или-protected-static-данным-класса">Использование статических методов для доступа извне к <code>private</code> или <code>protected</code> <code>static</code>-данным класса</h3>
<p>Если бы статическая переменная <code>nCount</code> класса <code>X</code> была защищенной, для доступа к ней извне класса потребовался бы <code>public</code> статический метод класса. Например:</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X</span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> nCount<span class="op">;</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a>    X<span class="op">()</span> <span class="op">{</span> nCount<span class="op">++;</span> <span class="op">}</span></span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>X<span class="op">()</span> <span class="op">{</span> nCount<span class="op">--;</span> <span class="op">}</span></span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> GetCount<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> nCount<span class="op">;</span> <span class="op">}</span></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Объявляется и инициализируется статическая переменная одинаково — независимо от спецификатора доступа:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> X<span class="op">::</span>nCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>Использование статических методов:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> X<span class="op">::</span>GetCount<span class="op">();</span> <span class="co">//???</span></span>
<span id="cb241-4"><a href="#cb241-4" aria-hidden="true" tabindex="-1"></a>    X x1<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb241-5"><a href="#cb241-5" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> x1<span class="op">::</span>GetCount<span class="op">();</span><span class="co">//???</span></span>
<span id="cb241-6"><a href="#cb241-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="производящие-функции-классов-виртуальный-конструктор">Производящие функции классов («виртуальный конструктор»)</h3>
<p>Производящей функцией называется функция, которая инкапсулирует вызов оператора <code>new</code> для динамического создания экземпляра класса.</p>
<p>Если конструктор класса защищен, то компилятор «не позволит» создать объект такого класса традиционным способом:</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> а<span class="op">;</span> <span class="op">}</span> <span class="co">//private конструктор</span></span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb242-8"><a href="#cb242-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//A a (1);//ошибка доступа (для того, чтобы компилятор имел</span></span>
<span id="cb242-9"><a href="#cb242-9" aria-hidden="true" tabindex="-1"></a>              <span class="co">//право вызвать конструктор, он должен быть public)</span></span>
<span id="cb242-10"><a href="#cb242-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Закрытые конструкторы (объявленные со спецификатором <code>private</code> или <code>protected</code>) не допускают создания объектов класса обычными пользователями, поэтому для создания объекта требуется выполнение одного из следующих условий:</p>
<ul>
<li><p>конструктор вызывается <code>public</code> статическим методом класса;</p></li>
<li><p>конструктор вызывается методом <code>friend</code>-класса.</p></li>
</ul>
<p>Когда это нужно? — если разработчик класса делает конструктор защищенным, он тем самым заставляет пользователя класса создавать объекты только предусмотренным разработчиком способом. Например:</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAX <span class="op">=</span> <span class="dv">100</span><span class="op">;</span> <span class="co">//максимально возможное количество объектов в</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//системе</span></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="co">//базовый класс, который будет контролировать в программе </span></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//как все объекты класса А, так и все объекты производных </span></span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//классов посредством статического счетчика и статического </span></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>       <span class="co">//массива, в котором будут храниться указатели базового типа</span></span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb243-10"><a href="#cb243-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb243-11"><a href="#cb243-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb243-12"><a href="#cb243-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">m_count</span> <span class="op">&lt;</span> MAX<span class="op">)</span></span>
<span id="cb243-13"><a href="#cb243-13" aria-hidden="true" tabindex="-1"></a>            <span class="va">m_ar</span><span class="op">[</span><span class="va">m_count</span><span class="op">++]</span> <span class="op">=</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb243-14"><a href="#cb243-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb243-15"><a href="#cb243-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>A<span class="op">()</span></span>
<span id="cb243-16"><a href="#cb243-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb243-17"><a href="#cb243-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_count</span><span class="op">--;</span></span>
<span id="cb243-18"><a href="#cb243-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">//изъять указатель из массива!!</span></span>
<span id="cb243-19"><a href="#cb243-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb243-20"><a href="#cb243-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> <span class="va">m_count</span><span class="op">;</span> <span class="co">//счетчик объектов как типа А, так</span></span>
<span id="cb243-21"><a href="#cb243-21" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">//и любого производного от А типа</span></span>
<span id="cb243-22"><a href="#cb243-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> A<span class="op">*</span> <span class="va">m_ar</span><span class="op">[</span>MAX<span class="op">];</span> <span class="co">//для упрощения считаем, что объектов не</span></span>
<span id="cb243-23"><a href="#cb243-23" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//может быть больше МАХ</span></span>
<span id="cb243-24"><a href="#cb243-24" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb243-25"><a href="#cb243-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> A<span class="op">*</span> Create<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span></span>
<span id="cb243-26"><a href="#cb243-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb243-27"><a href="#cb243-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">new</span> A<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb243-28"><a href="#cb243-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">//производящая функция</span></span>
<span id="cb243-29"><a href="#cb243-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Destroy<span class="op">()</span> <span class="op">{</span> <span class="kw">delete</span> <span class="kw">this</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb243-30"><a href="#cb243-30" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb243-31"><a href="#cb243-31" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb243-32"><a href="#cb243-32" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb243-33"><a href="#cb243-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb243-34"><a href="#cb243-34" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb243-35"><a href="#cb243-35" aria-hidden="true" tabindex="-1"></a>    B<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">:</span> A<span class="op">(</span>a<span class="op">)</span> <span class="op">{</span> <span class="va">m_b</span> <span class="op">=</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb243-36"><a href="#cb243-36" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb243-37"><a href="#cb243-37" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> A<span class="op">*</span> Create<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">new</span> B<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span> <span class="op">}</span></span>
<span id="cb243-38"><a href="#cb243-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">//статическая функция не может быть виртуальной, так как она </span></span>
<span id="cb243-39"><a href="#cb243-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">//не принимает в качестве «невидимого» параметра адрес </span></span>
<span id="cb243-40"><a href="#cb243-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">//объекта!!!</span></span>
<span id="cb243-41"><a href="#cb243-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> A<span class="op">::</span><span class="va">m_count</span><span class="op">;</span></span>
<span id="cb243-42"><a href="#cb243-42" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> A<span class="op">::</span><span class="va">m_ar</span><span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb243-43"><a href="#cb243-43" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb243-44"><a href="#cb243-44" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb243-45"><a href="#cb243-45" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb243-46"><a href="#cb243-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">//В b(1,2); //ошибка — конструктор защищен</span></span>
<span id="cb243-47"><a href="#cb243-47" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> p <span class="op">=</span> B<span class="op">::</span>Create<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span> <span class="co">//объект будет создан только таким</span></span>
<span id="cb243-48"><a href="#cb243-48" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//образом, как предусмотрел разработчик</span></span>
<span id="cb243-49"><a href="#cb243-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">//... вызов посредством указателя на базовый класс виртуальных </span></span>
<span id="cb243-50"><a href="#cb243-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">//методов производного класса</span></span>
<span id="cb243-51"><a href="#cb243-51" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>Destroy<span class="op">();</span> <span class="co">//вызывается метод базового класса. При выполнении </span></span>
<span id="cb243-52"><a href="#cb243-52" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//оператора delete сначала вызывается виртуальный </span></span>
<span id="cb243-53"><a href="#cb243-53" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//деструктор класса В, потом деструктор класса А, </span></span>
<span id="cb243-54"><a href="#cb243-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>                 <span class="co">//потом освобождается динамический блок памяти</span></span></code></pre></div>
<h1 id="тема-viii.-структуры-и-объединения-c">Тема VIII. Структуры и объединения C++</h1>
<p>В C++ структуры и объединения имеют существенные отличия от структур и объединений С.</p>
<h2 id="структура-c">Структура C++</h2>
<p>Структуры С могли содержать только данные. Они предоставляли программисту удобную возможность укрупнения данных. Структура C++ - это почти что полноценный класс. Это понятие остались в C++ для совместимости с С.</p>
<p>У классов и структур C++ много общего:</p>
<ul>
<li>в структурах C++ (в отличие от структур С) могут быть функции-члены,</li>
<li>в них можно объявлять секции <code>public</code>, <code>protected</code>, <code>private</code>,</li>
<li>структуры C++ могут иметь конструкторы, деструкторы,</li>
<li>участвовать в наследовании,</li>
<li>иметь виртуальные функции</li>
<li>…</li>
</ul>
<p>Отличие структур C++ от классов формально одно-единственное: спецификатор доступа по умолчанию - <code>public</code> (для совместимости со структурами С).</p>
<p>На практике (по договоренности между программистами) структуры используются вместо классов лишь при соблюдении следующих условий:</p>
<ul>
<li>структура не содержит виртуальных функций</li>
<li>если участвует в наследовании, то не является производной от чего-либо, кроме разве что другой структуры, и не является базой для чего-либо, кроме разве что другой структуры (то есть не стоит наследовать структуру от класса…)</li>
<li>нормальные программисты C++ используют обычно структуры для маленьких удобных наборов данных с тривиальными функциями.</li>
</ul>
<div class="sourceCode" id="cb244"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Rect</span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> left<span class="op">,</span> top<span class="op">,</span> right<span class="op">,</span> bottom<span class="op">;</span> <span class="co">//по умолчанию public</span></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="объединения-c">Объединения C++</h2>
<p>Объединения C++, кроме того что позволяют интерпретировать одну и ту же область памяти (то есть ее содержимое) по-разному, могут содержать также методы (в отличие от объединений С). По умолчанию - спецификатор доступа <code>public</code>.</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> U</span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_i</span><span class="op">;</span></span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="va">m_ch</span><span class="op">[</span><span class="dv">4</span><span class="op">];</span></span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a>    U<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> <span class="va">m_i</span> <span class="op">=</span> n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb245-8"><a href="#cb245-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb245-9"><a href="#cb245-9" aria-hidden="true" tabindex="-1"></a>    U ob<span class="op">(</span><span class="bn">0x11223344</span><span class="op">);</span></span>
<span id="cb245-10"><a href="#cb245-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> ch <span class="op">=</span> ob<span class="op">.</span><span class="va">m_ch</span><span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb245-11"><a href="#cb245-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> ob<span class="op">.</span><span class="va">m_i</span><span class="op">;</span></span>
<span id="cb245-12"><a href="#cb245-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Специфика:</p>
<ul>
<li>само объединение может иметь конструктор и деструктор, а его встроенные члены не могут.</li>
<li>объединение не может быть производным от чего-либо</li>
<li>не участвует в наследовании ⇒ в объединениях не используется спецификатор <code>protected</code></li>
<li>не может иметь статических членов</li>
<li>размер <code>union</code> определяется его наибольшим данным:</li>
</ul>
<div class="sourceCode" id="cb246"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> U</span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_i</span><span class="op">;</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="va">m_ch</span><span class="op">[</span><span class="dv">4</span><span class="op">];</span></span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_d</span><span class="op">;</span></span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>    U<span class="op">(</span><span class="dt">int</span> х<span class="op">)</span> <span class="op">{</span> <span class="va">m_i</span> <span class="op">=</span> х<span class="op">;</span> <span class="op">}</span></span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> GetInt<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_i</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> GetChar<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">if</span> <span class="op">(...)</span> <span class="cf">return</span> <span class="va">m_ch</span><span class="op">[</span>i<span class="op">];</span> <span class="op">}</span></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a>    U ob<span class="op">(</span><span class="bn">0x11223344</span><span class="op">);</span></span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">//ob.m_i = 5; //ошибка</span></span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> ob<span class="op">.</span>GetChar<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>ob<span class="op">);</span> <span class="co">//8</span></span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="анонимные-объединения-классы-структуры">Анонимные объединения (классы, структуры)</h3>
<p>Иногда просто требуется сообщить компилятору, что требуется разместить несколько переменных по одному и тому же адресу ⇒ нельзя создать экземпляр анонимного объединения ⇒ обращение к членам объединения не посредством объекта, а просто по имени переменной. Для локального использования.</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb247-4"><a href="#cb247-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">union</span></span>
<span id="cb247-5"><a href="#cb247-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb247-6"><a href="#cb247-6" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb247-7"><a href="#cb247-7" aria-hidden="true" tabindex="-1"></a>            <span class="dt">char</span> ch<span class="op">[</span><span class="dv">4</span><span class="op">];</span></span>
<span id="cb247-8"><a href="#cb247-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb247-9"><a href="#cb247-9" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb247-10"><a href="#cb247-10" aria-hidden="true" tabindex="-1"></a>        ch<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="bn">0xff</span><span class="op">;</span></span>
<span id="cb247-11"><a href="#cb247-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">//до конца блока можно пользоваться</span></span>
<span id="cb247-12"><a href="#cb247-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="тема-ix.-защищенное-наследование.-отношение-между-классами-подобен">Тема IX. Защищенное наследование. Отношение между классами — «подобен»</h1>
<h2 id="цель">Цель</h2>
<p>Если спецификатор наследования производного класса <code>private</code> или <code>protected</code>, <code>public</code> интерфейс базового класса извне (посредством объекта или указателя на объект) становится недоступен:</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fA<span class="op">();</span></span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">private</span><span class="co">/*protected*/</span> A <span class="op">{</span> <span class="op">};</span></span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb248-8"><a href="#cb248-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb248-9"><a href="#cb248-9" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">;</span></span>
<span id="cb248-10"><a href="#cb248-10" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>fA<span class="op">();</span> <span class="co">//ОК</span></span>
<span id="cb248-11"><a href="#cb248-11" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span></span>
<span id="cb248-12"><a href="#cb248-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//b.fA(); //ошибка компилятора метод недоступен</span></span>
<span id="cb248-13"><a href="#cb248-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//А* рА = new В; //ошибка — преобразование существует, но </span></span>
<span id="cb248-14"><a href="#cb248-14" aria-hidden="true" tabindex="-1"></a>                     <span class="co">//недоступно!</span></span>
<span id="cb248-15"><a href="#cb248-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>При защищенном наследовании доступ к <code>public</code> членам базового класса возможен только из методов производного класса. Пользователи производного класса не имеют доступа к базовой части, что позволяет разработчику производного класса приспособить базовую часть для своих целей, то есть:</p>
<ul>
<li><p>использовать те методы базового класса, которые удобно использовать производному классу только определенным образом,</p></li>
<li><p>а те понятия базового класса, которые «не справедливы» для производного, запретить.</p></li>
</ul>
<p>Например, таким образом можно построить иерархию классов:</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">,</span> r<span class="op">,</span> t<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true" tabindex="-1"></a>    Rect<span class="op">(</span><span class="dt">int</span> x1<span class="op">,</span> <span class="dt">int</span> y1<span class="op">,</span> <span class="dt">int</span> x2<span class="op">,</span> <span class="dt">int</span> y2<span class="op">)</span></span>
<span id="cb249-7"><a href="#cb249-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb249-8"><a href="#cb249-8" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> x1<span class="op">;</span> r <span class="op">=</span> x2<span class="op">;</span> t <span class="op">=</span> y1<span class="op">;</span> b <span class="op">=</span> y2<span class="op">;</span></span>
<span id="cb249-9"><a href="#cb249-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb249-10"><a href="#cb249-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Inflate<span class="op">(</span><span class="dt">int</span> dl<span class="op">,</span> <span class="dt">int</span> dr<span class="op">,</span> <span class="dt">int</span> dt<span class="op">,</span> <span class="dt">int</span> db<span class="op">)</span></span>
<span id="cb249-11"><a href="#cb249-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb249-12"><a href="#cb249-12" aria-hidden="true" tabindex="-1"></a>        l <span class="op">-=</span> dl<span class="op">;</span> r <span class="op">+=</span> dr<span class="op">;</span> t <span class="op">-=</span> dt<span class="op">;</span> b <span class="op">+=</span> db<span class="op">;</span></span>
<span id="cb249-13"><a href="#cb249-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb249-14"><a href="#cb249-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb249-15"><a href="#cb249-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Square <span class="op">:</span> <span class="kw">protected</span> Rect</span>
<span id="cb249-16"><a href="#cb249-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb249-17"><a href="#cb249-17" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb249-18"><a href="#cb249-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Inflate<span class="op">(</span><span class="dt">int</span> d<span class="op">)</span></span>
<span id="cb249-19"><a href="#cb249-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb249-20"><a href="#cb249-20" aria-hidden="true" tabindex="-1"></a>        Rect<span class="op">::</span>Inflate<span class="op">(</span>d<span class="op">,</span> d<span class="op">,</span> d<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb249-21"><a href="#cb249-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">//метод базового класса вызывается таким образом,</span></span>
<span id="cb249-22"><a href="#cb249-22" aria-hidden="true" tabindex="-1"></a>      <span class="co">//чтобы квадрат не превратился в прямоугольник</span></span>
<span id="cb249-23"><a href="#cb249-23" aria-hidden="true" tabindex="-1"></a>    Square<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> <span class="dt">int</span> d<span class="op">)</span></span>
<span id="cb249-24"><a href="#cb249-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> Rect<span class="op">(</span>x<span class="op">,</span> y<span class="op">,</span> x <span class="op">+</span> d<span class="op">,</span> y <span class="op">+</span> d<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb249-25"><a href="#cb249-25" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb249-26"><a href="#cb249-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb249-27"><a href="#cb249-27" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb249-28"><a href="#cb249-28" aria-hidden="true" tabindex="-1"></a>    Square s<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb249-29"><a href="#cb249-29" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>Inflate<span class="op">(</span><span class="dv">2</span><span class="op">);</span> <span class="co">//квадрат остался квадратом</span></span>
<span id="cb249-30"><a href="#cb249-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">//s.Inflate(1, 2, 3, 4); //ошибка компилятора</span></span>
<span id="cb249-31"><a href="#cb249-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb249-32"><a href="#cb249-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Компилятор обмануть трудно:</span></span>
<span id="cb249-33"><a href="#cb249-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">//s.Rect::Inflate(1, 2, 3, 4); //ошибка компилятора</span></span>
<span id="cb249-34"><a href="#cb249-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Rect r = s; //ошибка компилятора</span></span>
<span id="cb249-35"><a href="#cb249-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Rect* pr = new Square (10, 10, 100); //ошибка компилятора</span></span>
<span id="cb249-36"><a href="#cb249-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: при защищенном наследовании внутренние взаимоотношения между двумя классами не меняются, то есть в методах производного класса доступны <code>protected</code> понятия базового класса.</p>
<h2 id="friend"><code>friend</code></h2>
<p>Все друзья <code>Square</code> имеют также доступ к защищенным членам <code>Rect</code>, наследники — нет</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">,</span> r<span class="op">,</span> t<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>    Rect<span class="op">(</span><span class="dt">int</span> x1<span class="op">,</span> <span class="dt">int</span> yl<span class="op">,</span> <span class="dt">int</span> x2<span class="op">,</span> <span class="dt">int</span> y2<span class="op">)</span></span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> x1<span class="op">;</span> r <span class="op">=</span> x2<span class="op">;</span> t <span class="op">=</span> yl<span class="op">;</span> b <span class="op">=</span> y2<span class="op">;</span></span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Inflate<span class="op">(</span><span class="dt">int</span> dl<span class="op">,</span> <span class="dt">int</span> dr<span class="op">,</span> <span class="dt">int</span> dt<span class="op">,</span> <span class="dt">int</span> db<span class="op">)</span></span>
<span id="cb250-11"><a href="#cb250-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb250-12"><a href="#cb250-12" aria-hidden="true" tabindex="-1"></a>        l <span class="op">-=</span> dl<span class="op">;</span> r <span class="op">+=</span> dr<span class="op">;</span> t <span class="op">-=</span> dt<span class="op">;</span> b <span class="op">+=</span> db<span class="op">;</span></span>
<span id="cb250-13"><a href="#cb250-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb250-14"><a href="#cb250-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb250-15"><a href="#cb250-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb250-16"><a href="#cb250-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Square <span class="op">:</span> <span class="kw">protected</span> Rect</span>
<span id="cb250-17"><a href="#cb250-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb250-18"><a href="#cb250-18" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb250-19"><a href="#cb250-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> inflate<span class="op">(</span><span class="dt">int</span> d<span class="op">)</span> <span class="op">{</span> Rect<span class="op">::</span>Inflate<span class="op">(</span>d<span class="op">,</span> d<span class="op">,</span> d<span class="op">,</span> d<span class="op">);</span> <span class="op">};</span></span>
<span id="cb250-20"><a href="#cb250-20" aria-hidden="true" tabindex="-1"></a>    Square<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> <span class="dt">int</span> d<span class="op">)</span> <span class="op">:</span> Rect<span class="op">(</span>x<span class="op">,</span> y<span class="op">,</span> x <span class="op">+</span> d<span class="op">,</span> y <span class="op">+</span> d<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb250-21"><a href="#cb250-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="dt">void</span> GF<span class="op">(</span>Square<span class="op">&amp;</span> s<span class="op">);</span></span>
<span id="cb250-22"><a href="#cb250-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb250-23"><a href="#cb250-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> GF<span class="op">(</span>Square<span class="op">&amp;</span> s<span class="op">)</span></span>
<span id="cb250-24"><a href="#cb250-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb250-25"><a href="#cb250-25" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>f<span class="op">();</span> <span class="co">//ОК</span></span>
<span id="cb250-26"><a href="#cb250-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="защищенное-наследование-при-построении-иерархий-классов">Защищенное наследование при построении иерархий классов</h2>
<p>В предыдущем примере взаимоотношения внутри классов сохранялись, но если мы продолжим строить иерархию классов, то защищенная базовая часть должна</p>
<p>Объектно-ориентированное программирование (C++) быть изолирована от всех остальных не непосредственных наследников, поэтому для таких наследников появляются дополнительные ограничения области видимости:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a1</span><span class="op">;</span></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fA1<span class="op">();</span></span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb251-8"><a href="#cb251-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fA2<span class="op">();</span></span>
<span id="cb251-9"><a href="#cb251-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb251-10"><a href="#cb251-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span><span class="kw">private</span><span class="co">/*protected*/</span> A</span>
<span id="cb251-11"><a href="#cb251-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb251-12"><a href="#cb251-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb251-13"><a href="#cb251-13" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb251-14"><a href="#cb251-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_B1</span><span class="op">;</span></span>
<span id="cb251-15"><a href="#cb251-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fB1<span class="op">()</span></span>
<span id="cb251-16"><a href="#cb251-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="co">//разрешено обращаться к public и protected членам A</span></span>
<span id="cb251-17"><a href="#cb251-17" aria-hidden="true" tabindex="-1"></a>        fA1<span class="op">();</span></span>
<span id="cb251-18"><a href="#cb251-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_a1</span><span class="op">++;</span></span>
<span id="cb251-19"><a href="#cb251-19" aria-hidden="true" tabindex="-1"></a>        fA2<span class="op">();</span></span>
<span id="cb251-20"><a href="#cb251-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb251-21"><a href="#cb251-21" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb251-22"><a href="#cb251-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fB2<span class="op">();</span></span>
<span id="cb251-23"><a href="#cb251-23" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Разница в спецификаторах <code>private</code> и <code>protected</code> проявляется для наследников класса B:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span><span class="kw">public</span> B</span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fC<span class="op">()</span></span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb252-6"><a href="#cb252-6" aria-hidden="true" tabindex="-1"></a>        fB1<span class="op">();</span></span>
<span id="cb252-7"><a href="#cb252-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_a1</span><span class="op">++;</span><span class="co">//protected — OK, private — inaccessible member</span></span>
<span id="cb252-8"><a href="#cb252-8" aria-hidden="true" tabindex="-1"></a>        fA1<span class="op">();</span><span class="co">//protected — OK, private — inaccessible member</span></span>
<span id="cb252-9"><a href="#cb252-9" aria-hidden="true" tabindex="-1"></a>        fA2<span class="op">();</span><span class="co">//protected — OK, private — not accessible because</span></span>
<span id="cb252-10"><a href="#cb252-10" aria-hidden="true" tabindex="-1"></a>              <span class="co">//&#39;B&#39; uses &#39;private&#39; to inherit from &#39;A&#39;</span></span>
<span id="cb252-11"><a href="#cb252-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb252-12"><a href="#cb252-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb252-13"><a href="#cb252-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb252-14"><a href="#cb252-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb252-15"><a href="#cb252-15" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">;</span></span>
<span id="cb252-16"><a href="#cb252-16" aria-hidden="true" tabindex="-1"></a>    C c<span class="op">;</span></span>
<span id="cb252-17"><a href="#cb252-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">//c.fA2();//private — inaccessible member ,</span></span>
<span id="cb252-18"><a href="#cb252-18" aria-hidden="true" tabindex="-1"></a>              <span class="co">//protected — not accessible</span></span>
<span id="cb252-19"><a href="#cb252-19" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>fB2<span class="op">();</span></span>
<span id="cb252-20"><a href="#cb252-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//A* pA = new С; //ошибка</span></span>
<span id="cb252-21"><a href="#cb252-21" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> pA <span class="op">=</span> <span class="kw">new</span> C<span class="op">;</span> <span class="co">//OK</span></span>
<span id="cb252-22"><a href="#cb252-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Изменение вида доступа к элементу базового класса из производного класса в зависимости от спецификатора доступа, указываемого при объявлении производного класса</p>
<table style="width:94%;">
<colgroup>
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 23%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Спецификатор доступа, указываемый при объявлении производного класса</td>
<td>Изменение вида доступа к элементу базового класса посредством производного класса</td>
<td>⇒</td>
<td>⇒</td>
</tr>
<tr class="even">
<td>⇓</td>
<td>в базовом public</td>
<td>в базовом protected</td>
<td>в базовом private</td>
</tr>
<tr class="odd">
<td><p>class В : public А{…}; (открытое наследование)</p>
<p>class С : public В{…};</p></td>
<td>в производном public</td>
<td>в производном protected</td>
<td>в производном недоступен</td>
</tr>
<tr class="even">
<td><p>class В : protected A {…};</p>
<p>class С : public B {…};</p></td>
<td>в производном protected</td>
<td>в производном protected</td>
<td>в производном недоступен</td>
</tr>
<tr class="odd">
<td><p>class В : private А {…};</p>
<p>class С : public В {…};</p></td>
<td>в производном private</td>
<td>в производном private</td>
<td>в производном недоступен</td>
</tr>
</tbody>
</table>
<h1 id="тема-x.-множественное-наследование">Тема X. Множественное наследование</h1>
<p>Одиночное наследование (каким бы на самом деле сложным оно не было) предполагает наследование свойств от одного непосредственного предка. Множественное наследование позволяет производному классу наследовать свойства не только предков «по одной линии», но и свойства двух (трех, …) родителей. Иерархия классов при этом становится сложнее и вырождается в граф классов.</p>
<p>Отношение к множественному наследованию неоднозначно:</p>
<ul>
<li><p>с одной стороны, заманчиво, так как позволяет наследовать свойства нескольких предков (то есть зачастую моделирует реальные жизненные ситуации);</p></li>
<li><p>с другой стороны, работает медленнее, дополнительный расход памяти, труднее в реализации (так как подкидывает программисту массу «подводных» камней). Поэтому множественное наследование часто сравнивают с «ящиком Пандоры», то есть с источником бед, которые не актуальны при одиночном наследовании.</p></li>
</ul>
<p>Замечание: далеко не все объектно-ориентированные языки поддерживают множественное наследование.</p>
<h2 id="простой-пример-без-полиморфизма">Простой пример (без полиморфизма)</h2>
<p>Построим простую иерархию классов. Хотим, чтобы производный класс <code>C</code> наСледовал свойства обоих предков — классов <code>A</code> и <code>B</code>:</p>
<p><img src="media/image35.svg" /></p>
<div class="sourceCode" id="cb253"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> а<span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> а<span class="op">;</span> <span class="op">}</span></span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FA<span class="op">()</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb253-7"><a href="#cb253-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb253-8"><a href="#cb253-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B</span>
<span id="cb253-9"><a href="#cb253-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb253-10"><a href="#cb253-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb253-11"><a href="#cb253-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb253-12"><a href="#cb253-12" aria-hidden="true" tabindex="-1"></a>    B<span class="op">(</span><span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="va">m_b</span> <span class="op">=</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb253-13"><a href="#cb253-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FB<span class="op">()</span> <span class="op">{</span> <span class="op">};</span></span>
<span id="cb253-14"><a href="#cb253-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb253-15"><a href="#cb253-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> A<span class="op">,</span> <span class="kw">public</span> B <span class="co">//Замечание: если мы хотим открыто</span></span>
<span id="cb253-16"><a href="#cb253-16" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//наследовать от обоих предков, public </span></span>
<span id="cb253-17"><a href="#cb253-17" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//В обязательно, так как иначе по </span></span>
<span id="cb253-18"><a href="#cb253-18" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//умолчании компилятор будет считать, </span></span>
<span id="cb253-19"><a href="#cb253-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>                            <span class="co">//что спецификатор наследования private</span></span>
<span id="cb253-20"><a href="#cb253-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_c</span><span class="op">;</span></span>
<span id="cb253-21"><a href="#cb253-21" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb253-22"><a href="#cb253-22" aria-hidden="true" tabindex="-1"></a>    C<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">:</span> A<span class="op">(</span>a<span class="op">),</span> B<span class="op">(</span>b<span class="op">)</span> <span class="op">{</span> <span class="va">m_c</span> <span class="op">=</span> c<span class="op">;</span> <span class="op">}</span></span>
<span id="cb253-23"><a href="#cb253-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Замечание: независимо от того порядка, в котором в списке </span></span>
<span id="cb253-24"><a href="#cb253-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">//инициализации программист указывает вызов конструкторов </span></span>
<span id="cb253-25"><a href="#cb253-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">//базовых классов, компилятор их вызывает в том порядке, в </span></span>
<span id="cb253-26"><a href="#cb253-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">//котором они следуют в списке наследования</span></span>
<span id="cb253-27"><a href="#cb253-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> FC<span class="op">()</span> <span class="op">{</span> <span class="op">};</span></span>
<span id="cb253-28"><a href="#cb253-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Специфика:</p>
<ul>
<li><p>Порядок вызова конструкторов: <code>А() -&gt; В() -&gt; С()</code>. Конструкторы вызываются в том порядке, в котором они указаны в списке наследования!!!</p></li>
<li><p>Деструкторы — в обратном порядке</p></li>
<li><p>Компилятор строит объект в порядке объявления базовых классов. При этом экземпляр класса С будет в памяти выглядеть: (память отводится в порядке указания родительских классов)</p>
<p><img src="media/image36.svg" /></p></li>
<li><p>Вызов методов в таком простом случае ничем не отличается от простого наследования.</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>    С с<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>FA<span class="op">();</span></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>При одиночном наследовании преобразование от <code>derived*</code> к <code>base*</code> происходит следующим образом: адрес остается тем же самым, а тип объекта, на который указывает указатель, изменяется. При множественном:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">*</span> a <span class="op">=</span> <span class="op">&amp;</span>c<span class="op">;</span></span></code></pre></div>
<p>преобразование от производного к первому базовому классу — адрес не меняется. Здесь та же ситуация, что и при простом наследовании потому, что адрес подобъекта <code>A</code> совпадает с адресом объекта <code>C</code>.</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a>В<span class="op">*</span> b <span class="op">=</span> <span class="op">&amp;</span>с<span class="op">;</span></span></code></pre></div>
<p>тоже получаем правильный результат, но затраты компилятора гораздо больше — адрес преобразуется к подобъекту «<code>B</code>» — <strong>адрес изменяется</strong>!</p></li>
</ul>
<h2 id="множественное-наследование-и-полиморфизм">Множественное наследование и полиморфизм</h2>
<p>При наличии виртуальных функций ситуация усугубляется:</p>
<p><img src="media/image37.svg" /></p>
<div class="sourceCode" id="cb257"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f1<span class="op">()</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-8"><a href="#cb257-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B</span>
<span id="cb257-9"><a href="#cb257-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb257-10"><a href="#cb257-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mb<span class="op">;</span></span>
<span id="cb257-11"><a href="#cb257-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb257-12"><a href="#cb257-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f2<span class="op">()</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb257-13"><a href="#cb257-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb257-14"><a href="#cb257-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-15"><a href="#cb257-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> A<span class="op">,</span> <span class="kw">public</span> B</span>
<span id="cb257-16"><a href="#cb257-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb257-17"><a href="#cb257-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_c</span><span class="op">;</span></span>
<span id="cb257-18"><a href="#cb257-18" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb257-19"><a href="#cb257-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f1<span class="op">()</span> <span class="op">{</span> <span class="op">}</span> <span class="co">//перегруженный виртуальный метод для A</span></span>
<span id="cb257-20"><a href="#cb257-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f2<span class="op">()</span> <span class="op">{</span> <span class="op">}</span> <span class="co">//для B</span></span>
<span id="cb257-21"><a href="#cb257-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb257-22"><a href="#cb257-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-23"><a href="#cb257-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb257-24"><a href="#cb257-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb257-25"><a href="#cb257-25" aria-hidden="true" tabindex="-1"></a>    C с<span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">);</span></span>
<span id="cb257-26"><a href="#cb257-26" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pA <span class="op">=</span> <span class="op">&amp;</span>с<span class="op">;</span> <span class="co">//адрес объекта C совпадает с адресом его базовой</span></span>
<span id="cb257-27"><a href="#cb257-27" aria-hidden="true" tabindex="-1"></a>                <span class="co">//части A ⇒ указатель на vftab — первое данное с </span></span>
<span id="cb257-28"><a href="#cb257-28" aria-hidden="true" tabindex="-1"></a>                <span class="co">//нулевым смещением</span></span>
<span id="cb257-29"><a href="#cb257-29" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> рВ <span class="op">=</span> <span class="op">&amp;</span>с<span class="op">;</span><span class="co">//адрес объекта C не совпадает с адресом его базовой </span></span>
<span id="cb257-30"><a href="#cb257-30" aria-hidden="true" tabindex="-1"></a>               <span class="co">//части B ⇒ но указатель на vftab — это снова первое </span></span>
<span id="cb257-31"><a href="#cb257-31" aria-hidden="true" tabindex="-1"></a>               <span class="co">//данное с нулевым смещением</span></span>
<span id="cb257-32"><a href="#cb257-32" aria-hidden="true" tabindex="-1"></a>    pA<span class="op">-&gt;</span>f1<span class="op">();</span> <span class="co">//посредством C(для A)::vftab</span></span>
<span id="cb257-33"><a href="#cb257-33" aria-hidden="true" tabindex="-1"></a>    рВ<span class="op">-&gt;</span>f2<span class="op">();</span> <span class="co">//посредством C(для B)::vftab</span></span>
<span id="cb257-34"><a href="#cb257-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb257-35"><a href="#cb257-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><img src="media/image38.svg" /></p>
<p><img src="media/image39.svg" /></p>
<p><img src="media/image40.svg" /></p>
<p>Таблиц виртуальных функций две. Обе содержат адреса виртуальных функций производного класса. Поэтому при обращении и по <code>A*</code> компилятор «видит» часть подобъекта <code>A</code> и таблицу виртуальных функций <code>C</code> (для <code>A</code>), а при обращении по <code>B</code>* часть подобъекта <code>B</code>, но таблицу виртуальных функций <code>C</code> (для <code>B</code>).</p>
<h2 id="проблемы-возникающие-при-множественном-наследовании">Проблемы, возникающие при множественном наследовании</h2>
<p>Множественное наследование предоставляет ряд очевидных преимуществ + большое количество «подводных камней», поэтому такие библиотеки как MFC (и такие языки как С#) множественное наследование практически (во всяком случае явно) не используют. Проблемы: (Прим. редактора: какие проблемы???)</p>
<p>Замечание: в случае множественного наследования базовый класс нельзя указывать при объявлении производного более одного раза:</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> А <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> В <span class="op">:</span> <span class="kw">public</span> A<span class="op">,</span> <span class="kw">public</span> А <span class="op">{</span> <span class="op">...</span> <span class="op">};</span> <span class="co">//ошибка</span></span></code></pre></div>
<p>Но тем не менее, базовый класс может косвенно передаваться производному более одного раза, например:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb259-5"><a href="#cb259-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> left<span class="op">,</span> right<span class="op">,</span> top<span class="op">,</span> bottom<span class="op">;</span></span>
<span id="cb259-6"><a href="#cb259-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb259-7"><a href="#cb259-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ColoredRect <span class="op">:</span> <span class="kw">public</span> Rect <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb259-8"><a href="#cb259-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RoundRect <span class="op">:</span> <span class="kw">public</span> Rect <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb259-9"><a href="#cb259-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ColoredRoundRect <span class="op">:</span> <span class="kw">public</span> ColoredRect<span class="op">,</span> <span class="kw">public</span> RoundRect</span>
<span id="cb259-10"><a href="#cb259-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb259-11"><a href="#cb259-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> GetLeft<span class="op">();</span></span>
<span id="cb259-12"><a href="#cb259-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>При такой иерархии классов базовая часть Rect будет входить в объект производного типа <code>ColoredRoundRect</code> дважды:</p>
<p><img src="media/image41.svg" /></p>
<div class="sourceCode" id="cb260"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ColoredRoundRect<span class="op">::</span>GetLeft<span class="op">()</span></span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//return left; //ошибка. Так как объект класса ColoredRoundRect</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//содержит два подобъекта класса Rect, доступ к </span></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//члену данных left неоднозначен!</span></span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ColoredRect<span class="op">::</span>value<span class="op">;</span> <span class="co">//для устранения неоднозначности </span></span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//следует уточнить с помощью </span></span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//оператора разрешения области </span></span>
<span id="cb260-10"><a href="#cb260-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>                              <span class="co">//видимости «путь наследования»</span></span></code></pre></div>
<p>Наличие в дереве наследования нескольких экземпляров одного и того же базового класса вредно (не только вносит путаницу, но и приводит к излишним затратам памяти). Объявление базового класса в списке наследования виртуальным решает эту проблему. Подобное объявление предписывает компилятору создавать единственный подобъект базового класса. При этом виртуальные базовые классы реализуются посредством указателей ⇒ объект типа <code>ColoredRoundRect</code> компилятор формирует ссовсем уж причудливым образом:</p>
<p><img src="media/image42.svg" /></p>
<p><img src="media/image43.svg" /></p>
<div class="sourceCode" id="cb261"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ColoredRect <span class="op">:</span> <span class="kw">virtual</span> <span class="kw">public</span> Rect <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RoundRect <span class="op">:</span> <span class="kw">virtual</span> <span class="kw">public</span> Rect <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ColoredRoundRect <span class="op">:</span> <span class="kw">public</span> ColoredRect<span class="op">,</span> <span class="kw">public</span> RoundRect</span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> GetLeft<span class="op">();</span></span>
<span id="cb261-7"><a href="#cb261-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h1 id="тема-xi.-механизм-rtti-run-time-type-identification">Тема XI. Механизм RTTI (run-time type identification)</h1>
<h2 id="оператор-static_cast-и-указатели-на-классы-связанные-наследованием">Оператор <code>static_cast</code> и указатели на классы связанные наследованием</h2>
<p>Неявное приведение указателя на объект производного типа к указателю на объект базового типа компилятор прекрасно выполняет сам, так как производный класс содержит полные определения своих базовых классов. Такое <strong>повышающее (upcast)</strong> приведение типа всегда безопасно!</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a>B b<span class="op">;</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a>A<span class="op">*</span> pA <span class="op">=</span> <span class="op">&amp;</span>b<span class="op">;</span></span></code></pre></div>
<p>Верно и следующее утверждение: если объект на самом деле является объектом производного типа, а в нашем распоряжении имеется указатель на базовый класс, то корректным должно являться и преобразование указателя «вниз» по иерархии классов вплоть до преобразования такого указателя к указателю на фактический (целевой) тип — <strong>понижающее приведение (downcast)</strong>.</p>
<p>Для приведения указателя на базовый тип к указателю производного типа можно использовать оператор явного приведения типа <code>static_cast</code> — это механизм времени компиляции!</p>
<p>Пример:</p>
<!-- Что за класс D? -->
<div class="sourceCode" id="cb263"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="co">//классы A и В связаны наследованием</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb263-8"><a href="#cb263-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb263-9"><a href="#cb263-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb263-10"><a href="#cb263-10" aria-hidden="true" tabindex="-1"></a><span class="co">//C — «автономный» класс</span></span>
<span id="cb263-11"><a href="#cb263-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb263-12"><a href="#cb263-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb263-13"><a href="#cb263-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb263-14"><a href="#cb263-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb263-15"><a href="#cb263-15" aria-hidden="true" tabindex="-1"></a><span class="co">//Глобальная функция, принимающая указатель базового типа</span></span>
<span id="cb263-16"><a href="#cb263-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">(</span>A<span class="op">*</span> рА<span class="op">)</span> <span class="co">//посредством такого указателя можно: — вызвать </span></span>
<span id="cb263-17"><a href="#cb263-17" aria-hidden="true" tabindex="-1"></a>              <span class="co">//virtual-функцию целевого класса — вызвать обычный </span></span>
<span id="cb263-18"><a href="#cb263-18" aria-hidden="true" tabindex="-1"></a>              <span class="co">//метод базового класса оперировать данными базового </span></span>
<span id="cb263-19"><a href="#cb263-19" aria-hidden="true" tabindex="-1"></a>              <span class="co">//класса</span></span>
<span id="cb263-20"><a href="#cb263-20" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">//но если нужно вызвать обычный метод производного класса или </span></span>
<span id="cb263-21"><a href="#cb263-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">//обратиться к данным производного класса, то нужен указатель В*:</span></span>
<span id="cb263-22"><a href="#cb263-22" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> pB <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>B<span class="op">*&gt;(</span>рА<span class="op">);</span><span class="co">//с точки зрения компилятора все </span></span>
<span id="cb263-23"><a href="#cb263-23" aria-hidden="true" tabindex="-1"></a>                                <span class="co">//корректно, так как классы связаны </span></span>
<span id="cb263-24"><a href="#cb263-24" aria-hidden="true" tabindex="-1"></a>                                <span class="co">//наследованием!</span></span>
<span id="cb263-25"><a href="#cb263-25" aria-hidden="true" tabindex="-1"></a>    pB<span class="op">-&gt;</span>fB<span class="op">();</span></span>
<span id="cb263-26"><a href="#cb263-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb263-27"><a href="#cb263-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb263-28"><a href="#cb263-28" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb263-29"><a href="#cb263-29" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span></span>
<span id="cb263-30"><a href="#cb263-30" aria-hidden="true" tabindex="-1"></a>    F<span class="op">(&amp;</span>b<span class="op">);</span><span class="co">//компилятор преобразует адрес В* к A* — это всегда </span></span>
<span id="cb263-31"><a href="#cb263-31" aria-hidden="true" tabindex="-1"></a>          <span class="co">//корректно</span></span>
<span id="cb263-32"><a href="#cb263-32" aria-hidden="true" tabindex="-1"></a><span class="co">//Классы A и C не связаны наследованием, поэтому компилятор не </span></span>
<span id="cb263-33"><a href="#cb263-33" aria-hidden="true" tabindex="-1"></a><span class="co">//допустит такой ситуации</span></span>
<span id="cb263-34"><a href="#cb263-34" aria-hidden="true" tabindex="-1"></a>    C c<span class="op">;</span></span>
<span id="cb263-35"><a href="#cb263-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">//F(&amp;c); //ошибка компилятора — такого преобразования нет!</span></span>
<span id="cb263-36"><a href="#cb263-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Но!</span></span>
<span id="cb263-37"><a href="#cb263-37" aria-hidden="true" tabindex="-1"></a>    A а<span class="op">;</span></span>
<span id="cb263-38"><a href="#cb263-38" aria-hidden="true" tabindex="-1"></a>    F<span class="op">(&amp;</span>а<span class="op">);</span> <span class="co">//ошибки компилятора нет, но результат некорректный, так </span></span>
<span id="cb263-39"><a href="#cb263-39" aria-hidden="true" tabindex="-1"></a>           <span class="co">//как на самом деле объект A, а не В!</span></span>
<span id="cb263-40"><a href="#cb263-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: компилятор проверяет только тот факт, что</p>
<ul>
<li>оба класса связаны наследованием;</li>
<li>наследование открытое (<code>public</code>).</li>
</ul>
<p>Поэтому компилятор считает такое приведение корректным. А на самом деле такое преобразование небезопасно! Поэтому возникла необходимость в способе проверки возможности такого преобразования.</p>
<blockquote>
<p>Замечание: static_cast обычно используется для неполиморфных типов (в классах нет виртуальных функций).</p>
</blockquote>
<h2 id="динамическая-идентификация-типа">Динамическая идентификация типа</h2>
<p><img src="media/image44.svg" /></p>
<p>RTTI характеризуется тремя понятиями:</p>
<ul>
<li><p>оператор <code>dynamic_cast</code> — для преобразования указателей или ссылок полиморфных типов</p></li>
<li><p>оператор <code>typeid</code> — для определения точного (exact) типа объекта во время выполнения</p></li>
<li><p>класс <code>type_info</code> — (это то, что возвращает оператор <code>typeid</code>)</p></li>
</ul>
<h3 id="подключение-rtti">Подключение RTTI</h3>
<p>Для подключения RTTI (так как механизм дорогой и просто так работать не будет!):</p>
<ul>
<li><p>в опциях проекта <code>Project &gt; Properties &gt; C/C++ &gt; Language</code> — должен быть включен флаг <code>Enable Run-Time Type info</code> (тогда в опциях командной строки компилятору будет указан ключ <code>/GR</code>).</p></li>
<li><p><code>#include &lt;type_info&gt;</code> — объявлен класс <code>type_info</code></p></li>
<li><p>механизм работает только для полиморфных классов.</p></li>
</ul>
<h3 id="оператор-typeid-и-класс-type_info">Оператор <code>typeid</code> и класс <code>type_info</code></h3>
<p>Идентификация типов позволяет получить информацию об объектах во время выполнения. Это означает, что кто-то и где-то должен эту информацию сформировать, а именно</p>
<ol type="1">
<li><p>отвести память (где?)</p></li>
<li><p>сформировать данные (какие?)</p></li>
<li><p>обеспечить механизм использования этой информации (как?).</p></li>
</ol>
<p>Логично:</p>
<ol type="1">
<li><p>сколько бы объектов класса X мы не создавали, достаточно хранить информацию собственно о типе X в единственном экземпляре в каждом классе ⇒ для каждого класса компилятор создает объект типа <code>type_info</code></p></li>
<li><p>должен существовать способ получения этой информации для каждого объекта ⇒</p>
<ol type="1">
<li><p>явно доступ к объекту <code>type_info</code> можно получить при помощи оператора <code>typeid</code></p></li>
<li><p>неявно — посредством оператора <code>dynamic_cast</code>.</p></li>
</ol></li>
<li><p>Что существует в единственном экземпляре для всех объектов? — статические переменные или таблица виртуальных функций. В спецификации языка сказано, что получение этой информации гарантируется только для полиморфных типов (то есть если есть хотя бы одна виртуальная функция). Данные RTTI выполняют примерно ту же задачу, что и таблица виртуальных функций ⇒ для поддержки RTTI была использована именно таблицы виртуальных функций класса. Например индекс 0 в таблице может содержать указатель на объект <code>type_info</code>:</p></li>
</ol>
<p><img src="media/image45.svg" /></p>
<p>При такой реализации память будет тратиться только на добавление еще одной ячейки в каждую таблицу виртуальных функций + выделение памяти для хранения объекта <code>type_info</code> для каждого класса.</p>
<h4 id="формат-type_info">1.1.25. Формат <code>type_info</code></h4>
<p>Заголовочный файл <code>type_info</code>:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> type_info</span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>type_info<span class="op">();</span></span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> type_info<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">operator</span><span class="op">!=(</span><span class="at">const</span> type_info<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> before<span class="op">(</span><span class="at">const</span> type_info<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span><span class="op">;</span> <span class="co">//не только</span></span>
<span id="cb264-8"><a href="#cb264-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//непосредственного предка, но и любого в иерархии!</span></span>
<span id="cb264-9"><a href="#cb264-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> name<span class="op">()</span> <span class="at">const</span><span class="op">;</span> <span class="co">//имя, которое дал программист</span></span>
<span id="cb264-10"><a href="#cb264-10" aria-hidden="true" tabindex="-1"></a>                              <span class="co">//(human-readable)</span></span>
<span id="cb264-11"><a href="#cb264-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> raw_name<span class="op">()</span> <span class="at">const</span><span class="op">;</span> <span class="co">//декорированное имя</span></span>
<span id="cb264-12"><a href="#cb264-12" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb264-13"><a href="#cb264-13" aria-hidden="true" tabindex="-1"></a>    type_info<span class="op">(</span><span class="at">const</span> type_info<span class="op">&amp;);</span></span>
<span id="cb264-14"><a href="#cb264-14" aria-hidden="true" tabindex="-1"></a>    type_info<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> type_info<span class="op">&amp;);</span></span>
<span id="cb264-15"><a href="#cb264-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb264-16"><a href="#cb264-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Основные возможности:</p>
<ul>
<li><p>перегружены операторы <code>==</code> и <code>!=</code>.</p></li>
<li><p>методы для получения имени класса.</p></li>
<li><p>программисту запрещено самому создавать, копировать и присваивать объекты такого класса, так как все соответствующие методы являются защищенными</p></li>
</ul>
<blockquote>
<p>Замечание: единственной возможностью получить доступ к информации явно (и только для чтения) — является оператор typeid.</p>
</blockquote>
<p>Оператор присваивания тоже защищен ⇒ присваивать объекты типа type info компилятор Вам тоже не позволит!</p>
<h4 id="формы-оператора-typeid">1.1.26. Формы оператора <code>typeid</code></h4>
<div class="sourceCode" id="cb265"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> type_info<span class="op">&amp;</span> <span class="kw">typeid</span><span class="op">(</span>тип<span class="op">)</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> type_info<span class="op">&amp;</span> <span class="kw">typeid</span><span class="op">(</span>выражение<span class="op">)</span></span></code></pre></div>
<p>Так как определение типа имеет смысл только при наследовании, примеры привожу на простенькой иерархии:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A <span class="op">{</span> <span class="op">};</span></span></code></pre></div>
<p>В качестве выражения может использоваться:</p>
<ol type="1">
<li><p>ссылка на класс</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a>B b<span class="op">;</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>A<span class="op">&amp;</span> ra <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="kw">typeid</span><span class="op">(</span>ra<span class="op">).</span>name<span class="op">();</span> <span class="co">//&quot;class B&quot;</span></span></code></pre></div>
<p>При этом даже если в качестве выражения фигурирует ссылка на базовый класс, результат <code>typeid</code>-оператора — <code>const type_info&amp;</code> целевого класса.</p></li>
<li><p>Использовать в качестве выражения непосредственно объект можно, но смысла не имеет</p></li>
<li><p>разыменованный указатель (при этом, если значение указателя <code>==0</code>, вырабатывается исключение <code>bad_typeid_exception</code>)</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">*</span> рA <span class="op">=</span> <span class="kw">new</span> B<span class="op">;</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="kw">typeid</span><span class="op">(*</span>pA<span class="op">).</span>name<span class="op">();</span><span class="co">//&quot;class B&quot;</span></span></code></pre></div></li>
<li><p>Не имеет смысла в качестве выражения использовать указатель, так как оператором <code>typeid</code> будет возвращено <code>type_info</code> типа указателя</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="kw">typeid</span><span class="op">(</span>pA<span class="op">).</span>name<span class="op">();</span><span class="co">//&quot;class A*&quot;</span></span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="kw">typeid</span><span class="op">(</span>pB<span class="op">).</span>name<span class="op">();</span><span class="co">//&quot;class B*&quot;</span></span></code></pre></div></li>
</ol>
<p>Замечания:</p>
<ol type="1">
<li><ul>
<li><p>если используется недействительный указатель</p></li>
<li><p>или код не был скомпилирован с ключом <code>/GR</code> вырабатывается исключение типа <code>non_rtti_object</code></p></li>
</ul></li>
<li><p>для совместимости с базовыми типами компилятор для каждого базового типа создает объект <code>type_info</code>, поэтому для базовых типов тоже можно использовать оператор <code>typeid</code>:</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>n<span class="op">)</span> <span class="op">==</span> <span class="kw">typeid</span> <span class="op">(</span><span class="dt">int</span><span class="op">))</span> <span class="op">...</span></span></code></pre></div></li>
<li><p>оператор <code>typeid</code> может быть использован для получения объекта <code>type_info</code> для параметра шаблона (глава «Обобщенное программирование»)</p></li>
</ol>
<h3 id="пример-использования-оператора-typeid">Пример использования оператора <code>typeid</code></h3>
<p>Дана иерархия классов:</p>
<p><img src="media/image46.svg" /></p>
<div class="sourceCode" id="cb271"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Shape</span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> F<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect <span class="op">:</span> <span class="kw">public</span> Shape</span>
<span id="cb271-7"><a href="#cb271-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb271-8"><a href="#cb271-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb271-9"><a href="#cb271-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> F<span class="op">()</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;I&#39;m Rect&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="op">})</span></span>
<span id="cb271-10"><a href="#cb271-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb271-11"><a href="#cb271-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circle <span class="op">:</span> <span class="kw">public</span> Shape</span>
<span id="cb271-12"><a href="#cb271-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb271-13"><a href="#cb271-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb271-14"><a href="#cb271-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> F<span class="op">()</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;l&#39;m Circle&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb271-15"><a href="#cb271-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Функция — фабрика фигур, которая случайным образом генерирует динамический объект одного из производных типов и возвращает указатель базового типа:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a>Shape<span class="op">*</span> Make<span class="op">()</span></span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>rand<span class="op">()</span> <span class="op">%</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> <span class="cf">return</span> <span class="kw">new</span> Rect<span class="op">;</span> </span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> <span class="cf">return</span> <span class="kw">new</span> Circle<span class="op">;</span></span>
<span id="cb272-7"><a href="#cb272-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb272-8"><a href="#cb272-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Требуется посчитать, сколько прямоугольников и сколько кружков создала функция и при создании любого объекта вывести тип созданной фигуры.</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>    Shape<span class="op">*</span> ar<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nRects <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> nCircles <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//здесь подсчитаем — сколько чего</span></span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//«насоздавалось»</span></span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true" tabindex="-1"></a>        ar<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> Make<span class="op">();</span> <span class="co">//создание очередного объекта </span></span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> <span class="kw">typeid</span><span class="op">(*</span>ar<span class="op">[</span>i<span class="op">]).</span>name<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">//диагностика что</span></span>
<span id="cb273-11"><a href="#cb273-11" aria-hidden="true" tabindex="-1"></a>                                               <span class="co">//создали</span></span>
<span id="cb273-12"><a href="#cb273-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">typeid</span><span class="op">(*</span>ar<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">==</span> <span class="kw">typeid</span><span class="op">(</span>Rect<span class="op">))</span> nRects<span class="op">++;</span> <span class="co">//подсчет</span></span>
<span id="cb273-13"><a href="#cb273-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> nCircles<span class="op">++;</span></span>
<span id="cb273-14"><a href="#cb273-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb273-15"><a href="#cb273-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb273-16"><a href="#cb273-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb273-17"><a href="#cb273-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> ar<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb273-18"><a href="#cb273-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb273-19"><a href="#cb273-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Использование других возможностей класса <code>type_info</code></strong> — определение порядка следования классов в иерархии наследования. Задана иерархия классов:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span> <span class="op">...</span> <span class="kw">virtual</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> B <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb274-4"><a href="#cb274-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb274-5"><a href="#cb274-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb274-6"><a href="#cb274-6" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> рВ <span class="op">=</span> <span class="kw">new</span> C<span class="op">;</span></span>
<span id="cb274-7"><a href="#cb274-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> рА <span class="op">=</span> рВ<span class="op">;</span></span>
<span id="cb274-8"><a href="#cb274-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>A<span class="op">).</span>before<span class="op">(</span><span class="kw">typeid</span><span class="op">(*</span>рА<span class="op">)))</span> <span class="op">...</span> <span class="co">//???</span></span>
<span id="cb274-9"><a href="#cb274-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>B<span class="op">).</span>before<span class="op">(</span><span class="kw">typeid</span><span class="op">(*</span>pA<span class="op">)))</span> <span class="op">...</span> <span class="co">//???</span></span>
<span id="cb274-10"><a href="#cb274-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>C<span class="op">).</span>before<span class="op">(</span><span class="kw">typeid</span><span class="op">(*</span>pA<span class="op">)))</span> <span class="op">...</span> <span class="co">//???</span></span>
<span id="cb274-11"><a href="#cb274-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>B<span class="op">).</span>before<span class="op">(</span><span class="kw">typeid</span><span class="op">(*</span>pB<span class="op">)))</span> <span class="op">...</span> <span class="co">//???</span></span>
<span id="cb274-12"><a href="#cb274-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb274-13"><a href="#cb274-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="оператор-dynamic_cast">Оператор <code>dynamic_cast</code></h3>
<p>Необходимость RTTI обусловлена тем, что при компиляции не всегда есть возможность выяснить: на какой целевой объект указывает указатель базового типа (или ссылается ссылка базового типа).</p>
<p>Восстановление «потерянного» типа объекта требует, чтобы была возможность «спросить» объект о его типе, а также должна быть операция преобразования типа, которая возвращала бы корректный указатель, если объект действительно имеет целевой тип, или «сообщала» о невозможности преобразования.</p>
<p>Формат:</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a><span class="kw">dynamic_cast</span><span class="op">&lt;</span>T<span class="op">*&gt;(</span>pointer<span class="op">)</span> <span class="co">//возвращает указатель типа Т*, если</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>                          <span class="co">//преобразование корректно, или 0</span></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a><span class="kw">dynamic_cast</span><span class="op">&lt;</span>T<span class="op">&amp;&gt;(</span>reference<span class="op">)</span> <span class="co">//возвращает ссылку типа Т&amp; если</span></span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//преобразование корректно, или </span></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//вырабатывает исключение std::bad_cast</span></span></code></pre></div>
<p>Модифицируем предыдущий пример:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a>    Shape<span class="op">*</span> ar<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nRects <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> nCircles <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//здесь подсчитаем — сколько чего </span></span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//«насоздавалось»</span></span>
<span id="cb276-7"><a href="#cb276-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb276-8"><a href="#cb276-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb276-9"><a href="#cb276-9" aria-hidden="true" tabindex="-1"></a>        ar<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> Make<span class="op">();</span> <span class="co">//создание очередного объекта</span></span>
<span id="cb276-10"><a href="#cb276-10" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> <span class="kw">typeid</span><span class="op">(*</span>ar<span class="op">[</span><span class="dv">1</span><span class="op">]).</span>name<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span><span class="co">//диагностика — что</span></span>
<span id="cb276-11"><a href="#cb276-11" aria-hidden="true" tabindex="-1"></a>                                              <span class="co">//создали</span></span>
<span id="cb276-12"><a href="#cb276-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">dynamic_cast</span><span class="op">&lt;</span>Rect<span class="op">*&gt;(</span>ar<span class="op">[</span>i<span class="op">]))</span> nRects<span class="op">++;</span><span class="co">//подсчет</span></span>
<span id="cb276-13"><a href="#cb276-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> nCircles<span class="op">++;</span></span>
<span id="cb276-14"><a href="#cb276-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb276-15"><a href="#cb276-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb276-16"><a href="#cb276-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb276-17"><a href="#cb276-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> ar<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb276-18"><a href="#cb276-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb276-19"><a href="#cb276-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Оператор <code>dynamic_cast</code> используется для проверки возможности приведения, поэтому:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> А <span class="op">{</span> <span class="op">...</span> <span class="kw">virtual</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> А <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> B <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a>    А<span class="op">*</span> pA <span class="op">=</span> <span class="kw">new</span> C<span class="op">;</span></span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> pB <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>B<span class="op">*&gt;(</span>pA<span class="op">);</span> <span class="co">//!=0</span></span>
<span id="cb277-8"><a href="#cb277-8" aria-hidden="true" tabindex="-1"></a>    C<span class="op">*</span> pC <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>C<span class="op">*&gt;(</span>pA<span class="op">);</span> <span class="co">//!=0</span></span>
<span id="cb277-9"><a href="#cb277-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> pA<span class="op">;</span></span>
<span id="cb277-10"><a href="#cb277-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Замечание: <code>dynamic_cast</code> не работает с <code>void*</code>-указателями</p>
</blockquote>
<h3 id="операторы-typeid-и-dynamic_cast-и-наследование">Операторы typeid и <code>dynamic_cast</code> и наследование</h3>
<p>Продемонстрируем разницу в использовании операторов <code>typeid</code> и <code>dynamic_cast</code>. Напоминаю: оператор <code>typeid</code> используется для определения точного типа, а <code>dynamic_cast</code> для проверки возможности приведения.</p>
<p>Задана иерархия классов:</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span> <span class="op">...</span> <span class="kw">virtual</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> B <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb278-5"><a href="#cb278-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb278-6"><a href="#cb278-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pA <span class="op">=</span> <span class="kw">new</span> C<span class="op">;</span></span>
<span id="cb278-7"><a href="#cb278-7" aria-hidden="true" tabindex="-1"></a>    C<span class="op">*</span> pC <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>C<span class="op">*&gt;(</span>pA<span class="op">);</span><span class="co">//!=0</span></span>
<span id="cb278-8"><a href="#cb278-8" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> pC <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>B<span class="op">*&gt;(</span>pA<span class="op">);</span> <span class="co">//!=0</span></span>
<span id="cb278-9"><a href="#cb278-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Но!!!</span></span>
<span id="cb278-10"><a href="#cb278-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> b <span class="op">=</span> <span class="kw">typeid</span><span class="op">(*</span>pA<span class="op">)</span> <span class="op">==</span> <span class="kw">typeid</span><span class="op">(</span>C<span class="op">);</span><span class="co">//true</span></span>
<span id="cb278-11"><a href="#cb278-11" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="kw">typeid</span><span class="op">(*</span>pA<span class="op">)</span> <span class="op">==</span> <span class="kw">typeid</span><span class="op">(</span>B<span class="op">);</span><span class="co">//false</span></span>
<span id="cb278-12"><a href="#cb278-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>При множественном наследовании механизм RTTI тоже работает, так как в объекте <code>type_info</code> есть вся информация как о производном типе, так и обо всех предках:</p>
<p>Задана иерархия классов:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span> <span class="op">...</span> <span class="kw">virtual</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">{</span> <span class="op">...</span> <span class="kw">virtual</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> A<span class="op">,</span> <span class="kw">public</span> B <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main <span class="op">()</span></span>
<span id="cb279-5"><a href="#cb279-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb279-6"><a href="#cb279-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> pA <span class="op">=</span> <span class="kw">new</span> C<span class="op">;</span></span>
<span id="cb279-7"><a href="#cb279-7" aria-hidden="true" tabindex="-1"></a>    C<span class="op">*</span> pC <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>C<span class="op">*&gt;(</span>pA<span class="op">);</span><span class="co">//!=0</span></span>
<span id="cb279-8"><a href="#cb279-8" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> pB <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>B<span class="op">*&gt;(</span>pA<span class="op">);</span> <span class="co">//!=0</span></span>
<span id="cb279-9"><a href="#cb279-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="когда-возникает-необходимость-rtti">Когда возникает необходимость RTTI</h2>
<p>Например, при использовании сторонней библиотеки классов Вы наследуете свои специализированные производные классы от классов, предоставляемых библиотекой. Работа с библиотечными классами поддерживается каркасом приложения, НО! Библиотека ничего не знает о Вашей специализированной производной части. Поэтому может возникнуть следующая ситуация: Вы создали объект своего (производного) типа, «передали» его для выполнения базовой работы каркасу приложения (при этом информация о производной части потеряна), а потом каркас приложения может вызвать виртуальный метод другого Вашего производного класса, передавая в качестве параметра ссыпку или указатель базового типа на Ваш объект. Обратите внимание! — при этом естественным образом теряется информация о пользовательском специализированном типе ⇒ возникает необходимость восстановить целевой тип, чтобы пользоваться спецификой производной части объекта.</p>
<p><img src="media/image47.svg" /></p>
<h1 id="тема-xii.-исключительные-ситуации-exceptions">Тема XII. Исключительные ситуации (exceptions)</h1>
<h2 id="что-такое-исключительные-ситуации">Что такое исключительные ситуации</h2>
<p>При написании сколько-нибудь серьезных приложений большую роль играет обработка всевозможных ошибочных ситуаций, которые могут возникнуть во время работы приложения. Ошибочные ситуации можно разделить на две большие категории:</p>
<p><img src="media/image48.svg" /></p>
<p>Если Ваше приложение не отреагирует на такую ситуацию, то, скорее всего Вы увидите сообщение <strong>«Unhandled exception»</strong>, Ваше приложение будет аварийно завершено,… а Вашу программу вряд ли кто-нибудь купит.</p>
<p><img src="media/image49.svg" /></p>
<p><strong>Проблема</strong> возникает тогда, когда <strong>в месте возникновения ошибочной ситуации у Вас «нет контекста» для ее разрешения</strong>. Обычно ситуация «нелокальных» проблем появляется в случае разработки большого проекта несколькими программистами или использования независимо разработанных библиотек. При этом может возникнуть следующая ситуация:</p>
<p><img src="media/image50.svg" /></p>
<p>То есть автор вызываемого модуля может обнаружить «неприятности» во время выполнения, но, как правило, не имеет представления о том. что делать в этом случае. Автор вызывающего модуля может знать, как поступить в случае возникновения ошибок, но не в состоянии их обнаружить.</p>
<p>Если же «вложенность» вызовов функций значительна, то возникновение исключительной ситуации может возникнуть на нижнем уровне, а обработка ошибки должна быть произведена на самом верхнем уровне:</p>
<p><img src="media/image51.svg" /></p>
<p>Замечание 1: Но! Механизм обработки исключений дорогой ⇒ Следует отметить, что целью обработки исключений является решение <strong>«нелокальных»</strong> по своей природе проблем. Поэтому, если проблема может быть решена локально, почти всегда так ее и следует решать.</p>
<p>Обработку исключений имеет смысл использовать тогда, когда можно восстановить (починить) программу для продолжения работы.</p>
<p>Замечание 2: существуют два уровня обработки исключений:</p>
<ul>
<li><p>структурная обработка исключений (SEH) — используется в основном для обработки hardware-ных исключительных ситуаций (деление на 0, обращение по недействительному адресу…);</p></li>
<li><p>обработка исключений C++</p></li>
</ul>
<h2 id="способы-отслеживания-аварийных-ситуаций">Способы отслеживания «аварийных» ситуаций</h2>
<h3 id="прекращение-выполнения-программы">Прекращение выполнения программы</h3>
<p>Прекращение выполнения всей программы при возникновении нештатной ситуации — это крайняя мера. Поэтому еще в древние времена (до развития формальной модели обработки исключений) программисты боролись с непредвиденными ситуациями множеством неструктурированных способов, пытаясь, во что бы то ни стало продолжить выполнение своей программы.</p>
<h3 id="возвращение-функцией-значения-статуса-кода-завершения">Возвращение функцией значения статуса (кода завершения)</h3>
<p>Замечание: этот подход прост и достаточно эффективен ⇒ никто его не отменяет для решения локальных нештатных ситуаций.</p>
<p>Функция может возвращать некоторое значение в случае успешного завершения (например, ненулевое значение) и определенное (нулевое) значение в случае ошибки. При таком подходе вызываемая функция обнаруживает ошибку, а вызывающая эту ошибку должна обрабатывать. Это означает, что программист каждый раз после вызова функции должен осуществлять проверку кода завершения, анализировать тип ошибки, обрабатывать данный тип ошибки. Если представить себе пример с N-вложенным вызовом функций, то становится очевидным, что <strong>программист-зануда</strong> погрязнет в скрупулёзной обработке всех возможных ошибок (а его программа разрастется так, что большая часть кода окажется посвященной обработке неожиданных ситуаций, а не ожидаемых). В той же ситуации <strong>среднеответственный программист</strong> пренебрежет обработкой большей части ошибок, рассчитывая только на штатные ситуации…</p>
<p>Кроме того если для обработки ошибки не обойтись одним возвращаемым значением (то есть важен не только сам факт возникновения ошибки, но и ее тип)? Для запоминания типа ошибки обычно использовалась глобальная переменная (например, <code>errno</code> содержит код ошибки).</p>
<h3 id="статус-завершения-системных-вызовов">Статус завершения системных вызовов</h3>
<p>В стандартной библиотеке есть глобальная переменная <code>errno</code>, которая предназначена для формирования кода системных ошибок. В принципе, любой системный вызов это значение формирует, но так как переменная глобальная, код ошибки можно получить только непосредственно после вызова системной функции.</p>
<h3 id="выявление-ошибок-в-debug-версии">Выявление ошибок в Debug-версии</h3>
<p>Диагностический макрос <code>assert</code> — хорош для выявления тех ошибок, которые зависят от программиста, но не спасает от ошибок времени выполнения.</p>
<h3 id="обработка-ошибок-с-помощью-функций-обратного-вызова">Обработка ошибок с помощью функций обратного вызова</h3>
<p>Вызывающая функция (клиент) передает вызываемой (серверу) указатель на другую клиентскую функцию, которую сервер должен вызвать в случае возникновения ошибки.</p>
<p>Замечание: этот прием часто используется при использовании системных сервисов — смысл в том то в качестве одного из параметров функции или каким-нибудь еще способом (в качестве поля структуры) передается адрес пользовательской функции — функции обратного вызова (callback).</p>
<p>В C++ эта технология, например, используется для обработки отказов при динамическом распределении памяти. Функция <code>set_new_handler()</code> позволяет Вашей программе установить Ваш специализированный обработчик ситуации, который будет вызываться системой в случае нехватки памяти вместо стандартного. Причем, «подменять» стандартный обработчик своим можно только на некоторое (потенциально опасное) время. Например:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;new&gt;</span></span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> BIG_NUMBER <span class="op">=</span> <span class="bn">0xfffffff</span><span class="op">;</span></span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> p<span class="op">;</span></span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> my_handler<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb280-5"><a href="#cb280-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb280-6"><a href="#cb280-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Ваш обработчик</span></span>
<span id="cb280-7"><a href="#cb280-7" aria-hidden="true" tabindex="-1"></a>    BIG_NUMBER <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb280-8"><a href="#cb280-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb280-9"><a href="#cb280-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb280-10"><a href="#cb280-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb280-11"><a href="#cb280-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>old_handler<span class="op">)(</span><span class="dt">void</span><span class="op">)</span> <span class="op">=</span> <span class="bu">std::</span>set_new_handler<span class="op">(</span>my_handler<span class="op">);</span></span>
<span id="cb280-12"><a href="#cb280-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">//установили свой обработчик</span></span>
<span id="cb280-13"><a href="#cb280-13" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>BIG_NUMBER<span class="op">];</span> <span class="co">//если памяти не хватает, будет вызван </span></span>
<span id="cb280-14"><a href="#cb280-14" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//Ваш обработчик, где Вы постараетесь </span></span>
<span id="cb280-15"><a href="#cb280-15" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//справиться с ситуацией</span></span>
<span id="cb280-16"><a href="#cb280-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>set_new_handler<span class="op">(</span>old_handler<span class="op">);</span> <span class="co">//восстановили прежний </span></span>
<span id="cb280-17"><a href="#cb280-17" aria-hidden="true" tabindex="-1"></a>                                       <span class="co">//обработчик</span></span>
<span id="cb280-18"><a href="#cb280-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание: по умолчанию указатель, возвращаемый <code>set_new_handler</code>, равен нулю.</p>
<h3 id="выполнение-глобального-перехода-при-возникновении-ошибки">Выполнение глобального перехода при возникновении ошибки</h3>
<p>Функция <code>setjmp()</code> позволяет программисту запомнить точку возврата и состояние программы на момент выполнения <code>setjmp()</code> в структуре предопределенного вида. Функция <code>longjmp()</code> позволяет вернуть управление посредством сохраненных данных в структуре <code>jmp_buf</code>.</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="co">//client.срр</span></span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;csetjmp&gt;</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a>jmp_buf buf<span class="op">;</span></span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb281-5"><a href="#cb281-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb281-6"><a href="#cb281-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret <span class="op">=</span> setjmp<span class="op">(</span>buf<span class="op">);</span></span>
<span id="cb281-7"><a href="#cb281-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>При этом она корректно восстанавливает стек</em>. Неудобство — буферов может быть много…</p>
<p>Будучи перенесена в C++, функция <code>longjmp()</code> приобрела один существенный недостаток — она не вызывает деструкторы локальных объектов.</p>
<h3 id="малоизвестная-и-малоиспользуемая-часть-старой-стандартной-библиотеки-с">Малоизвестная и малоиспользуемая часть старой стандартной библиотеки С</h3>
<p>Функции</p>
<p><code>signal()</code> — для определения — что произошло</p>
<p><code>raise()</code> — для генерации события</p>
<p>Поведение по умолчанию <code>signal</code> означает аварийное завершение программы с кодом 3. Проблема — та же самая + номера ошибок должны быть уникальными.</p>
<h2 id="встроенные-средства-c-для-обработки-исключений-c-exception-handling">Встроенные средства C++ для обработки исключений (C++ exception handling)</h2>
<p>Все перечисленные выше способы обработки представляют собой набор разнородных средств, предназначенных для решения разных аварийных ситуаций.</p>
<p>Встроенная поддержка обработки исключений в С++ появилась сравнительно недавно. Достоинствами механизма обработки исключительных ситуаций являются:</p>
<ul>
<li><p>обработку нештатных ситуаций все равно предусмотреть нужно, ситуации разные, а способ борьбы с ними <strong>унифицирован</strong>.</p></li>
<li><p><strong>структура</strong> текста программы улучшается. Программист может отделить написание рабочего кода (основная работа) от написания обработки нештатных ситуаций (и отложить это рутинное удовольствие «на потом», то есть предполагается, что к этому можно вернуться и позже)</p></li>
</ul>
<p>Идея — нужно передать управление и информацию об ошибке из того места, где она возникла, туда, где она может быть обработана (минуя все промежуточные инстанции)! — Похоже на посылку сообщения</p>
<p>Если обработка исключений не предусмотрена, при возникновении любого исключения программа будет завершена аварийно!!!</p>
<p><img src="media/image52.svg" /></p>
<p>Язык C++ включает встроенные средства для обработки аномальных ситуаций (exceptions), возникающих во время выполнения программы - операторы <code>throw</code>, <code>catch</code>, <code>try</code>. Оператор try открывает блок кода, в котором может произойти ошибка. Если ошибка произошла, то оператор <code>throw</code> вызывает исключение. Обработчик исключения представляет собой блок кода, который начинается оператором <code>catch</code>.</p>
<p>Если предусмотреть обработку исключений:</p>
<p><img src="media/image53.svg" /></p>
<h3 id="оператор-throw-сравнение-с-return">Оператор <code>throw</code> — сравнение с <code>return</code></h3>
<p>Оператор <code>throw</code> очень похож на инструкцию <code>return</code>, но главные отличия:</p>
<ul>
<li><p><strong>куда</strong> происходит передача управления!!!</p></li>
<li><p><strong>где</strong> вызываются деструкторы для всех промежуточных стековых объектов, которые были созданы на момент генерации исключения (в частности локальных объектов вызываемой функции)</p></li>
<li><p><strong>как</strong> передается объект-исключение и где вызывается для объекта-исключения деструктор</p></li>
</ul>
<p><img src="media/image54.svg" /></p>
<p>Способы передачи объекта-исключения:</p>
<ul>
<li><p>по значению:</p>
<ol type="1">
<li><p>— неэффективно, так как в месте генерации исключения вызывается конструктор копирования</p></li>
<li><p>если генерируем объект В, а принимаем А, то конструктор копирования только базовой части ⇒ в обработчике можем пользоваться только базовой частью объекта-исключения</p></li>
<li><p>внутри обработчика работа с копией</p></li>
</ol></li>
<li><p>по указателю (объект-исключение автоматически при выполнении throw не копируется):</p>
<ol type="1">
<li><p>адрес локального объекта — плохо, так как для него будет вызван деструктор до выполнения тела обработчика</p></li>
<li><p>адрес динамического объекта плохо, так как нет уверенности, что в обработчике программист — delete</p></li>
<li><p>стандартные исключения можно принять только по значению или по ссылке</p></li>
</ol></li>
<li><p>по ссылке — в месте генерации исключения передается адрес объекта-исключения, но деструктор для него будет вызван только по закрывающей скобке обработчика</p></li>
</ul>
<p><strong>в обработчике получаем адрес объекта целевого типа, даже если принимаем ссылку на базовый тип ⇒ всегда возможен вызов виртуальных методов!</strong></p>
<h3 id="операторы-try-и-catch">Операторы <code>try</code> и <code>catch</code></h3>
<p>Функция, которая собирается обрабатывать ошибку, должна:</p>
<ol type="1">
<li><p>объявить блок, в котором эта ошибка может возникнуть — блок <code>try</code>.</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span></span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>сообщить компилятору какие ошибки ожидаются и как она собирается обрабатывать — обработчики исключений (<code>catch</code>).</p></li>
</ol>
<p>Замечание: непосредственно за try должен следовать хотя бы один обработчик — <code>catch</code></p>
<p>Конструкция</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span><span class="op">(</span>тип переменной исключения <span class="op">[</span>имя формального параметра<span class="op">])</span></span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb283-4"><a href="#cb283-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>называется обработчиком исключения. Она может и должна использоваться только сразу после блока <code>try</code> или после другого обработчика <code>catch</code>.</p>
<p>Пэ синтаксису объявление оператора <code>catch</code> похоже на определение функции, в котором обязательными являются типы аргументов, а имена аргументов должны присутствовать только если данный аргумент «задействован» в коде функции.</p>
<h3 id="пример">Пример</h3>
<div class="sourceCode" id="cb284"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Array</span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb284-3"><a href="#cb284-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_ar</span><span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb284-4"><a href="#cb284-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb284-5"><a href="#cb284-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span></span>
<span id="cb284-6"><a href="#cb284-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb284-7"><a href="#cb284-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="cf">return</span> <span class="va">m_ar</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb284-8"><a href="#cb284-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">throw</span> <span class="st">&quot;Index out of range&quot;</span><span class="op">;</span></span>
<span id="cb284-9"><a href="#cb284-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">//Синтаксически оператор throw похож на оператор return.</span></span>
<span id="cb284-10"><a href="#cb284-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> </span>
<span id="cb284-11"><a href="#cb284-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb284-12"><a href="#cb284-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb284-13"><a href="#cb284-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb284-14"><a href="#cb284-14" aria-hidden="true" tabindex="-1"></a>    Array ar<span class="op">;</span></span>
<span id="cb284-15"><a href="#cb284-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb284-16"><a href="#cb284-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb284-17"><a href="#cb284-17" aria-hidden="true" tabindex="-1"></a>        ar<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb284-18"><a href="#cb284-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> error<span class="op">)</span></span>
<span id="cb284-19"><a href="#cb284-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb284-20"><a href="#cb284-20" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> error <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">//программисту предупреждение</span></span>
<span id="cb284-21"><a href="#cb284-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb284-22"><a href="#cb284-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">//выполнение программы продолжается</span></span>
<span id="cb284-23"><a href="#cb284-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Основная идея состоит в том, что <code>Array::operator[]</code>, обнаружившая проблему, которую она не в состоянии решить, генерирует (<code>throw</code>) исключение, чтобы вызывающая функция «не затерла» что-нибудь за пределами выделенной памяти.</p>
<p>Обычно одной диагностики о произошедшей ситуации недостаточно Например, в нашем случае неплохо:</p>
<ul>
<li><p>сообщить в вызывающую функцию значение «некорректного» индекса - <code>throw i</code>;</p></li>
<li><p>вырабатывать исключение более сложного типа, чтобы в объекте такого типа можно передать гораздо больше информации</p></li>
</ul>
<div class="sourceCode" id="cb285"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyArrayError</span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_wrongIndex</span><span class="op">;</span></span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_High</span><span class="op">;</span></span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a>    MyArrayError<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span> <span class="va">m_wrongIndex</span> <span class="op">=</span> n<span class="op">;</span> <span class="va">m_High</span> <span class="op">=</span> c<span class="op">;</span> <span class="op">}</span></span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb285-7"><a href="#cb285-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Array</span>
<span id="cb285-8"><a href="#cb285-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb285-9"><a href="#cb285-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_ar</span><span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb285-10"><a href="#cb285-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb285-11"><a href="#cb285-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span></span>
<span id="cb285-12"><a href="#cb285-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb285-13"><a href="#cb285-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="cf">return</span> <span class="va">m_ar</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb285-14"><a href="#cb285-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">throw</span> MyArrayError<span class="op">(</span>i<span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb285-15"><a href="#cb285-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb285-16"><a href="#cb285-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb285-17"><a href="#cb285-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb285-18"><a href="#cb285-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb285-19"><a href="#cb285-19" aria-hidden="true" tabindex="-1"></a>    Array ar<span class="op">;</span></span>
<span id="cb285-20"><a href="#cb285-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb285-21"><a href="#cb285-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb285-22"><a href="#cb285-22" aria-hidden="true" tabindex="-1"></a>        ar<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb285-23"><a href="#cb285-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>MyArrayError<span class="op">&amp;</span> error<span class="op">)</span></span>
<span id="cb285-24"><a href="#cb285-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb285-25"><a href="#cb285-25" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> <span class="st">&quot;index out of range&quot;</span> <span class="op">&lt;&lt;</span> error<span class="op">.</span><span class="va">m_wrongIndex</span></span>
<span id="cb285-26"><a href="#cb285-26" aria-hidden="true" tabindex="-1"></a>             <span class="op">&lt;&lt;</span> <span class="st">&quot;index must be &gt;= 0 or &lt; &quot;</span> <span class="op">&lt;&lt;</span> error<span class="op">.</span><span class="va">m_High</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb285-27"><a href="#cb285-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span><span class="co">//вызывается деструктор для объекта-исключения</span></span>
<span id="cb285-28"><a href="#cb285-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="обработка-нескольких-типов-исключений">Обработка нескольких типов исключений</h3>
<p>Обычно в программе в процессе выполнения может возникнуть не одна, а несколько ошибочных ситуаций разного типа. Хорошей практикой является для каждой такой ситуации определить свой тип исключения. В общем случае структура блока программы, в котором могут возникнуть исключения, выглядит следующим образом:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Above</span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_wrongIndex</span><span class="op">;</span></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_High</span><span class="op">;</span></span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a>    Above<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span> <span class="va">m_wrongIndex</span> <span class="op">=</span> n<span class="op">;</span> <span class="va">m_High</span> <span class="op">=</span> c<span class="op">;</span> <span class="op">}</span></span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb286-7"><a href="#cb286-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Below</span>
<span id="cb286-8"><a href="#cb286-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb286-9"><a href="#cb286-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_wrongIndex</span><span class="op">;</span></span>
<span id="cb286-10"><a href="#cb286-10" aria-hidden="true" tabindex="-1"></a>    Below<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> <span class="va">m_wrongIndex</span> <span class="op">=</span> n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb286-11"><a href="#cb286-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb286-12"><a href="#cb286-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-13"><a href="#cb286-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">&amp;</span> Array<span class="op">::</span><span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span></span>
<span id="cb286-14"><a href="#cb286-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb286-15"><a href="#cb286-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">throw</span> Below<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb286-16"><a href="#cb286-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">10</span><span class="op">)</span> <span class="cf">throw</span> Above<span class="op">(</span>i<span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb286-17"><a href="#cb286-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">m_ar</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb286-18"><a href="#cb286-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb286-19"><a href="#cb286-19" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span></span>
<span id="cb286-20"><a href="#cb286-20" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb286-21"><a href="#cb286-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb286-22"><a href="#cb286-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>Above<span class="op">&amp;</span> er<span class="op">)</span></span>
<span id="cb286-23"><a href="#cb286-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb286-24"><a href="#cb286-24" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="op">...;</span></span>
<span id="cb286-25"><a href="#cb286-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>Below<span class="op">&amp;</span> er<span class="op">)</span></span>
<span id="cb286-26"><a href="#cb286-26" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb286-27"><a href="#cb286-27" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="op">...;</span></span>
<span id="cb286-28"><a href="#cb286-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечания:</p>
<ul>
<li><p>каждый обработчик соответствует своему конкретному типу ошибки ( то есть при возникновении ошибки данного типа, управление будет передано именно сюда).</p></li>
<li><p>В скобках любого оператора <code>catch</code> указывается тип объекта, который может быть перехвачен данным обработчиком.</p></li>
<li><p>Если нет соответствующего обработчика, вызывается <code>unexpected</code></p></li>
<li><p>Обработчики «просматриваются» в том порядке, в котором их привел программист, поэтому в том случае, когда типы исключений связаны наследованием, обработчик с объектом исключения производного типа должен предшествовать обработчику с исключением базового типа.</p></li>
<li><p>Можно предусмотреть обработку всех явно не указанных в обработчиках <code>catch</code> типов исключений посредством:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span></span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Something is wrong!&quot;</span><span class="op">;</span></span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
<p>Замечание: если существует такой обработчик «по умолчанию», он должен быть последним в списке обработчиков</p>
<h3 id="обработчики-исключений-могут">Обработчики исключений могут</h3>
<ol type="1">
<li><p>вызвать <code>abort()</code>, если ситуацию поправить невозможно</p></li>
<li><p>повторно сгенерировать то же самое исключение — то есть передать его выше</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span> <span class="cf">throw</span><span class="op">;</span> <span class="op">}</span> <span class="co">//rethrow</span></span></code></pre></div></li>
<li><p>обработать на своем уровне текущее исключение, а для уровня «выше» сгенерировать другое исключение (запаковать другую информацию)</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span>My1<span class="op">&amp;</span> х<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="cf">throw</span> Му<span class="dv">2</span><span class="op">();</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div></li>
<li><p>выполнить любое восстановительное действие и продолжить работу программы</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> I <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> BIG <span class="op">=</span> <span class="bn">0x7fffffff</span><span class="op">;</span></span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">**</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb290-4"><a href="#cb290-4" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span></span>
<span id="cb290-5"><a href="#cb290-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb290-6"><a href="#cb290-6" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">*</span> <span class="op">[</span>BIG<span class="op">];</span></span>
<span id="cb290-7"><a href="#cb290-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(;</span> I <span class="op">&lt;</span> BIG<span class="op">;</span> I<span class="op">++)</span> p<span class="op">[</span>I<span class="op">]</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">[</span>BIG<span class="op">];</span></span>
<span id="cb290-8"><a href="#cb290-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>bad_ailoc<span class="op">&amp;</span> er<span class="op">)</span></span>
<span id="cb290-9"><a href="#cb290-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb290-10"><a href="#cb290-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Можно использовать только то, для чего удалось выделить</span></span>
<span id="cb290-11"><a href="#cb290-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//память!!!</span></span>
<span id="cb290-12"><a href="#cb290-12" aria-hidden="true" tabindex="-1"></a>    BIG <span class="op">=</span> I<span class="op">;</span></span>
<span id="cb290-13"><a href="#cb290-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>удалить причину ошибки и повторить вызов функции, вызвавшей ошибку</p></li>
<li><p>освободить ресурсы (например, память) и продолжить выполнение</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> I <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> BIG <span class="op">=</span> <span class="bn">0x7fffffff</span><span class="op">;</span></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">**</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span></span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">*</span> <span class="op">[</span>BIG<span class="op">];</span> <span class="cf">for</span> <span class="op">(;</span> I <span class="op">&lt;</span> BIG<span class="op">;</span> I<span class="op">++)</span> p<span class="op">[</span>I<span class="op">]</span> <span class="op">=</span> <span class="kw">new</span></span>
<span id="cb291-7"><a href="#cb291-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span><span class="op">[</span>BIG<span class="op">];</span></span>
<span id="cb291-8"><a href="#cb291-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>bad allocs er<span class="op">)</span></span>
<span id="cb291-9"><a href="#cb291-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb291-10"><a href="#cb291-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Все, что удалось захватить, нужно освободить!!!</span></span>
<span id="cb291-11"><a href="#cb291-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>р<span class="op">)</span></span>
<span id="cb291-12"><a href="#cb291-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> I<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb291-13"><a href="#cb291-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[]</span> p<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb291-14"><a href="#cb291-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span><span class="op">[]</span> p<span class="op">;</span></span>
<span id="cb291-15"><a href="#cb291-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<h3 id="function-level-try-блок">Function-level <code>try</code>-блок</h3>
<p>Можно все тело функции заключить в блок <code>try</code>. При этом последовательность выполнения кода отмечена цифрами 1-2-3</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> MyEr<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="cf">try</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="st">&quot;error&quot;</span><span class="op">;</span> <span class="co">//1</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> p<span class="op">)</span></span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> p<span class="op">;</span> <span class="co">//2</span></span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb292-10"><a href="#cb292-10" aria-hidden="true" tabindex="-1"></a>    MyEr<span class="op">();</span></span>
<span id="cb292-11"><a href="#cb292-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//3</span></span>
<span id="cb292-12"><a href="#cb292-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="последовательность-выполнения-кода-и-выбор-исключений">Последовательность выполнения кода и выбор исключений</h2>
<ul>
<li><p>Если код в <code>try</code>-блоке (или код функции, вызываемой из этого блока) генерирует исключение, будут проверяться обработчики данного блока <code>try</code>. Остаток блока <code>try</code> игнорируется!!!</p></li>
<li><p>Если сгенерированное исключение имеет тип. указанный в одном из обработчиков, будет выполнен этот обработчик.</p></li>
<li><p>Если исключение не генерируется, то все обработчики игнорируются.</p></li>
<li><p>Если исключение сгенерировано, и ни один обработчик не перехватил его, выполнение программы прекращается специальной функцией стандартной библиотеки — <code>unexpected</code></p></li>
</ul>
<div class="sourceCode" id="cb293"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span></span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>    func<span class="op">();</span></span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//мы попадем сюда только в том случае, если func() не возбудит</span></span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//исключения</span></span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>TYPE1<span class="op">&amp;</span> er<span class="op">)</span></span>
<span id="cb293-8"><a href="#cb293-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb293-9"><a href="#cb293-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//обработка исключения типа TYPE1</span></span>
<span id="cb293-10"><a href="#cb293-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>TYPE2<span class="op">&amp;</span> er<span class="op">)</span></span>
<span id="cb293-11"><a href="#cb293-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb293-12"><a href="#cb293-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//обработка исключения типа TYPE2</span></span>
<span id="cb293-13"><a href="#cb293-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb293-14"><a href="#cb293-14" aria-hidden="true" tabindex="-1"></a><span class="co">//сюда мы попадем, если a) func() не сгенерировала исключения,</span></span>
<span id="cb293-15"><a href="#cb293-15" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//б) сгенерированы исключения типа TYPE1 или </span></span>
<span id="cb293-16"><a href="#cb293-16" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//TYPE2, а обработчики этих исключений в свою </span></span>
<span id="cb293-17"><a href="#cb293-17" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//очередь не сгенерировали исключения или </span></span>
<span id="cb293-18"><a href="#cb293-18" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//некоторым другим способом не изменили </span></span>
<span id="cb293-19"><a href="#cb293-19" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//последовательность исполняемого кода</span></span>
<span id="cb293-20"><a href="#cb293-20" aria-hidden="true" tabindex="-1"></a><span class="co">//unexpected!!!</span></span></code></pre></div>
<h3 id="обработка-непредусмотренных-исключений">Обработка непредусмотренных исключений</h3>
<ol type="1">
<li><p>Программист может предусмотреть обработчик «по умолчанию»</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span></span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb294-3"><a href="#cb294-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//здесь можно обработать все остальные исключения</span></span>
<span id="cb294-4"><a href="#cb294-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>При этом такой обработчик должен быть последним!!!</p></li>
<li><p>Что происходит, если обработка предусмотрена на другом уровне</p>
<p>Если самый внутренний <code>catch</code> исключение не обработал, оно «передается» выше на следующий уровень. <strong>Поиск продолжается до самого внешнего блока <code>try</code></strong></p></li>
<li><p>Что происходит, <strong>если программист нигде не предусмотрел обработку</strong> какого-то конкретного или всех исключений.</p></li>
</ol>
<p>Замечание: если возникает неперехваченное исключение, никакого clean_up не происходит (деструкторы не вызываются)</p>
<p><img src="media/image56.svg" /></p>
<h3 id="обработка-неперехваченных-исключений">Обработка неперехваченных исключений</h3>
<p><img src="media/image57.svg" /></p>
<p>Пример:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> my_unexpected<span class="op">()</span></span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;I&#39;ll be back!!!&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a>    exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb295-8"><a href="#cb295-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb295-9"><a href="#cb295-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>рf<span class="op">)()</span> <span class="op">=</span> set_unexpected<span class="op">(</span>my_unexpected<span class="op">);</span></span>
<span id="cb295-10"><a href="#cb295-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//f2();</span></span>
<span id="cb295-11"><a href="#cb295-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb295-12"><a href="#cb295-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb295-13"><a href="#cb295-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span></span>
<span id="cb295-14"><a href="#cb295-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb295-15"><a href="#cb295-15" aria-hidden="true" tabindex="-1"></a>            f1<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb295-16"><a href="#cb295-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb295-17"><a href="#cb295-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">catch</span> <span class="op">(</span>A<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;A&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb295-18"><a href="#cb295-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">catch</span> <span class="op">(</span>B<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;B&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb295-19"><a href="#cb295-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">catch</span> <span class="op">(</span>C<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;C&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb295-20"><a href="#cb295-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb295-21"><a href="#cb295-21" aria-hidden="true" tabindex="-1"></a>    set_unexpected<span class="op">(</span>pf<span class="op">);</span></span>
<span id="cb295-22"><a href="#cb295-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="спецификация-исключений">Спецификация исключений</h3>
<p>Если Вы предполагаете, что Вашей функцией (вырабатывающей исключение) может пользоваться другой программист, то</p>
<ul>
<li><p>Вы не обязаны указывать, какого типа исключения функция вырабатывает,</p></li>
<li><p>но цивилизованный подход заключается в спецификации этих исключений.</p></li>
</ul>
<p>Объявление функций с появлением механизма исключений тоже изменилось ⇒ появилось новое понятие — спецификация исключений. Пока можно рассматривать спецификацию исключений в качестве одной из возможностей документирования текста программы.</p>
<p>Замечание 1: спецификация исключений должна быть указана как при объявлении, так и при определении функции!</p>
<p>Замечание 2: спецификация исключений функцию на самом деле программиста ни к чему не обязывает, то есть, несмотря на «обещания» функция может выработать исключение любого вида, а компилятор выдаст только предупреждение. Исключение будет сгенерировано и по общим правилам обработано или не обработано!!!</p>
<ol type="1">
<li><p>Если спецификация исключений отсутствует, функция может инициировать любые исключения</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">();</span> <span class="co">//что угодно</span></span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">()</span> <span class="cf">throw</span><span class="op">(...);</span> <span class="co">//гораздо «читабельнее» Microsoft specific</span></span></code></pre></div></li>
<li><p>если Вы уверены, что Ваша функция никогда не будет инициировать исключения, то лучше сообщить об этом компилятору и пользователю-программисту</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">()</span> <span class="cf">throw</span><span class="op">();</span> <span class="co">//не должна инициировать исключений</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="ex">__declspec(nothrow) F(); //Microsoft specific</span></span></code></pre></div></li>
</ol>
<p>Тогда при попытке выработать в функции исключение компилятор выдаст <em>предупреждение</em>:</p>
<pre><code>warning С4297: &#39;f&#39; : function assumed not to throw an exception but does
    __declspec(nothrow) or throw() was specified on the function</code></pre>
<p>Но! исключение будет все равно выработано!!!</p>
<p>Замечание: такая функция сама не генерирует исключения, но может передавать дальше исключения, получаемые ею от вызываемых функций</p>
<ol start="3" type="1">
<li><p>функция инициирует исключения нескольких типов</p>
<pre><code>void F() throw(int, Error&amp;, char*);</code></pre></li>
</ol>
<p>Замечание: если функция вырабатывает исключения других видов, то они все равно будут сгенерированы, но компилятор выдаст предупреждение, а Вы получите <strong>«Unhandled exception»</strong></p>
<p>Замечание: если Вы объявили две функции, отличающиеся только спецификацией исключений, то компилятор их различить не сможет:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">()</span> <span class="cf">throw</span><span class="op">();</span></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">()</span> <span class="cf">throw</span><span class="op">(</span><span class="dt">int</span><span class="op">);</span> <span class="co">//redefinition</span></span></code></pre></div>
<h2 id="специфика-оператора-new">Специфика оператора <code>new</code></h2>
<p>В старых версиях C++ требовалось, чтобы оператор <code>new</code> в случае нехватки памяти возвращал 0. Сейчас <code>new</code> должен генерировать исключение <code>std::bad_alloc</code>, но существует огромное количество кода, написанного до изменения спецификации ⇒ поэтому на самом деле существуют <strong>несколько форм оператора <code>new</code>.</strong></p>
<ol type="1">
<li><p><code>cpp     void* operator new(size_t n); //если памяти не хватает,                                    //вырабатывается исключение     void operator delete(void*);//соответствующий delete</code></p></li>
<li><p>array <code>new</code> and <code>delete</code></p></li>
</ol>
<p>Пример:</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;new&gt;</span></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> p<span class="op">;</span></span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb301-6"><a href="#cb301-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb301-7"><a href="#cb301-7" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="kw">new</span> A<span class="op">;</span> <span class="co">//компилятор интерпретирует как</span></span>
<span id="cb301-8"><a href="#cb301-8" aria-hidden="true" tabindex="-1"></a>                   <span class="co">//p = new (sizeof(A)); генерирует std::bad_alloc</span></span>
<span id="cb301-9"><a href="#cb301-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>p <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">...</span> <span class="co">//Это условие не выполнится никогда!!!</span></span>
<span id="cb301-10"><a href="#cb301-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>bad_alloc<span class="op">&amp;</span> a<span class="op">)</span></span>
<span id="cb301-11"><a href="#cb301-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb301-12"><a href="#cb301-12" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> a<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">//выведет диагностику</span></span>
<span id="cb301-13"><a href="#cb301-13" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span><span class="co">//обезопасили себя от использования недействительного </span></span>
<span id="cb301-14"><a href="#cb301-14" aria-hidden="true" tabindex="-1"></a>              <span class="co">//указателя</span></span>
<span id="cb301-15"><a href="#cb301-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb301-16"><a href="#cb301-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> р<span class="op">;</span></span>
<span id="cb301-17"><a href="#cb301-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="3" type="1">
<li><div class="sourceCode" id="cb302"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span><span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span><span class="dt">size_t</span> n<span class="op">,</span> <span class="at">const</span> notrow t<span class="op">&amp;);</span> <span class="co">//если памяти не</span></span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">//хватает, возвращается нулевой указатель, а исключение не </span></span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//вырабатывается</span></span></code></pre></div></li>
<li><div class="sourceCode" id="cb303"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span><span class="dt">notrow_t</span><span class="op">&amp;,</span> <span class="dt">void</span><span class="op">*);</span> <span class="co">//соответствующий delete</span></span></code></pre></div></li>
</ol>
<p>3 и 4 продолжают существовать для совместимости с предыдущими версиями для одиночного объекта и для массива — возвращает нулевой указатель</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> p <span class="op">=</span> <span class="kw">new</span><span class="op">(</span>nothrow<span class="op">)</span> A<span class="op">[</span><span class="dv">2</span><span class="op">];</span><span class="co">//nothrow — это глобальный объект типа </span></span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//nothrow_t</span></span>
<span id="cb304-4"><a href="#cb304-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>p <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">...</span></span>
<span id="cb304-5"><a href="#cb304-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span><span class="op">(</span>nothrow<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb304-6"><a href="#cb304-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="исключения-в-конструкторах-и-деструкторах">Исключения в конструкторах и деструкторах</h2>
<p>Объект не считается созданным, пока не завершится выполнение его конструктора ⇒ для «недоделанных» объектов деструкторы не вызываются!!!</p>
<p>Проблема: другими способами ситуацию разрешить сложно, так как конструкторам и деструкторам в C++ не позволено возвращать значений ⇒ если ошибка все-таки возникает именно в конструкторе, то (чтобы не пользоваться «недоделанным» объектом) нужно как-то об этом сообщить:</p>
<ul>
<li><p>посредством глобальных переменных</p></li>
<li><p>с помощью механизма исключений (основное преимущество — будут вызваны деструкторы для всех объектов, созданных в конструкторе на момент выработки исключения, например, если создавался массив объектов, то будут вызваны деструкторы только для тех элементов массива, которые уже удалось создать)</p></li>
</ul>
<ol type="1">
<li><p>встроенные объекты (все корректно, так как для всех промежуточных стековых объектов будут вызваны деструкторы)</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A</span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb305-5"><a href="#cb305-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> a<span class="op">;</span> <span class="op">}</span></span>
<span id="cb305-6"><a href="#cb305-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;~A&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb305-7"><a href="#cb305-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb305-8"><a href="#cb305-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B</span>
<span id="cb305-9"><a href="#cb305-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb305-10"><a href="#cb305-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb305-11"><a href="#cb305-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb305-12"><a href="#cb305-12" aria-hidden="true" tabindex="-1"></a>    B<span class="op">(</span><span class="dt">int</span> b <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="va">m_b</span> <span class="op">=</span> b<span class="op">;</span> <span class="cf">throw</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb305-13"><a href="#cb305-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>B<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;~B &quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb305-14"><a href="#cb305-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb305-15"><a href="#cb305-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb305-16"><a href="#cb305-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb305-17"><a href="#cb305-17" aria-hidden="true" tabindex="-1"></a>    A <span class="va">m_A</span><span class="op">;</span></span>
<span id="cb305-18"><a href="#cb305-18" aria-hidden="true" tabindex="-1"></a>    B <span class="va">m_B</span><span class="op">;</span></span>
<span id="cb305-19"><a href="#cb305-19" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb305-20"><a href="#cb305-20" aria-hidden="true" tabindex="-1"></a>    C<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">:</span><span class="va">m_A</span><span class="op">(</span>a<span class="op">),</span> <span class="va">m_B</span><span class="op">(</span>b<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb305-21"><a href="#cb305-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>C<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;~C &quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb305-22"><a href="#cb305-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb305-23"><a href="#cb305-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb305-24"><a href="#cb305-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb305-25"><a href="#cb305-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb305-26"><a href="#cb305-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb305-27"><a href="#cb305-27" aria-hidden="true" tabindex="-1"></a>        C c<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb305-28"><a href="#cb305-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb305-29"><a href="#cb305-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb305-30"><a href="#cb305-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">//на момент вызова обработчика гарантировано будут вызваны </span></span>
<span id="cb305-31"><a href="#cb305-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">//деструкторы для всех сконструированных на момент </span></span>
<span id="cb305-32"><a href="#cb305-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">//возникновения исключения стековых объектов. В нашем случае </span></span>
<span id="cb305-33"><a href="#cb305-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">//— только ~A</span></span>
<span id="cb305-34"><a href="#cb305-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb305-35"><a href="#cb305-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb305-36"><a href="#cb305-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Модифицируем предыдущий пример: «голые» указатели (утечка памяти!!!)</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> <span class="va">m_pA</span><span class="op">;</span></span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> <span class="va">m_pB</span><span class="op">;</span></span>
<span id="cb306-5"><a href="#cb306-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb306-6"><a href="#cb306-6" aria-hidden="true" tabindex="-1"></a>    C<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">:</span> <span class="va">m_pA</span><span class="op">(</span><span class="kw">new</span> A<span class="op">(</span>a<span class="op">)),</span> <span class="va">m_pB</span><span class="op">(</span><span class="kw">new</span> B<span class="op">(</span>b<span class="op">))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb306-7"><a href="#cb306-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>C<span class="op">()</span></span>
<span id="cb306-8"><a href="#cb306-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb306-9"><a href="#cb306-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_pA</span><span class="op">;</span></span>
<span id="cb306-10"><a href="#cb306-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_pB</span><span class="op">;</span></span>
<span id="cb306-11"><a href="#cb306-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;~C &quot;</span><span class="op">;</span></span>
<span id="cb306-12"><a href="#cb306-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb306-13"><a href="#cb306-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb306-14"><a href="#cb306-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb306-15"><a href="#cb306-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb306-16"><a href="#cb306-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb306-17"><a href="#cb306-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb306-18"><a href="#cb306-18" aria-hidden="true" tabindex="-1"></a>        C c<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb306-19"><a href="#cb306-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb306-20"><a href="#cb306-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb306-21"><a href="#cb306-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">//на момент вызова обработчика гарантировано будут</span></span>
<span id="cb306-22"><a href="#cb306-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">//вызваны деструкторы для всех сконструированных на</span></span>
<span id="cb306-23"><a href="#cb306-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">//момент возникновения исключения стековых объектов.</span></span>
<span id="cb306-24"><a href="#cb306-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">//Деструктор для C вызван не будет ⇒ память потекла!!!</span></span>
<span id="cb306-25"><a href="#cb306-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb306-26"><a href="#cb306-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Решение проблемы — все опасное заворачивать в объекты!!!</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> WrapA</span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> <span class="va">m_pA</span><span class="op">;</span></span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true" tabindex="-1"></a>    WrapA<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> <span class="va">m_pA</span> <span class="op">=</span> <span class="kw">new</span> A<span class="op">[</span>n<span class="op">];</span> <span class="op">}</span></span>
<span id="cb307-6"><a href="#cb307-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>WrapA<span class="op">()</span> <span class="op">{</span> <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_pA</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb307-7"><a href="#cb307-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb307-8"><a href="#cb307-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb307-9"><a href="#cb307-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb307-10"><a href="#cb307-10" aria-hidden="true" tabindex="-1"></a>    WrapA wa<span class="op">;</span><span class="co">//вместо A* m_pA;</span></span>
<span id="cb307-11"><a href="#cb307-11" aria-hidden="true" tabindex="-1"></a>    B<span class="op">*</span> <span class="va">m_pB</span><span class="op">;</span></span>
<span id="cb307-12"><a href="#cb307-12" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb307-13"><a href="#cb307-13" aria-hidden="true" tabindex="-1"></a>    C<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">:</span>wa<span class="op">(</span>a<span class="op">),</span> <span class="va">m_pB</span><span class="op">(</span><span class="kw">new</span> B<span class="op">(</span>b<span class="op">))</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb307-14"><a href="#cb307-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>C<span class="op">()</span> <span class="op">{</span> <span class="kw">delete</span> <span class="va">m_pB</span><span class="op">;</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;~C &quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb307-15"><a href="#cb307-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb307-16"><a href="#cb307-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb307-17"><a href="#cb307-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb307-18"><a href="#cb307-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb307-19"><a href="#cb307-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb307-20"><a href="#cb307-20" aria-hidden="true" tabindex="-1"></a>        C c<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb307-21"><a href="#cb307-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb307-22"><a href="#cb307-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb307-23"><a href="#cb307-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">//на момент вызова обработчика гарантировано будут </span></span>
<span id="cb307-24"><a href="#cb307-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">//вызваны деструкторы для всех сконструированных на </span></span>
<span id="cb307-25"><a href="#cb307-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">//момент возникновения исключения стековых объектов. В </span></span>
<span id="cb307-26"><a href="#cb307-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">//нашем случае — только для WrapA ⇒ все динамически </span></span>
<span id="cb307-27"><a href="#cb307-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">//созданные А будут уничтожены!</span></span>
<span id="cb307-28"><a href="#cb307-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb307-29"><a href="#cb307-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<blockquote>
<p>Рекомендация — не стоит возбуждать исключения в деструкторе, разве что тут же их и обработать.</p>
</blockquote>
<h2 id="исключения-и-наследование">Исключения и наследование</h2>
<div class="sourceCode" id="cb308"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span> <span class="op">...</span> <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A <span class="op">{</span> <span class="op">...</span><span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-4"><a href="#cb308-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">()</span></span>
<span id="cb308-5"><a href="#cb308-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb308-6"><a href="#cb308-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> B<span class="op">();</span><span class="co">//производного типа!!!</span></span>
<span id="cb308-7"><a href="#cb308-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb308-8"><a href="#cb308-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb308-9"><a href="#cb308-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb308-10"><a href="#cb308-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Тип исключения и наследование</span></span>
<span id="cb308-11"><a href="#cb308-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb308-12"><a href="#cb308-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb308-13"><a href="#cb308-13" aria-hidden="true" tabindex="-1"></a>        f<span class="op">();</span></span>
<span id="cb308-14"><a href="#cb308-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>A<span class="op">&amp;</span> a<span class="op">)</span><span class="co">//Выработано исключение производного типа B, а </span></span>
<span id="cb308-15"><a href="#cb308-15" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//принимается базового типа А, а управление все </span></span>
<span id="cb308-16"><a href="#cb308-16" aria-hidden="true" tabindex="-1"></a>                  <span class="co">//рано будет передано сюда</span></span>
<span id="cb308-17"><a href="#cb308-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb308-18"><a href="#cb308-18" aria-hidden="true" tabindex="-1"></a>        a<span class="op">.</span>f<span class="op">();</span><span class="co">//посредством ссылки на базовый класс вызывается </span></span>
<span id="cb308-19"><a href="#cb308-19" aria-hidden="true" tabindex="-1"></a>              <span class="co">//виртуальный метод целевого класса</span></span>
<span id="cb308-20"><a href="#cb308-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb308-21"><a href="#cb308-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Замечание 1: существенно в случае наследования принимать ссылку, так как по значению Вы получите только копию базовой части объекта ⇒ <code>a.f();</code> — вызов виртуальной функции базового класса.</p>
<p>Замечание 2: обработчики исключений просматриваются в том порядке, в котором их указал программист ⇒ обработчики производного типа должны предшествовать обработчикам базового типа, иначе последние никогда не будут выполняться!</p>
<p>Замечание 3: Это справедливо и для указателей!</p>
<h2 id="стандартные-исключения">Стандартные исключения</h2>
<p>На самом деле для того, чтобы придать типам исключений некоторую структурность, в стандартной библиотеке определена иерархия классов с базовым классом <code>exception</code>, (все в пространстве имен <code>std</code>). В стандартной библиотеке определены три группы исключений:</p>
<p><img src="media/image58.svg" /></p>
<div class="sourceCode" id="cb309"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> F<span class="op">()</span></span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> exception<span class="op">();</span><span class="co">//будет выведено Unknown exception</span></span>
<span id="cb309-6"><a href="#cb309-6" aria-hidden="true" tabindex="-1"></a><span class="co">//      throw exception(&quot;MyException&quot;);//будет выведено MyException</span></span>
<span id="cb309-7"><a href="#cb309-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>exception<span class="op">&amp;</span> e<span class="op">)</span><span class="co">//сюда будет передано управление при </span></span>
<span id="cb309-8"><a href="#cb309-8" aria-hidden="true" tabindex="-1"></a>                          <span class="co">//возникновении любого исключения, </span></span>
<span id="cb309-9"><a href="#cb309-9" aria-hidden="true" tabindex="-1"></a>                          <span class="co">//производного от except</span></span>
<span id="cb309-10"><a href="#cb309-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb309-11"><a href="#cb309-11" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb309-12"><a href="#cb309-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(...)</span><span class="co">//сюда все остальные — пользовательского типа, не </span></span>
<span id="cb309-13"><a href="#cb309-13" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//производные</span></span>
<span id="cb309-14"><a href="#cb309-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb309-15"><a href="#cb309-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb309-16"><a href="#cb309-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb309-17"><a href="#cb309-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Вы можете:</p>
<ul>
<li><p>использовать непосредственно эти классы исключений стандартной библиотеки</p></li>
<li><p>наследовать от них свои классы</p></li>
<li><p>игнорировать классы стандартной библиотеки и создавать свои</p></li>
</ul>
<table style="width:81%;">
<colgroup>
<col style="width: 30%" />
<col style="width: 27%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>Имя</th>
<th>Чем генерируется</th>
<th><code>.h</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bad_alloc</code></td>
<td><code>new</code></td>
<td><code>&lt;new&gt;</code></td>
</tr>
<tr class="even">
<td>bad_cast</td>
<td><code>dynamic_cast</code></td>
<td><code>&lt;type_info&gt;</code></td>
</tr>
<tr class="odd">
<td><code>bad_typeid</code></td>
<td><code>typeid</code></td>
<td><code>&lt;type_info&gt;</code></td>
</tr>
<tr class="even">
<td><code>ios_base::failure</code></td>
<td>функциями потоков ввода/вывода</td>
<td><code>&lt;ios&gt;</code></td>
</tr>
<tr class="odd">
<td><code>out_of_range</code></td>
<td><code>at()</code></td>
<td><code>&lt;stdexcept&gt;</code></td>
</tr>
<tr class="even">
<td>все остальные</td>
<td></td>
<td><code>&lt;stdexcept&gt;</code></td>
</tr>
</tbody>
</table>
<p>оператор <code>new</code></p>
<div class="sourceCode" id="cb310"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">()</span></span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N <span class="op">=</span> <span class="bn">0x7fffffff</span><span class="op">;</span> <span class="co">//Пробуем исчерпать память</span></span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">**</span> p <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">*</span> <span class="op">[</span>N<span class="op">];</span></span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a>            p<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">[</span>N<span class="op">];</span></span>
<span id="cb310-11"><a href="#cb310-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb310-12"><a href="#cb310-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>bad_alloc<span class="op">&amp;)</span></span>
<span id="cb310-13"><a href="#cb310-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb310-14"><a href="#cb310-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//i — итерация цикла, на которой память закончилась</span></span>
<span id="cb310-15"><a href="#cb310-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">//освобождаем</span></span>
<span id="cb310-16"><a href="#cb310-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb310-17"><a href="#cb310-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>bad_cast</code></p>
<div class="sourceCode" id="cb311"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> Shape<span class="op">&amp;</span> s<span class="op">)</span><span class="co">//нужно проверить — на какой действительно </span></span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a>                      <span class="co">//объект ссылается s</span></span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb311-4"><a href="#cb311-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb311-5"><a href="#cb311-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb311-6"><a href="#cb311-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> Rect<span class="op">&amp;</span> r <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span><span class="at">const</span> Rect<span class="op">&amp;&gt;(</span>s<span class="op">);</span></span>
<span id="cb311-7"><a href="#cb311-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>bad_cast<span class="op"> </span>b<span class="op">)</span></span>
<span id="cb311-8"><a href="#cb311-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb311-9"><a href="#cb311-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//не Rect</span></span>
<span id="cb311-10"><a href="#cb311-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb311-11"><a href="#cb311-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb311-12"><a href="#cb311-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Rect:</span></span>
<span id="cb311-13"><a href="#cb311-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Rect<span class="op">&amp;</span> rRect <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> Rect<span class="op">&amp;&gt;(</span>s<span class="op">);</span></span>
<span id="cb311-14"><a href="#cb311-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="тема-xiii.-обобщенное-программирование">Тема XIII. Обобщенное программирование</h1>
<h2 id="идеи-обобщенного-программирования.-зачем-нужны-шаблоны.-понятия-связанные-с-шаблонами">Идеи обобщенного программирования. Зачем нужны шаблоны. Понятия, связанные с шаблонами</h2>
<p>При создании программ довольно часто приходится писать множество одинаковых фрагментов для обработки разных типов данных. Например:</p>
<p>Функция выполняет одни и те же действия, текст на языке высокого уровня будет одинаковым, но низкоуровневый код будет зависеть от типов параметров.</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a>Т min<span class="op">(</span>T х<span class="op">,</span> Т у<span class="op">);</span> <span class="co">//под Т можно подразумевать int, double, Point... -</span></span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//в зависимости от типа параметров компилятор </span></span>
<span id="cb312-3"><a href="#cb312-3" aria-hidden="true" tabindex="-1"></a>                 <span class="co">//сгенерирует разные низкоуровневые команды!!!</span></span></code></pre></div>
<p>Данные класса отличаются только типом, а реализация методов на языке высоко уровня выглядит одинаково:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point</span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a>    T х<span class="op">,</span> у<span class="op">;</span> <span class="co">//int, double, MyComplex... в зависимости от типа </span></span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">//параметров компилятор будет резервировать разное </span></span>
<span id="cb313-5"><a href="#cb313-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">//количество памяти при создании объекта типа Point и </span></span>
<span id="cb313-6"><a href="#cb313-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">//генерировать разные тела методов класса</span></span>
<span id="cb313-7"><a href="#cb313-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>С помощью ключевого слова <code>template</code> на C++ можно задать компилятору образец кода для некоторого обобщенного типа данных — шаблон. Используя «скелет» кода, компилятор сам сгенерирует конечный код для конкретного типа данных.</p>
<p><img src="media/image59.svg" /></p>
<h3 id="объявление-шаблона-общее">Объявление шаблона (общее)</h3>
<blockquote>
<div class="sourceCode" id="cb314"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>список_параметров_шаблона<span class="op">&gt;</span></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a>    объявление_функции_или_класса<span class="op">,</span></span></code></pre></div>
</blockquote>
<p>где <code>список_параметров_шаблона</code> — это разделенные запятой параметры шаблона (где фигурирует один или несколько параметров обобщенного типа). Параметры шаблона обозначают в общем случае <strong>«отличающиеся»</strong> части того кода, который будет сгенерирован компилятором по данному шаблону (это могут быть обобщенные типы данных, константы, а также «вложенные» шаблоны). <strong>Могут иметь значения по умолчанию!</strong></p>
<p><img src="media/image60.svg" /></p>
<p>Замечания:</p>
<ol type="1">
<li><p>без явного (<code>explicit</code>) указания при объявлении шаблона компилятор не создает никакого кода, шаблон является просто заготовкой для компилятора. Только встретив обращение к данному шаблону (вызов функции или создание экземпляра класса и вызов его методов) в тексте программы, компилятор сгенерирует соответствующий код.</p></li>
<li><p>ключевого слово typename рекомендуется использовать вместо старого <code>class</code> (в ранних версиях ключевого слова typename просто не было). Пока нет причин, почему бы следовало использовать <code>typename</code>, но оно выглядит понятнее (не ассоциируются только с понятием <code>class</code>).</p></li>
<li><p>в качестве обобщенного типа можно задать как имя сложного пользовательского типа данных (класс), так и простой (базовый) тип</p></li>
<li><p>можно задать параметры шаблона по умолчанию. Например:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> В <span class="op">=</span> А<span class="op">&gt;</span> <span class="op">...</span></span></code></pre></div></li>
</ol>
<h3 id="термины-связанные-с-шаблонами">Термины, связанные с шаблонами</h3>
<p>Процесс генерации компилятором как функции (тела), так и объявления класса по шаблону и списку параметров шаблона называется инстанцированием. Например, когда компилятор в первый раз встречает вызов функции-шаблона, он создает соответствующий код (именно для указанных в качестве параметров шаблона типов данных) — это неявное инстанцирование. Далее, если компилятор встречает вызов функции с теми же типами параметров, он просто генерирует вызов к уже созданному телу функции Более того, если даже такие вызовы находятся в разных единицах компиляции, только одна копия тела функции будет включена в исполняемый файл.</p>
<p>Версия шаблона для конкретного набора аргументов называется специализацией.</p>
<h2 id="шаблоны-функций">Шаблоны функций</h2>
<h3 id="способы-обобщения-функций-выполняющих-одинаковые-действия-но-оперирующих-данными-разных-типов">Способы обобщения функций, выполняющих одинаковые действия, но оперирующих данными разных типов</h3>
<p>Если функция, оперируя данными разного типа, выполняет одинаковые по смыслу действия, удобно и логично для такой функции иметь одно и то же имя. Такую возможность можно реализовать двумя способами (рассмотрим на примере функции, возвращающей минимальное из двух заданных значений):</p>
<ol type="1">
<li><p>с помощью «перегрузки» функций. При этом программист должен объявить и определить нужное количество функций с одним и тем же именем, которые в нашем примере отличаются только типом параметров:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a><span class="co">//min for ints</span></span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">)</span> <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true" tabindex="-1"></a><span class="co">//min for doubles</span></span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> min<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">)</span> <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true" tabindex="-1"></a><span class="co">//etc...</span></span></code></pre></div>
<p>При этом компилятор сгенерирует в точке вызова функции min() вызов одной из определенных функций в зависимости от типа параметров:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iX <span class="op">=</span> <span class="dv">1000</span><span class="op">,</span> iY <span class="op">=</span> <span class="dv">500</span><span class="op">;</span></span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iResult <span class="op">=</span> min<span class="op">(</span>iX<span class="op">,</span> iY<span class="op">);</span> <span class="co">//вызов min(int, int)</span></span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dX <span class="op">=</span> <span class="fl">1.0</span><span class="op">,</span> dY <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dResult <span class="op">=</span> min<span class="op">(</span>dX<span class="op">,</span> dY<span class="op">);</span> <span class="co">//вызов min (double, double)</span></span>
<span id="cb317-6"><a href="#cb317-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>с помощью макроподстановки</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define min</span><span class="op">(</span>a<span class="op">,</span>b<span class="op">)</span><span class="pp"> </span><span class="op">(</span>a<span class="pp"> </span><span class="op">&lt;</span><span class="pp"> </span>b<span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span>a<span class="pp"> </span><span class="op">:</span><span class="pp"> </span>b</span></code></pre></div>
<p>Что гораздо «опаснее», так как макроподстановка — это всего лишь подстановка текста препроцессором</p>
<ol type="a">
<li><p>типы параметров <code>a</code> и <code>b</code> макроса могут быть разными, ⇒ компилятор может неявно привести типы так, как посчитает нужным, или не сможет привести и выдаст ошибку, но покажет на ошибку в теле макроса (и разобраться в чем дело будет достаточно трудно)</p></li>
<li><p>некоторых «неожиданностей» при использовании макросов можно избежать с помощью скобок <code>(a) &lt; (Ь) ? (a) : (Ь)</code> — например: без скобок вызов макро <code>min(x &amp; y, z)</code> препроцессор превратит в <code>х &amp; (у &lt; b)</code>. а задумано было <code>(х &amp; у) &lt; Ь</code></p></li>
<li><p>некоторых побочных эффектов даже при использовании скобок избежать не удастся:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> r <span class="op">=</span> min<span class="op">(</span>a<span class="op">++,</span> b<span class="op">++);</span> <span class="co">//превратится в</span></span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a>                       <span class="co">//(a++) &lt; (Ь++) ? (a++) : (b++)</span></span></code></pre></div></li>
</ol></li>
<li><p>с помощью шаблона функции можно</p>
<ol type="a">
<li><p>уменьшить количество «дублируемого» кода, определив только один шаблон, оперирующий с некоторым обобщенным типом данных — <code>Т</code>,</p></li>
<li><p>шаблон лишен недостатков макроподстановок, так как тело функции по шаблону реализуется компилятором, который прекрасно знает семантику C++ (например, параметр шаблона гарантированно вычисляется только один раз).</p></li>
</ol></li>
</ol>
<h4 id="объявление-шаблона-функции">3.1. Объявление шаблона функции:</h4>
<p><img src="media/image61.svg" /></p>
<p>Замечания:</p>
<ol type="1">
<li><p>как и обычную функцию, шаблон такой короткой функции Вы можете объявить встраиваемым:</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> T min<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>a <span class="op">&lt;</span> Ь<span class="op">)</span> <span class="op">?</span> а <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span></code></pre></div></li>
<li><p>параметры шаблона (также как и параметры функции) могут иметь значения по умолчанию: <code class="sourceCode cpp">func<span class="op">(</span>T а <span class="op">=</span> Т<span class="op">())</span></code></p></li>
<li><p>так как тело шаблона — это только заготовка компилятору (шаблон), по которой он будет генерировать код для конкретной типа данных, всю заготовку целиком компилятор должен видеть в месте вызова функции ⇒ ее тело также должно быть в заголовочном файле. Обычно объявление совмещают с определением.</p></li>
<li><p>функция-шаблон в свою очередь может быть перегружена и в частности наряду с параметрами обобщенного типа может принимать параметры любого типа</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> Т<span class="op">&gt;</span> Т min<span class="op">(</span>Т<span class="op">*</span> р<span class="op">,</span> <span class="dt">int</span> num<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a><span class="co">// пример — поиск минимального элемента в массиве</span></span></code></pre></div></li>
</ol>
<h4 id="создание-и-вызов-функции-по-заданному-шаблону">3.2. Создание и вызов функции по заданному шаблону:</h4>
<p>Вызов функции-шаблона ничем не отличается от вызова обычной функции. Когда компилятор в тексте программы встретит вызов функции, он создаст конкретную реализацию функции (<strong>специализацию шаблона</strong>), исходя из заданного шаблона и конкретных типов параметров, использованных при вызове функции:</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iX <span class="op">=</span> <span class="dv">1000</span><span class="op">,</span> iY <span class="op">=</span> <span class="dv">500</span><span class="op">;</span></span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iResult <span class="op">=</span> min<span class="op">(</span>iX<span class="op">,</span> iY<span class="op">);</span> <span class="co">//компилятор создаст и вызовет</span></span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//min(int, int)</span></span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dX <span class="op">=</span> <span class="fl">1.0</span><span class="op">,</span> dY <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb322-6"><a href="#cb322-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dResult <span class="op">=</span> min<span class="op">(</span>dX<span class="op">,</span> dY<span class="op">);</span> <span class="co">//компилятор создаст и вызовет</span></span>
<span id="cb322-7"><a href="#cb322-7" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">//min(double, double)</span></span>
<span id="cb322-8"><a href="#cb322-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Ho!!!</span></span>
<span id="cb322-9"><a href="#cb322-9" aria-hidden="true" tabindex="-1"></a>    iResult <span class="op">=</span> min<span class="op">(</span>iX<span class="op">,</span> dX<span class="op">);</span> <span class="co">//ошибка компилятора! — параметры paзного</span></span>
<span id="cb322-10"><a href="#cb322-10" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//типа -&gt; нужно явно указать компилятору </span></span>
<span id="cb322-11"><a href="#cb322-11" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//какую специализацию нужно вызывать(или </span></span>
<span id="cb322-12"><a href="#cb322-12" aria-hidden="true" tabindex="-1"></a>                           <span class="co">//генерировать)</span></span>
<span id="cb322-13"><a href="#cb322-13" aria-hidden="true" tabindex="-1"></a>    iResult <span class="op">=</span> min<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>iX<span class="op">,</span> dX<span class="op">);</span><span class="co">//компилятор преобразует «double dX»</span></span>
<span id="cb322-14"><a href="#cb322-14" aria-hidden="true" tabindex="-1"></a>                               <span class="co">//в «int dX», и вызовет min(int, int)</span></span>
<span id="cb322-15"><a href="#cb322-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Таким образом, один раз определив в приведенном примере шаблон функции <code>min()</code>, можно вызывать ее для любых сколь угодно сложных типов данных (для которых определена операция сравнения — «<code>&lt;</code>» ). Это существенно снижает объем Вами написанного кода и в то же время повышает его «гибкость» без уменьшения надежности.</p>
<h3 id="шаблоны-функций-и-объекты-пользовательского-типа">Шаблоны функций и объекты пользовательского типа</h3>
<p>Рассмотрим шаблон функции <code>min()</code> и наш класс <code>Rect</code>:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="at">const</span> T<span class="op">&amp;</span> min<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">)</span> <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>Замечание:</p>
<ol type="1">
<li><p><strong>Модификация шаблона</strong>: так как мы распространили использование шаблона на пользовательские типы, эффективнее передавать <strong>ссылки</strong> в качестве параметров (<strong>+<code>const</code></strong> — необходимо, иначе этот шаблон не сможет работать с <code>min(1,5)</code> — а) запретить модифицировать параметры, б) возвращаемое значение — позволить использовать только справа от <code>=</code>)</p></li>
<li><p>Модификация пользовательского типа данных: в тепе функции присутствует оператор <code>&lt;</code>, который должен быть перегружен для пользовательского типа, если мы хотим использовать объекты <code>Rect</code> в качестве параметров. Так как мы будем вызывать эту функцию в константной функции и для константного параметра — она сама должна быть <code>const</code>.</p></li>
</ol>
<div class="sourceCode" id="cb324"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rect</span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_l</span><span class="op">,</span> <span class="va">m_t</span><span class="op">,</span> <span class="va">m_r</span><span class="op">,</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb324-4"><a href="#cb324-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb324-5"><a href="#cb324-5" aria-hidden="true" tabindex="-1"></a>    Rect<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb324-6"><a href="#cb324-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb324-7"><a href="#cb324-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_l</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="va">m_t</span> <span class="op">=</span> t<span class="op">;</span> <span class="va">m_r</span> <span class="op">=</span> r<span class="op">;</span> <span class="va">m_b</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb324-8"><a href="#cb324-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb324-9"><a href="#cb324-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="at">const</span> Rect<span class="op">&amp;</span> r<span class="op">)</span> <span class="at">const</span></span>
<span id="cb324-10"><a href="#cb324-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="cf">return</span> Square<span class="op">()</span> <span class="op">&lt;</span> r<span class="op">.</span>Square<span class="op">();</span> <span class="op">}</span></span>
<span id="cb324-11"><a href="#cb324-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> Square<span class="op">()</span> <span class="at">const</span></span>
<span id="cb324-12"><a href="#cb324-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span><span class="va">m_r</span> <span class="op">-</span> <span class="va">m_l</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="va">m_b</span> <span class="op">-</span> <span class="va">m_t</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb324-13"><a href="#cb324-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb324-14"><a href="#cb324-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb324-15"><a href="#cb324-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb324-16"><a href="#cb324-16" aria-hidden="true" tabindex="-1"></a>    Rect rl<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">3</span><span class="op">),</span> r2<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb324-17"><a href="#cb324-17" aria-hidden="true" tabindex="-1"></a>    Rect res <span class="op">=</span> min<span class="op">(</span>rl<span class="op">,</span> r2<span class="op">);</span></span>
<span id="cb324-18"><a href="#cb324-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="шаблоны-классов">Шаблоны классов</h3>
<p>Шаблоны классов называют также «обобщенными классами» (generic classes). Шаблон класса описывает, как компилятору сгенерировать класс (то есть <strong>выделить память под данные и сгенерировать код методов класса</strong>) по соответствующему набору аргументов шаблона и «скелету» класса. (Объявление шаблона является заготовкой класса, по которой компилятор создаст конкретные классы, основываясь на конкретных типах используемых данных).</p>
<p>Специфика:</p>
<ol type="1">
<li><p>шаблоны могут участвовать в наследовании</p></li>
<li><p>шаблоны методов могут быть виртуальными</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Т<span class="op">&gt;</span> <span class="kw">class</span> A</span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb325-3"><a href="#cb325-3" aria-hidden="true" tabindex="-1"></a>    Т m_а<span class="op">;</span></span>
<span id="cb325-4"><a href="#cb325-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb325-5"><a href="#cb325-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="at">const</span> Т<span class="op">&amp;</span> a<span class="op">)</span> <span class="op">{</span> <span class="va">m_a</span> <span class="op">=</span> а<span class="op">;</span> <span class="op">}</span></span>
<span id="cb325-6"><a href="#cb325-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span> <span class="va">m_a</span><span class="op">++;</span> <span class="op">}</span></span>
<span id="cb325-7"><a href="#cb325-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb325-8"><a href="#cb325-8" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A<span class="op">&lt;</span>T<span class="op">&gt;</span></span>
<span id="cb325-9"><a href="#cb325-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb325-10"><a href="#cb325-10" aria-hidden="true" tabindex="-1"></a>    T <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb325-11"><a href="#cb325-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb325-12"><a href="#cb325-12" aria-hidden="true" tabindex="-1"></a>    B<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">:</span>A<span class="op">&lt;</span>T<span class="op">&gt;(</span>а<span class="op">)</span> <span class="op">{</span> <span class="va">m_b</span> <span class="op">=</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb325-13"><a href="#cb325-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span> <span class="va">m_b</span><span class="op">++;</span> <span class="op">}</span></span>
<span id="cb325-14"><a href="#cb325-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb325-15"><a href="#cb325-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">()</span></span>
<span id="cb325-16"><a href="#cb325-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb325-17"><a href="#cb325-17" aria-hidden="true" tabindex="-1"></a>    B<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*</span> pB <span class="op">=</span> <span class="kw">new</span> B<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb325-18"><a href="#cb325-18" aria-hidden="true" tabindex="-1"></a>    A<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*</span> pA <span class="op">=</span> <span class="kw">new</span> B<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb325-19"><a href="#cb325-19" aria-hidden="true" tabindex="-1"></a>    pA<span class="op">-&gt;</span>f<span class="op">();</span></span>
<span id="cb325-20"><a href="#cb325-20" aria-hidden="true" tabindex="-1"></a>    pB<span class="op">-&gt;</span>f<span class="op">();</span></span>
<span id="cb325-21"><a href="#cb325-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>шаблоны классов могут содержать статические члены</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a><span class="co">//MyVector.h</span></span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">class</span> MyVector</span>
<span id="cb326-3"><a href="#cb326-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb326-4"><a href="#cb326-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb326-5"><a href="#cb326-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> <span class="va">m_count</span><span class="op">;</span></span>
<span id="cb326-6"><a href="#cb326-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb326-7"><a href="#cb326-7" aria-hidden="true" tabindex="-1"></a><span class="co">//main.cpp</span></span>
<span id="cb326-8"><a href="#cb326-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> MyVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span><span class="va">m_count</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb326-9"><a href="#cb326-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb326-10"><a href="#cb326-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb326-11"><a href="#cb326-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> MyVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span><span class="va">m_count</span><span class="op">;</span></span>
<span id="cb326-12"><a href="#cb326-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>у шаблонов могут быть <code>friend</code>-функции и классы</p></li>
<li><p>классы могут содержать встроенные шаблоны, при этом действуют некоторые ограничения, которые перечислим по мере использования</p></li>
</ol>
<p>Для примера рассмотрим шаблон класса, с помощью которого можно реализовать «массив» заданного размера (<code>size</code>) для элементов любого типа (обобщенный тип <code>T</code>):</p>
<p><img src="media/image62.svg" /></p>
<p>Методы шаблона класса вне объявления класса определяются следующим образом:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span> <span class="dt">int</span> size<span class="op">&gt;</span> T<span class="op">&amp;</span> MyArray<span class="op">&lt;</span>T<span class="op">,</span> size<span class="op">&gt;::</span><span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span></span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> size<span class="op">)</span> <span class="cf">return</span> <span class="va">m_ar</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb327-4"><a href="#cb327-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//исключение — out_of_range</span></span>
<span id="cb327-5"><a href="#cb327-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Создание объектов конкретного типа на базе шаблона:</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb328-3"><a href="#cb328-3" aria-hidden="true" tabindex="-1"></a>    MyArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">5</span><span class="op">&gt;</span> ar1<span class="op">;</span> <span class="co">//создает массив для 5 элементов int</span></span>
<span id="cb328-4"><a href="#cb328-4" aria-hidden="true" tabindex="-1"></a>    ar1<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb328-5"><a href="#cb328-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iTmp <span class="op">=</span> ar1<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb328-6"><a href="#cb328-6" aria-hidden="true" tabindex="-1"></a>    MyArray<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dv">6</span><span class="op">&gt;</span> ar2<span class="op">;</span> <span class="co">//создает массив для 6 элементов char</span></span>
<span id="cb328-7"><a href="#cb328-7" aria-hidden="true" tabindex="-1"></a>    MyArray<span class="op">&lt;</span>Rect<span class="op">,</span> <span class="dv">7</span><span class="op">&gt;</span> arЗ<span class="op">;</span> <span class="co">//создает массив для 7 элементов типа Rect</span></span>
<span id="cb328-8"><a href="#cb328-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb328-9"><a href="#cb328-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>Замечания:</em></p>
<ol type="1">
<li><p>так как шаблоны являются механизмом времени компиляции, все параметры списка параметров базовых типов шаблона (такие как <code>int i</code>) должны быть константами:</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> N <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a>MyArray<span class="op">&lt;</span>MyClass<span class="op">,</span> N<span class="op">&gt;</span> ar4<span class="op">;</span> <span class="co">//ошибка компилятора</span></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a>                         <span class="co">//(N не является константой!)</span></span></code></pre></div></li>
<li><p>методы класса являются шаблонами функций ⇒ должны быть реализованы тоже в заголовочном файле</p></li>
<li><p>параметры шаблона базового типа могут иметь значения по умолчанию:</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Т<span class="op">,</span> <span class="dt">int</span> size<span class="op">=</span><span class="dv">10</span><span class="op">&gt;</span> <span class="kw">class</span> MyArray <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a>MyArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ar5<span class="op">;</span><span class="co">//размер массива по умолчанию ==10</span></span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">=</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span> size<span class="op">=</span><span class="dv">10</span><span class="op">&gt;</span> <span class="kw">class</span> MyArray <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true" tabindex="-1"></a>MyArray<span class="op">&lt;&gt;</span> ar5<span class="op">;</span><span class="co">//тип элементов по умолчанию ==int, размер </span></span>
<span id="cb330-6"><a href="#cb330-6" aria-hidden="true" tabindex="-1"></a>              <span class="co">//массива по умолчанию ==10</span></span></code></pre></div></li>
<li><p>шаблон класса может содержать метод класса, который в свою очередь является шаблоном, базирующимся на другом типе. При этом такой метод-шаблон должен быть встроенным — то есть должен быть «определен» внутри класса:</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Т<span class="op">&gt;</span> <span class="kw">class</span> X</span>
<span id="cb331-2"><a href="#cb331-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb331-3"><a href="#cb331-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb331-4"><a href="#cb331-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span> <span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> U<span class="op">&amp;</span> u<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span> <span class="co">//OK</span></span>
<span id="cb331-5"><a href="#cb331-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Некорректно:</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Т<span class="op">&gt;</span> <span class="kw">class</span> X</span>
<span id="cb332-2"><a href="#cb332-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb332-3"><a href="#cb332-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb332-4"><a href="#cb332-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span> <span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> U<span class="op">&amp;</span> u<span class="op">);</span></span>
<span id="cb332-5"><a href="#cb332-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb332-6"><a href="#cb332-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb332-7"><a href="#cb332-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> X<span class="op">&lt;</span>T<span class="op">&gt;::</span>f<span class="op">(</span><span class="at">const</span> U<span class="op">&amp;</span> u<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div></li>
</ol>
</body>
</html>
