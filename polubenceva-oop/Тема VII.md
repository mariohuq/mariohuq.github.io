# Тема VII. Статические члены класса

## Статические данные

Часто возникает следующая ситуация: все объекты класса оперируют с
одним и тем же, единственным для всех экземпляров, глобальным данным
(__данные, которые характеризуют количество или взаимосвязь всех существующих на данный момент объектов данного типа__). То есть
появляются переменные, которые имеют отношение к классу в целом, но не
входят (не являются частью) в каждый объект данного класса. Для таких
данных вводится понятие и ключевое слово `static`.

Специфика:

-   статические переменные класса

    a)  __размещаются в статической области памяти__ на стадии
        компоновки
        (когда еще не создано ни одного экземпляра класса!) независимо от
        того, где создается сам объект.
    b)  __существуют в единственном экземпляре__ (то есть компоновщик
        выделяет под нее память только один
        раз!) независимо от того, сколько создано экземпляров данного класса.
        Это означает, что для переменных класса с ключевым словом static при
        создании экземпляра класса компилятор место не резервирует!

    ```cpp
    class Х
    {
        int m_х; //обычная переменная класса (в каждом объекте
                 //типа X компилятор отводит под такую переменную 
                 //память в объекте)
        static size_t count; //статическая переменная (в объекте
                             //память под такую переменную не 
                             //резервируется!)
    public:
        ...
    };
    ```

-   Статическую переменную класса необходимо определить следующим
    образом (вне функций и тем более вне объявления класса — как
    глобальные переменные) для того, чтобы компилятор отвел под эту
    переменную место в статической памяти:

    ```cpp
    //Х.срр
    size_t X::nCount; //объявление и инициализация статической
                      //переменной nCount класса X нулем по 
                      //умолчанию.
    ```

-   Определяется и инициализируется статическая переменная одинаково
    — независимо от спецификатора доступа:

    ```cpp
    size_t X::nCount = 1;
    ```

-   Обращение «извне». Статическая переменная класса по сути является
    глобальной, заключенной в пространство имен (имя класса), поэтому к public статической переменной можно обращаться посредством `cout << X::nCount`.

    С другой стороны, формально статическая переменная является членом
    класса поэтому ничто не мешает обращаться к ней посредством объекта: `cout << x.nCount << pX->nCount;`.

-   Обращение к статической переменной внутри методов класса для
    программиста — ничем не отличается от обращения к обычной
    переменной класса, для компилятора — подставляет адрес статической
    переменной, а не вычисляет база + смещение

-   Следствие: статические члены класса никогда не должны
    инициализироваться в конструкторе!

Для примера рассмотрим класс, который автоматически «контролирует»
количество объектов данного типа, существующих на данный момент
выполнения программы. Для решения этой задачи заведем статическую
переменную-счетчик и предусмотрим модификацию этой переменной при
создании нового объекта и при удалении существующего:

```cpp
class X
{
    int m_х;
public:
    static int nCount; //счетчик объектов типа X.
    X() { m_х = 0; nCount++; }
    ... //подумайте: какие еще методы требуется реализовать?
    ~X() { nCount--; }
};
int main()
{
    cout << X::nCount; //???
    X x1;
    size_t n = sizeof(x1); //???
    cout << x1.nCount; //???
    {
        X x2 = x1;
        cout << x2.nCount; //???
    }
    cout << X::nCount; //???
}
```

Замечание 1: в отличие от нестатических переменных:

```cpp
class A
{
    A a; //ошибка — использование неопределенного класса A
};
```

В объявлении класса можно использовать встроенные статические данные
того же типа. Например, таким образом можно задать `default` значение
(одинаковое для всех экземпляров класса):

```cpp
class A
{
    static A default; //ОК
};
```

`.срр`:

```cpp
A A::default(1);
```

Такое `default` значение можно изменить в процессе выполнения, а
значения параметров по умолчанию — нет!

Замечание 2: статические константы целого типа можно
проинициализировать непосредственно в объявлении класса: 

```cpp
class A
{
public:
    const static int n = 1; //это простая константа, вместо которой 
                            //компилятор будет просто подставлять 
                            //значение. Область видимости такой 
                            //константы ограничена классом
    static int count;//=1; — ошибка
};
int A::count; //обязательно!
//const int A::n; //необязательно — если хотим зарезервировать память
int main()
{
    int tmp = A::n;//компилятор подставит 1
}
```

### Пример использования статических переменных. Определение имени класса объекта во время выполнения

Замечание: приведенный ниже механизм определения класса объекта в
период выполнения применяется в библиотеке MFC и появился задолго до
того, как определение типа в период выполнения (runtime type
information — RTTI) ввели в спецификацию языка C++. И хотя компилятор
Visual C++, начиная с версии 4.0 поддерживает синтаксис RTTI, в
библиотеке используется прежний механизм. Пример является упрощением.

Все классы MFC (кроме вспомогательных) наследуются от `CObject`. Если бы
мы только хотели узнать имя класса объекта, достаточно было бы
определить в классе `CObject` виртуальную функцию:

```cpp
class CObject
{
public:
    virtual const char* GetClassName() const = 0;
};
class MyObject : public CObject
{
    static char m_name[]; //это только Объявление, поэтому могу
                          //размер не указывать (эквивалентно 
                          //объявлению extern сhar m_name[];)
public:
    virtual const char* GetClassName() const
    {
        return m_name;
    }
};
```

`.cpp`:

```cpp
    char MyObject::m_name[] = "MyObject";
        //а это определение, совмещенное с инициализацией 
        //(компилятор резервирует память)
```

То есть смысл в том, что каждый производный класс хранит в статической
переменной m_name имя своего класса и переопределяет виртуальную
функцию `GetClassName()`, которая возвращает это имя, тогда

```cpp
void F(CObject* p)
{
    std::cout << p->GetClassName() << std::endl;
        //посредством таблиц виртуальных функций выводит имя класса 
        //«целевого» объекта
}
```

## Статические методы

Статический метод — это по сути глобальная функция, область видимости
которой ограничена именем класса, поэтому (если она `public`) фактически
вызывать ее можно, указывая имя класса и спецификатор разрешения
области видимости, но формально она является членом класса, поэтому
вызывать ее можно также посредством объекта или указателя на объект.

Самое главное отличие статического метода класса от обычного
заключается в том, что компилятор при вызове статической функции не
формирует «невидимый» параметр, содержащий адрес объекта, поэтому:

-   следствие 1 — в таких функциях указатель `this` не существует!!!

-   следствие 2 — обратиться к нестатическим данным класса в такой
    функции не возможно

-   следствие 3 — статическая функция не может быть `virtual`

### Использование статических методов для доступа извне к `private` или `protected` `static`-данным класса

Если бы статическая переменная `nCount` класса `X` была защищенной, для
доступа к ней извне класса потребовался бы `public` статический метод
класса. Например:

```cpp
class X
{
protected:
    static int nCount;
public:
    X() { nCount++; }
    ~X() { nCount--; }
    ...
    static int GetCount() { return nCount; }
};
```

Объявляется и инициализируется статическая переменная одинаково — 
независимо от спецификатора доступа:

```cpp
int X::nCount = 0;
```

Использование статических методов:

```cpp
int main()
{
    cout << X::GetCount(); //???
    X x1(10);
    cout << x1::GetCount();//???
}
```

### Производящие функции классов («виртуальный конструктор»)

Производящей функцией называется функция, которая инкапсулирует вызов
оператора `new` для динамического создания экземпляра класса.

Если конструктор класса защищен, то компилятор «не позволит» создать
объект такого класса традиционным способом:

```cpp
class A
{
    int m_a;
    A(int a) { m_a = а; } //private конструктор
};
int main()
{
    //A a (1);//ошибка доступа (для того, чтобы компилятор имел
              //право вызвать конструктор, он должен быть public)
}
```

Закрытые конструкторы (объявленные со спецификатором `private` или
`protected`) не допускают создания объектов класса обычными
пользователями, поэтому для создания объекта требуется выполнение
одного из следующих условий:

-   конструктор вызывается `public` статическим методом класса;

-   конструктор вызывается методом `friend`-класса.

Когда это нужно? — если разработчик класса делает конструктор
защищенным, он тем самым заставляет пользователя класса создавать
объекты только предусмотренным разработчиком способом. Например:

```cpp
const int MAX = 100; //максимально возможное количество объектов в
                     //системе
class A //базовый класс, который будет контролировать в программе 
        //как все объекты класса А, так и все объекты производных 
        //классов посредством статического счетчика и статического 
{       //массива, в котором будут храниться указатели базового типа
    int m_a;
protected:
    A(int a = 0)
    {
        m_a = a;
        if (m_count < MAX)
            m_ar[m_count++] = this;
    }
    virtual ~A()
    {
        m_count--;
        //изъять указатель из массива!!
    }
    static unsigned int m_count; //счетчик объектов как типа А, так
                                 //и любого производного от А типа
    static A* m_ar[MAX]; //для упрощения считаем, что объектов не
                         //может быть больше МАХ
public:
    static A* Create(int a)
    {
        return new A(a);
    } //производящая функция
    void Destroy() { delete this; }
};
class B : public A
{
    int m_b;
protected:
    B(int a, int b) : A(a) { m_b = b; }
public:
    static A* Create(int a, int b) { return new B(a, b); }
        //статическая функция не может быть виртуальной, так как она 
        //не принимает в качестве «невидимого» параметра адрес 
        //объекта!!!
    unsigned int A::m_count;
    A* A::m_ar[MAX];
};
int main()
{
    //В b(1,2); //ошибка — конструктор защищен
    A* p = B::Create(1, 2); //объект будет создан только таким
                            //образом, как предусмотрел разработчик
    //... вызов посредством указателя на базовый класс виртуальных 
    //методов производного класса
    p->Destroy(); //вызывается метод базового класса. При выполнении 
                  //оператора delete сначала вызывается виртуальный 
                  //деструктор класса В, потом деструктор класса А, 
}                 //потом освобождается динамический блок памяти
```

