# Тема VIII. Структуры и объединения C++

В C++ структуры и объединения имеют существенные отличия от структур и объединений С.

## Структура C++

Структуры С могли содержать только данные. Они предоставляли
программисту удобную возможность укрупнения данных. Структура C++ -
это почти что полноценный класс. Это понятие остались в C++ для
совместимости с С.

У классов и структур C++ много общего:

-   в структурах C++ (в отличие от структур С) могут быть
    функции-члены,
-   в них можно объявлять секции `public`, `protected`, `private`,
-   структуры C++ могут иметь конструкторы, деструкторы,
-   участвовать в наследовании,
-   иметь виртуальные функции
-   ...

Отличие структур C++ от классов формально одно-единственное:
спецификатор доступа по умолчанию - `public` (для совместимости со
структурами С).

На практике (по договоренности между программистами) структуры
используются вместо классов лишь при соблюдении следующих условий:

-   структура не содержит виртуальных функций
-   если участвует в наследовании, то не является производной
    от чего-либо, кроме разве что другой структуры, и не является базой для
    чего-либо, кроме разве что другой структуры (то есть не стоит
    наследовать структуру от класса...)
-   нормальные программисты C++ используют обычно структуры для
    маленьких удобных наборов данных с тривиальными функциями.

```cpp
struct Rect
{
    int left, top, right, bottom; //по умолчанию public
};
```

## Объединения C++

Объединения C++, кроме того что позволяют интерпретировать одну и ту
же область памяти (то есть ее содержимое) по-разному, могут содержать
также методы (в отличие от объединений С). По умолчанию - спецификатор
доступа `public`.

```cpp
union U
{
    int m_i;
    char m_ch[4];
    U(int n) { m_i = n; }
};
int main()
{
    U ob(0x11223344);
    char ch = ob.m_ch[0];
    int n = ob.m_i;
}
```

Специфика:

-   само объединение может иметь конструктор и деструктор, а его
    встроенные члены не могут.
-   объединение не может быть производным от чего-либо
-   не участвует в наследовании ⇒ в объединениях не используется
    спецификатор `protected`
-   не может иметь статических членов
-   размер `union` определяется его наибольшим данным:

```cpp
union U
{
private:
    int m_i;
    char m_ch[4];
    double m_d;
public:
    U(int х) { m_i = х; }
    int GetInt() { return m_i; }
    int GetChar(int i) { if (...) return m_ch[i]; }
    ...
};
int main()
{
    U ob(0x11223344);
    //ob.m_i = 5; //ошибка
    int tmp = ob.GetChar(1);
    size_t n = sizeof(ob); //8
}
```

### Анонимные объединения (классы, структуры)

Иногда просто требуется сообщить компилятору, что требуется разместить
несколько переменных по одному и тому же адресу ⇒ нельзя создать
экземпляр анонимного объединения ⇒ обращение к членам объединения не
посредством объекта, а просто по имени переменной. Для локального
использования.

```cpp
int main()
{
    {
        union
        {
            int i;
            char ch[4];
        };
        i = 10;
        ch[3] = 0xff;
    } //до конца блока можно пользоваться
}
```

