# Тема V. Сложные указатели. Указатели на члены класса

В некоторых случаях нужно уметь объявлять и использовать указатели на
члены класса (реже на переменные, чаще на методы).

Для демонстрации создадим простенькую иерархию классов:

```cpp
class A
{
    int m_Private_a;
public:
    int m_Public_a; //для примера в нарушение правил ООП
                    //объявим общедоступную переменную
    A(int a1 = 0, int a2 = 0) { m_Private_a = a1; m_Public_a = a2; }
    void f();
    virtual void vf();
};
class B : public A
{
    ...
public:
    virtual void vf();
};
int main()
{
    //указатели на переменные класса
    A a(1, 2);

    //а)
    //int* р = &А::m_Private_a;//ошибка доступа — cannot access
                               //private member
    int* р = &a.m_Public_a;//р - обычный указатель, содержит адрес 
                           //переменной m_Public_a объекта а

    //использование такого указателя ничем не отличается от 
    //использования указателя на обычную переменную
    int t = *р;

    //б)
    //int А::*рА1 = &A::m_Private_a;//cannot access private member
    int A::*pA = &A::m_Public_a;
        //a такая переменная pA содержит не адрес, а смещение 
        //переменной m_Public_a относительно начала объекта
    
    //использование такого «указателя» специфично
    int tmp = a.*pA;//а пользоваться этим смещением синтаксически
                    //можно как указателем (но только посредством 
                    //объекта или указателя на объект)

    //Указатели на невиртуальные и нестатические методы класса
    //void (*pf) () =А::f;//ошибка компилятора
    void (A::*pf)() = A::f;//такой указатель рf содержит просто 
                           //адрес функции, но при вызове такой 
                           //функции компилятор должен сформировать 
                           //дополнительный параметр - адрес того 
                           //объекта, для которого вызывается метод
                           //(this)
    (a.*pf)();//поэтому вызывать нужно посредством объекта или
              //указателя на объект

    //Указатели на виртуальные методы класса
    A* p1 = new A;
    void (A::*pvf1)() = &A::vf;
        //такой указатель содержит не адрес 
        //функции, а адрес «заглушки», в которой
        //а) по полученному адресу из объекта извлекается адрес
        //б) по индексу, составленному с vf, извлекается из vtab 
        //   адрес метода
        //в) косвенно вызывается метод
    p1->vf();
    (p1->*pvf1)();

    A* p2 = new B;
    void (B::*pvf2)() = B::vf;//то же самое значение, что и в pvf1
    p2->vf();
    (p2->*pvf1)();
}
```

Замечание: так как статический метод класса по сути является
глобальной функцией ([раздел «Статические методы класса»](#статические-методы)), указатель на
статический метод ничем не отличается от указателя на обычную
глобальную функцию.

Пример использования:

```cpp
class A
{
    int m_a;
public:
    //оба метода имеют одинаковый вид:
    void fl();
    void f2();
    ...
};
int main()
{
    A ar[] = { A(1), A(5), A(2), A(-1), ... };
    void (A::*pSample)() = 0; //указатель на метод класса А, который
                              //не принимает параметров и ничего не 
                              //возвращает
    //Какой из методов требуется вызвать для каждого элемента массива, 
    //определяю случайным образом во время выполнения:
    switch (rand() % 2)
    {
    case 0:
        pSample = A::f1;
        break;
    case 1:
        pSample = A::f2;
        break;
    }
    for (int i = 0; i < sizeof(ar) / sizeof(A); i++)
        (ar[i].*pSample)(); //вызов метода для каждого элемента
                            //массива посредством сформированного 
}                           //указателя
```

