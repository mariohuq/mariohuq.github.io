# Тема IX. Защищенное наследование. Отношение между классами — «подобен»

## Цель

Если спецификатор наследования производного класса `private` или
`protected`, `public` интерфейс базового класса извне (посредством объекта
или указателя на объект) становится недоступен:

```cpp
class A
{
public:
    void fA();
};
class B : private/*protected*/ A { };
int main()
{
    A a;
    a.fA(); //ОК
    B b;
    //b.fA(); //ошибка компилятора метод недоступен
    //А* рА = new В; //ошибка — преобразование существует, но 
                     //недоступно!
}
```

При защищенном наследовании доступ к `public` членам базового класса
возможен только из методов производного класса. Пользователи
производного класса не имеют доступа к базовой части, что позволяет
разработчику производного класса приспособить базовую часть для своих
целей, то есть:

-   использовать те методы базового класса, которые удобно
    использовать производному классу только определенным образом,

-   а те понятия базового класса, которые «не справедливы» для
    производного, запретить.

Например, таким образом можно построить иерархию классов:

```cpp
class Rect
{
protected:
    int l, r, t, b;
public:
    Rect(int x1, int y1, int x2, int y2)
    {
        l = x1; r = x2; t = y1; b = y2;
    }
    void Inflate(int dl, int dr, int dt, int db)
    {
        l -= dl; r += dr; t -= dt; b += db;
    }
};
class Square : protected Rect
{
public:
    void Inflate(int d)
    {
        Rect::Inflate(d, d, d, d);
    } //метод базового класса вызывается таким образом,
      //чтобы квадрат не превратился в прямоугольник
    Square(int x, int y, int d)
        : Rect(x, y, x + d, y + d) { }
};
int main()
{
    Square s(1, 1, 10);
    s.Inflate(2); //квадрат остался квадратом
    //s.Inflate(1, 2, 3, 4); //ошибка компилятора
    
    //Компилятор обмануть трудно:
    //s.Rect::Inflate(1, 2, 3, 4); //ошибка компилятора
    //Rect r = s; //ошибка компилятора
    //Rect* pr = new Square (10, 10, 100); //ошибка компилятора
}
```

Замечание: при защищенном наследовании внутренние взаимоотношения
между двумя классами не меняются, то есть в методах производного
класса доступны `protected` понятия базового класса.

## `friend`

Все друзья `Square` имеют также доступ к защищенным членам `Rect`,
наследники — нет

```cpp
class Rect
{
protected:
    int l, r, t, b;
public:
    Rect(int x1, int yl, int x2, int y2)
    {
        l = x1; r = x2; t = yl; b = y2;
    }
    void Inflate(int dl, int dr, int dt, int db)
    {
        l -= dl; r += dr; t -= dt; b += db;
    }
    void f() { }
};
class Square : protected Rect
{
public:
    void inflate(int d) { Rect::Inflate(d, d, d, d); };
    Square(int x, int y, int d) : Rect(x, y, x + d, y + d) { }
    friend void GF(Square& s);
};
void GF(Square& s)
{
    s.f(); //ОК
}
```

## Защищенное наследование при построении иерархий классов

В предыдущем примере взаимоотношения внутри классов сохранялись, но
если мы продолжим строить иерархию классов, то защищенная базовая
часть должна

Объектно-ориентированное программирование (C++) быть изолирована от
всех остальных не непосредственных наследников, поэтому для таких
наследников появляются дополнительные ограничения области видимости:

```cpp
class A
{
    int m_a;
protected:
    int m_a1;
    void fA1();
public:
    void fA2();
};
class B :private/*protected*/ A
{
    int m_b;
protected:
    int m_B1;
    void fB1()
    { //разрешено обращаться к public и protected членам A
        fA1();
        m_a1++;
        fA2();
    }
public:
    void fB2();
};
```

Разница в спецификаторах `private` и `protected` проявляется для
наследников класса B:

```cpp
class C :public B
{
public:
    void fC()
    {
        fB1();
        m_a1++;//protected — OK, private — inaccessible member
        fA1();//protected — OK, private — inaccessible member
        fA2();//protected — OK, private — not accessible because
              //'B' uses 'private' to inherit from 'A'
    }
};
int main()
{
    A a;
    C c;
    //c.fA2();//private — inaccessible member ,
              //protected — not accessible
    c.fB2();
    //A* pA = new С; //ошибка
    B* pA = new C; //OK
}
```

Изменение вида доступа к элементу базового класса из производного
класса в зависимости от спецификатора доступа, указываемого при
объявлении производного класса

+----------------+----------------+----------------+----------------+
| Спецификатор   | Изменение вида | ⇒              | ⇒             |
| доступа,       | доступа к      |                |                |
| указываемый    | элементу       |                |                |
| при объявлении | базового       |                |                |
| производного   | класса         |                |                |
| класса         | посредством    |                |                |
|                | производного   |                |                |
|                | класса         |                |                |
+----------------+----------------+----------------+----------------+
| ⇓              | в базовом      | в базовом      | в базовом      |
|                | public         | protected      | private        |
+----------------+----------------+----------------+----------------+
| class В :      | в производном  | в производном  | в производном  |
| public         | public         | protected      | недоступен     |
| А{...};        |                |                |                |
| (открытое      |                |                |                |
| наследование)  |                |                |                |
|                |                |                |                |
| class С :      |                |                |                |
| public         |                |                |                |
| В{...};        |                |                |                |
+----------------+----------------+----------------+----------------+
| class В :      | в производном  | в производном  | в производном  |
| protected A    | protected      | protected      | недоступен     |
| {...};         |                |                |                |
|                |                |                |                |
| class С :      |                |                |                |
| public B       |                |                |                |
| {...};         |                |                |                |
+----------------+----------------+----------------+----------------+
| class В :      | в производном  | в производном  | в производном  |
| private А      | private        | private        | недоступен     |
| {...};         |                |                |                |
|                |                |                |                |
| class С :      |                |                |                |
| public В       |                |                |                |
| {...};         |                |                |                |
+----------------+----------------+----------------+----------------+

